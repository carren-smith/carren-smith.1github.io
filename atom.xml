<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jerry那些事儿</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-13T13:18:57.494Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jerry_Cai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SyncToy使用说明</title>
    <link href="http://yoursite.com/2018/02/12/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/SyncToy/SyncToy%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/02/12/软件应用_办公软件/SyncToy/SyncToy使用说明/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-02-13T13:18:57.494Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="SyncToy使用说明"><a href="#SyncToy使用说明" class="headerlink" title="SyncToy使用说明"></a>SyncToy使用说明</h2><ul>
<li>synchronize ：在这个模式下，SyncToy会使得两个文件夹<strong>完全一致</strong>，无论在哪一个文件夹中操作，对应的操作相当于都在另一个文件夹中执行了一次。（也就是我们所说的“同步”）。</li>
<li>echo：echo模式的效果是，使得在左边文件夹中新增加的和被改变的内容会被备份到右边的文件夹中。在左侧被重命名的文件以及被删除了的文件，将也会在右侧的文件夹中删除。（这种模式与synchronize 很像，<strong>差别就在于这里只会从左边同步到右边，右边的操作对左边的文件夹无效~）</strong>。</li>
<li>Contribute ：也就是我们常说的“增量备份”，相当于在echo的基础上，把所有的删除操作都屏蔽掉了，只要在左边文件夹中存在过的文件都会在右侧文件夹中存在。</li>
</ul>
<blockquote>
<p>博客文档，选用echo模式；因为并不是所有的文章都要发表</p>
<p><strong>并且，在右侧删除的内容，对同一个 &lt;同步设置&gt; 再次执行时，右侧被删除的文档不会被再次增加。</strong></p>
</blockquote>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;SyncToy使用说明&quot;&gt;&lt;a href=&quot;#SyncToy使用说明&quot; class=&quot;headerlink&quot; title=&quot;SyncToy使用说明&quot;&gt;&lt;/a&gt;SyncToy使用说明&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;synchroniz
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="办公软件" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Sync" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/Sync/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="办公软件" scheme="http://yoursite.com/tags/%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Sync" scheme="http://yoursite.com/tags/Sync/"/>
    
  </entry>
  
  <entry>
    <title>Python_数据处理_pandas</title>
    <link href="http://yoursite.com/2018/02/06/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86_pandas/"/>
    <id>http://yoursite.com/2018/02/06/软件应用_程序编程/Python/Python_专题总结/Python_数据处理_pandas/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-02-13T13:12:22.596Z</updated>
    
    <content type="html"><![CDATA[<p>pandas 指引 : <a href="http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window" target="_blank" rel="external">http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window</a></p>
<ul>
<li><strong>DataFrame 单独取出一列是 Series 格式</strong></li>
</ul>
<blockquote>
<p>根据pandas的官方文档，重新调整结构</p>
</blockquote>
<a id="more"></a>
<p>[TOC]</p>
<p><br></p>
<p><strong>笔记方法：</strong></p>
<ol>
<li>列出关键的参数</li>
<li>示例部分一定要是自己的代码</li>
<li>其他均可以上网找</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div></pre></td></tr></table></figure>
<blockquote>
<p>官方文档：<a href="http://pandas.pydata.org/pandas-docs/stable/api.html" target="_blank" rel="external">http://pandas.pydata.org/pandas-docs/stable/api.html</a></p>
</blockquote>
<!--more-->
<p><br></p>
<h1 id="Input-Output-输入-输出"><a href="#Input-Output-输入-输出" class="headerlink" title="Input/Output - 输入/输出"></a>Input/Output - 输入/输出</h1><p><br></p>
<h1 id="General-func-一般功能"><a href="#General-func-一般功能" class="headerlink" title="General func - 一般功能"></a>General func - 一般功能</h1><p><br></p>
<h2 id="datetimelike-顶层处理"><a href="#datetimelike-顶层处理" class="headerlink" title="datetimelike 顶层处理"></a>datetimelike 顶层处理</h2><h4 id="pd-to-datetime"><a href="#pd-to-datetime" class="headerlink" title="pd.to_datetime"></a>pd.to_datetime</h4><blockquote>
<p><strong>Convert argument to datetime.</strong></p>
</blockquote>
<p>pandas<strong>.to_datetime(</strong>arg, errors=’raise’, <strong>dayfirst=False,</strong> yearfirst=False, utc=None, <strong>box=True,</strong> <strong>format=None</strong>, exact=True, unit=None, infer_datetime_format=False, origin=’unix’)</p>
<blockquote>
<p><strong>arg</strong> : <u>integer, float, string, datetime, list, tuple, 1-d array, Series</u></p>
<p><strong>errors</strong> : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</p>
<blockquote>
<ul>
<li>If ‘raise’, then invalid parsing will raise an exception (唤起异常)</li>
<li>If ‘coerce’, then invalid parsing will be set as NaT </li>
<li>If ‘ignore’, then invalid parsing will return the input</li>
</ul>
</blockquote>
<p><strong>dayfirst</strong> : boolean, default False</p>
<blockquote>
<p>If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10.</p>
</blockquote>
<p><strong>box</strong> : boolean, default True</p>
<blockquote>
<ul>
<li>If True returns a <u>DatetimeIndex</u></li>
<li>If False returns <u>ndarray of values.</u></li>
</ul>
</blockquote>
<p><strong>format</strong> : string, default None</p>
<blockquote>
<p>strftime to parse time, eg “%d/%m/%Y”, note that “%f” will parse all the way up to nanoseconds (纳秒).</p>
</blockquote>
<p><strong>unit</strong> : string, default ‘ns’  (默认为纳秒)</p>
<blockquote>
<p>unit of the arg (D,s,ms,us,ns) denote the unit, which is an integer or float number.</p>
</blockquote>
<hr>
<p>Return type depends on input:</p>
<ul>
<li>list-like: DatetimeIndex</li>
<li>Series: Series of datetime64 dtype</li>
<li>scalar: Timestamp</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'year'</span>: [<span class="number">2015</span>, <span class="number">2016</span>],</div><div class="line">                       <span class="string">'month'</span>: [<span class="number">2</span>, <span class="number">3</span>],</div><div class="line">                       <span class="string">'day'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</div><div class="line">day	month	year</div><div class="line"><span class="number">0</span>	<span class="number">4</span>	<span class="number">2</span>	<span class="number">2015</span></div><div class="line"><span class="number">1</span>	<span class="number">5</span>	<span class="number">3</span>	<span class="number">2016</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(df)</div><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-02</span><span class="number">-04</span></div><div class="line"><span class="number">1</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-05</span></div><div class="line">dtype: datetime64[ns]  <span class="comment"># 对于一列的DataFrame其实就是一个Series，返回的对象类型为 datetime64 dtype</span></div><div class="line">  </div><div class="line"><span class="comment">#-----------------</span></div></pre></td></tr></table></figure>
<h5 id="pd-to-timedelta"><a href="#pd-to-timedelta" class="headerlink" title="pd.to_timedelta"></a>pd.to_timedelta</h5><h5 id="pd-date-range"><a href="#pd-date-range" class="headerlink" title="pd.date_range"></a>pd.date_range</h5><blockquote>
<p><strong>Return a fixed frequency DatetimeIndex, with day (calendar) as the default frequency</strong></p>
</blockquote>
<p>pandas.<strong>date_range</strong>(start=None, end=None, periods=None, freq=’D’, tz=None, normalize=False, name=None, closed=None, **kwargs)</p>
<p><br></p>
<h5 id="pd-bdate-range"><a href="#pd-bdate-range" class="headerlink" title="pd.bdate_range"></a>pd.bdate_range</h5><h5 id="pd-period-range"><a href="#pd-period-range" class="headerlink" title="pd.period_range"></a>pd.period_range</h5><h5 id="pd-timedelta-range"><a href="#pd-timedelta-range" class="headerlink" title="pd.timedelta_range"></a>pd.timedelta_range</h5><h5 id="pd-infer-freq"><a href="#pd-infer-freq" class="headerlink" title="pd.infer_freq"></a>pd.infer_freq</h5><p><br></p>
<p>#Series</p>
<p><br></p>
<p>#DataFrame</p>
<p><br></p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h4 id="pd-DataFrame"><a href="#pd-DataFrame" class="headerlink" title="pd.DataFrame"></a>pd.DataFrame</h4><p> pandas.<strong>DataFrame</strong>(data=None, index=None, columns=None, dtype=None, copy=False)</p>
<blockquote>
<p><strong>data</strong> : numpy ndarray (structured or homogeneous), dict, or DataFrame</p>
<blockquote>
<p>Dict can contain Series, arrays, constants, or list-like objects</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'col1'</span>: [<span class="number">1</span>, <span class="number">2</span>], <span class="string">'col2'</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(data=d)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">   col1  col2</div><div class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">3</span></div><div class="line"><span class="number">1</span>     <span class="number">2</span>     <span class="number">4</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>##重编索引/选择/标签操作</p>
<h4 id="pd-DataFrame-reindex"><a href="#pd-DataFrame-reindex" class="headerlink" title="pd.DataFrame.reindex"></a>pd.DataFrame.reindex</h4><blockquote>
<p><strong>Conform DataFrame to new index with optional filling logic, placing NA/NaN in locations having no value in the previous index. /   Retrun  reindexed : DataFrame</strong></p>
</blockquote>
<p>DataFrame.<strong>reindex</strong>(labels=None, index=None, columns=None, <strong>axis</strong>=None, <strong>method</strong>=None, copy=True, level=None, <strong>fill_value</strong>=nan, limit=None, tolerance=None)</p>
<blockquote>
<p><strong>labels</strong> : array-like, optional</p>
<blockquote>
<p>New labels / index to conform the axis specified by ‘axis’ to.</p>
</blockquote>
<p><strong>index, columns</strong> : array-like, optional (should be specified using keywords)</p>
<p><strong>axis</strong> : int or str, optional ; <strong>(axis=1, 表示对列进行重排)</strong></p>
<blockquote>
<p>Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1).</p>
</blockquote>
<p><strong>method</strong> : {None, ‘backfill’/’bfill’, ‘pad’/’ffill’, ‘nearest’}, optional  <strong>（仅对调单递增/递减的空位处进行填充 - 向前/向后等）</strong></p>
<blockquote>
<p>method to use for filling holes in reindexed DataFrame. Please note: this is only applicable to DataFrames/Series with a monotonically increasing/decreasing index. </p>
<ul>
<li>default: don’t fill gaps</li>
<li>pad / ffill: propagate last valid observation forward to next valid</li>
<li>backfill / bfill: use next valid observation to fill gap</li>
<li>nearest: use nearest valid observations to fill gap</li>
</ul>
</blockquote>
<p><strong>fill_value</strong> : scalar, default np.NaN</p>
<blockquote>
<p>Value to use for missing values. Defaults to NaN, but can be any “compatible” value</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#--------------- reindex the columns.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(columns=[<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>])  <span class="comment"># 通过columns 来重排</span></div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex([<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>], axis=<span class="string">"columns"</span>)  <span class="comment"># 通过axis 指定来重排 / axis=1 类同</span></div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#--------------- reindex the index.</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>index = [<span class="string">'Firefox'</span>, <span class="string">'Chrome'</span>, <span class="string">'Safari'</span>, <span class="string">'IE10'</span>, <span class="string">'Konqueror'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;</div><div class="line"><span class="meta">... </span>     <span class="string">'http_status'</span>: [<span class="number">200</span>,<span class="number">200</span>,<span class="number">404</span>,<span class="number">404</span>,<span class="number">301</span>],</div><div class="line"><span class="meta">... </span>     <span class="string">'response_time'</span>: [<span class="number">0.04</span>, <span class="number">0.02</span>, <span class="number">0.07</span>, <span class="number">0.08</span>, <span class="number">1.0</span>]&#125;,</div><div class="line"><span class="meta">... </span>      index=index)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">           http_status  response_time</div><div class="line">Firefox            <span class="number">200</span>           <span class="number">0.04</span></div><div class="line">Chrome             <span class="number">200</span>           <span class="number">0.02</span></div><div class="line">Safari             <span class="number">404</span>           <span class="number">0.07</span></div><div class="line">IE10               <span class="number">404</span>           <span class="number">0.08</span></div><div class="line">Konqueror          <span class="number">301</span>           <span class="number">1.00</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -------------Create a new index and reindex the dataframe. </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>new_index= [<span class="string">'Safari'</span>, <span class="string">'Iceweasel'</span>, <span class="string">'Comodo Dragon'</span>, <span class="string">'IE10'</span>,</div><div class="line"><span class="meta">... </span>            <span class="string">'Chrome'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index)</div><div class="line">               http_status  response_time</div><div class="line">Safari               <span class="number">404.0</span>           <span class="number">0.07</span></div><div class="line">Iceweasel              NaN            NaN  <span class="comment">## 无法匹配的索引默认填充 NaN</span></div><div class="line">Comodo Dragon          NaN            NaN</div><div class="line">IE10                 <span class="number">404.0</span>           <span class="number">0.08</span></div><div class="line">Chrome               <span class="number">200.0</span>           <span class="number">0.02</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index, fill_value=<span class="number">0</span>)  <span class="comment"># NaN 用0来填充</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex(new_index, fill_value=<span class="string">'missing'</span>)  <span class="comment"># NaN 用‘missing’来填充</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>#panel - 面板</p>
<p><br></p>
<p>#Index - 索引</p>
<p><br></p>
<p>#Numeric Index - 数字化索引</p>
<p><br></p>
<p>#CategoricalIndex - 分类索引</p>
<p><br></p>
<p>#IntervalIndex - 交互索引</p>
<p><br></p>
<p>#MultiIndex </p>
<p><br></p>
<p>#DatetimeIndex - 日期时间索引</p>
<p><br></p>
<p>#TimedeltaIndex - 时间间隔索引</p>
<p><br></p>
<p>#PeriodIndex - 间隔索引</p>
<p><br></p>
<p>#Scales - 标量</p>
<p><br></p>
<p><br></p>
<p>#Windows  - 窗口</p>
<p><br></p>
<h1 id="Groupby-分组"><a href="#Groupby-分组" class="headerlink" title="Groupby - 分组"></a>Groupby - 分组</h1><p><br></p>
<p>#Resampling  - 重新取样</p>
<p><br></p>
<p>#Style- 样式</p>
<p><br></p>
<p>#General utility func - 通用效用函数</p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<h1 id="old"><a href="#old" class="headerlink" title="old"></a>old</h1><p><br></p>
<h2 id="创建与变更格式"><a href="#创建与变更格式" class="headerlink" title="创建与变更格式"></a>创建与变更格式</h2><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li><strong>pd.Series( [], index=[], name=’’ )</strong>：创建Series</li>
</ul>
<ul>
<li><strong>pd.DataFrame</strong>(np.random.rand(20,5) , index=[], columns=[] )：创建20行5列的随机数组成的DataFrame对象</li>
</ul>
<blockquote>
<p>DataFrame会<strong>自动创建索引，且会被有序排列</strong>； <strong>Index索引对象是不可修改的</strong>。除非在第一次写入时缺少索引列，可进行定义。</p>
<p>传入等长的列表或NumPy数组组成的 <strong>字典</strong>。</p>
<p>若传入的列在数据中查询不到，就会产生NA</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">DataFrame(obj, colums=[], index=[])</div><div class="line"><span class="comment"># columns  按照指定的列进行显示</span></div><div class="line"><span class="comment"># index  指定索引的名称，但并不改变行的顺序; 	若对已存在的索引（eg:嵌套字典），若index中的索引不存在，则不显示</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 创建对象：运用字典--------------------</span></div><div class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohi'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>], <span class="string">'year'</span>: [<span class="number">2000</span>,</div><div class="line">        <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>]&#125;</div><div class="line">frame = DataFrame(data, columns = [<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>])  <span class="comment"># 按照指定列进行排序</span></div><div class="line"></div><div class="line"><span class="comment"># 创建对象：运用列表</span></div><div class="line">pd.DataFrame([[<span class="number">4</span>,<span class="number">7</span>],[<span class="number">5</span>,<span class="number">10</span>]],columns=[<span class="string">'a'</span>,<span class="string">'b'</span>],index=[<span class="number">1</span>,<span class="number">2</span>])</div><div class="line"></div><div class="line"><span class="comment"># ------嵌套字典-----------</span></div><div class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;, <span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, </div><div class="line">       <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</div><div class="line">frame3 = DataFrame(pop)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h2><ul>
<li><strong>df.shape()</strong>：查看行数和列数</li>
<li><strong>df.head(n)</strong>：查看DataFrame对象的前n行</li>
<li><strong>df.tail(n)</strong>：查看DataFrame对象的最后n行</li>
<li><strong>df.describe()</strong>：查看数值型列的汇总统计</li>
<li><strong>df.columns</strong> ：查看列名</li>
<li>s.value_counts(dropna=False)：查看Series对象的唯一值和计数</li>
<li>df.apply(pd.Series.value_counts)：查看DataFrame对象中每一列的唯一值和计数</li>
<li><a href="http://link.zhihu.com/?target=http%3A//df.info%28%29" target="_blank" rel="external">http://df.info()</a>：查看索引、数据类型和内存信息</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><h3 id="重命名-rename"><a href="#重命名-rename" class="headerlink" title="重命名 - rename"></a>重命名 - rename</h3><ul>
<li><strong>df.set_index(‘column_one’)</strong>：更改<strong>索引列</strong></li>
<li><strong>df.columns</strong>：获取当前列名</li>
<li><strong>df.columns = [‘a’,’b’,’c’]</strong>：重命名列名</li>
<li><strong>df.rename( columns = {‘a’ : ‘A’} , inplace = True )</strong>：只修改特定的列；将’a’ 改为 ‘A’<ul>
<li><strong>df.rename(columns=lambda x: x + 1)</strong>：批量更改列名</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">df.rename(columns=&#123;<span class="string">'old_name'</span>: <span class="string">'new_ name'</span>&#125;) <span class="comment"># 选择性更改列名</span></div><div class="line"></div><div class="line">df.rename(columns=<span class="keyword">lambda</span> x: x + <span class="number">1</span>) <span class="comment"># 批量更改列名</span></div><div class="line">df.rename(index=<span class="keyword">lambda</span> x: x + <span class="number">1</span>) <span class="comment"># 批量重命名索引</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="批量重命名-前缀-后缀"><a href="#批量重命名-前缀-后缀" class="headerlink" title="批量重命名  - 前缀/后缀"></a>批量重命名  - 前缀/后缀</h3><ul>
<li><strong>DataFrame.add_prefix(prefix)</strong> ：将<strong>前缀字符串</strong>与面板项名称串联在一起。</li>
<li>DataFrame.add_suffix(suffix)：将<strong>后缀字符串</strong>与面板项名称串联在一起。、</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 分组运算并合并数据</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>).add_prefix(<span class="string">'mean_'</span>)  <span class="comment"># DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。</span></div><div class="line"></div><div class="line">mean_data1	mean_data2</div><div class="line"><span class="number">0</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">1</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">3</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">4</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="排序-sort-valuese"><a href="#排序-sort-valuese" class="headerlink" title="排序 - sort_valuese"></a>排序 - sort_valuese</h3><blockquote>
<p>根据列的值进行排序</p>
</blockquote>
<ul>
<li><strong>df.sort_values(col1)</strong>：按照列col1排序数据，<strong>默认升序</strong>排列</li>
<li><strong>df.sort_values([col1,col2], ascending=[True,False])</strong>：先按列col1升序排列，后按col2降序排列数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.sort_value(col1, ascendding=<span class="keyword">False</span>)</div><div class="line"><span class="comment">## ascendding=False，按照列col1降序排列数据；默认按升序排列</span></div></pre></td></tr></table></figure>
<blockquote>
<p>根据索引调整</p>
</blockquote>
<ul>
<li><strong>df.sort_index(asix=1, ascending=False)</strong> ：根据<strong>索引/列名标签</strong>对数据结构进行调整</li>
</ul>
<blockquote>
<p>若axis=1，则根据<strong>列名的顺序</strong>进行调整结构，行不变。</p>
</blockquote>
<ul>
<li><strong>df.reset_index()</strong>：重新设置行的索引</li>
</ul>
<ul>
<li>s.sort_index() ：根据索引进行排序</li>
</ul>
<ul>
<li>s.order()</li>
</ul>
<p><br></p>
<h3 id="列-行索引重排"><a href="#列-行索引重排" class="headerlink" title="列/行索引重排"></a>列/行索引重排</h3><ul>
<li>DataFrame.<strong>reindex(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None)</strong>：根据新索引进行重新排序<ul>
<li>只显示符合当前索引的值。可加入新的索引值，若不存在则显示为NaN</li>
<li><strong>axsi = 1 ，则表示对 [列 Columns ] 进行重排</strong></li>
<li>支持两种形式（建议采用第二种）<ul>
<li><code>(index=index_labels, columns=column_labels, ...)</code></li>
<li><code>(labels, axis={&#39;index&#39;, &#39;columns&#39;}, ...)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>labels</strong> : array-like, optional. New labels / index to conform the axis specified by ‘axis’ to.</p>
<p>index： 用作索引的新序列</p>
<p><strong>axis</strong> : int or str, optional. Axis to target. Can be either the axis name (‘index’, ‘columns’) or number (0, 1).</p>
<p>fill_value ：缺失值NaN的替代值</p>
<p>method： = ffill /bfill；向前填充/向后填充；<strong>只适用于单调增长/减少的索引</strong></p>
<p>limit： 向前或向后填充的最大填充量； 向前，即正向填充，向后一位数字（数值2位于1的前面）</p>
<p>level ：</p>
<p>copy： 默认为True，无论如何都复制；若为False，则新旧不相等时复制</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">           http_status  response_time</div><div class="line">Firefox            <span class="number">200</span>           <span class="number">0.04</span></div><div class="line">Chrome             <span class="number">200</span>           <span class="number">0.02</span></div><div class="line">Safari             <span class="number">404</span>           <span class="number">0.07</span></div><div class="line">IE10               <span class="number">404</span>           <span class="number">0.08</span></div><div class="line">Konqueror          <span class="number">301</span>           <span class="number">1.00</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.reindex([<span class="string">'http_status'</span>, <span class="string">'user_agent'</span>], axis=<span class="string">"columns"</span>)</div><div class="line">           http_status  user_agent</div><div class="line">Firefox            <span class="number">200</span>         NaN</div><div class="line">Chrome             <span class="number">200</span>         NaN</div><div class="line">Safari             <span class="number">404</span>         NaN</div><div class="line">IE10               <span class="number">404</span>         NaN</div><div class="line">Konqueror          <span class="number">301</span>         NaN</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 将制定的列提到最前面</span></div><div class="line">df.reindex([<span class="string">'mean'</span>] + list(df.columns[:<span class="number">-1</span>]), axis=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<ul>
<li><strong>df.index.is_unique()</strong>：判断<strong>索引值是否唯一</strong>，若某个索引对应多个值，则返回一个Series，否则返回单个值</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="排名-rank"><a href="#排名-rank" class="headerlink" title="排名 - rank"></a>排名 - rank</h3><ul>
<li><strong>df.rank(method = ‘’)</strong>：会把对象的 values <strong>替换成名次</strong> <ul>
<li>排名作用与排序的不同之处在于，它会<strong>把对象的 values 替换成名次</strong>。 这时唯一的问题在于如何处理<strong>平级项</strong>，方法里的 method 参数就是起这个作用的</li>
</ul>
</li>
</ul>
<blockquote>
<p>method 排名时处理平级值的方式。</p>
<p>average ：默认，为各个值分配平均排名</p>
<p>min：使用整个分组的 [最小] 排名</p>
<p>max：使用整个分组的 [最大] 排名</p>
<p>first：按值在原始数据中的出现顺序分配排名</p>
<ul>
<li>max 与 min的区别：相等时，显示的排名按最大/最小排名来显示</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ------------示例-------------</span></div><div class="line">obj = Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]) </div><div class="line">obj.rank(method=<span class="string">'max'</span>)  <span class="comment"># 对于3这个值，最大排序为4，所以显示4</span></div><div class="line"><span class="number">0</span>    <span class="number">1.0</span></div><div class="line"><span class="number">1</span>    <span class="number">2.0</span></div><div class="line"><span class="number">2</span>    <span class="number">4.0</span></div><div class="line"><span class="number">3</span>    <span class="number">4.0</span></div><div class="line"><span class="number">4</span>    <span class="number">7.0</span></div><div class="line"><span class="number">5</span>    <span class="number">7.0</span></div><div class="line"><span class="number">6</span>    <span class="number">7.0</span></div><div class="line"></div><div class="line">obj.rank(method=<span class="string">'min'</span>)  <span class="comment"># 对于3这个值，最下排序为3，所以显示3</span></div><div class="line"><span class="number">0</span>    <span class="number">1.0</span></div><div class="line"><span class="number">1</span>    <span class="number">2.0</span></div><div class="line"><span class="number">2</span>    <span class="number">3.0</span></div><div class="line"><span class="number">3</span>    <span class="number">3.0</span></div><div class="line"><span class="number">4</span>    <span class="number">5.0</span></div><div class="line"><span class="number">5</span>    <span class="number">5.0</span></div><div class="line"><span class="number">6</span>    <span class="number">5.0</span></div></pre></td></tr></table></figure>
<br>

<h3 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h3><ul>
<li>​</li>
</ul>
<p><br></p>
<h3 id="布局转换-长宽格式"><a href="#布局转换-长宽格式" class="headerlink" title="布局转换 - 长宽格式"></a>布局转换 - 长宽格式</h3><blockquote>
<p><strong>宽格式 $\to$  长格式</strong></p>
</blockquote>
<ul>
<li><strong>df.melt(id_vars=[‘A’], value_vars=[‘B’, ‘C’])</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">df.melt(id_ars=[], value_vars=[], var_name=<span class="string">''</span>, value_name=<span class="string">''</span>)</div><div class="line"><span class="comment">## id_vars，以该变量为基准进行重构</span></div><div class="line"><span class="comment">## vaule_vars，需要将哪些变量组合进id列的变量，其值自动填充</span></div><div class="line"></div><div class="line"><span class="comment"># 示例-------------------</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">   A  B  C</div><div class="line"><span class="number">0</span>  a  <span class="number">1</span>  <span class="number">2</span></div><div class="line"><span class="number">1</span>  b  <span class="number">3</span>  <span class="number">4</span></div><div class="line"><span class="number">2</span>  c  <span class="number">5</span>  <span class="number">6</span></div><div class="line"></div><div class="line">df.melt(id_vars=[<span class="string">'A'</span>], value_vars=[<span class="string">'B'</span>, <span class="string">'C'</span>])</div><div class="line"></div><div class="line">   A variable  value</div><div class="line"><span class="number">0</span>  a        B      <span class="number">1</span></div><div class="line"><span class="number">1</span>  b        B      <span class="number">3</span></div><div class="line"><span class="number">2</span>  c        B      <span class="number">5</span></div><div class="line"><span class="number">3</span>  a        C      <span class="number">2</span></div><div class="line"><span class="number">4</span>  b        C      <span class="number">4</span></div><div class="line"><span class="number">5</span>  c        C      <span class="number">6</span></div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p><strong>长格式 $\to$ 宽格式</strong></p>
</blockquote>
<ul>
<li><strong>df.pivot(val1, val2, val3)</strong>：将df的val1作为<strong>[行]</strong>索引的列名，val2为用作<strong>[列]</strong>索引的列名，val3作为用于<strong>[填列值]</strong>的列名</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="层次化索引的重塑-stack"><a href="#层次化索引的重塑-stack" class="headerlink" title="层次化索引的重塑 - stack"></a>层次化索引的重塑 - stack</h3><ul>
<li>stack()：列转行；将数据的列 “旋转” 为行</li>
<li>unstack()：列转行；将数据的行 “旋转” 为列</li>
</ul>
<blockquote>
<p>stack操作的是对<strong>最内层的索引</strong>进行操作。</p>
<blockquote>
<p>若用字符串表示，则直接输入该索引的名称 .stack(‘number’)</p>
<p>若用数字表示，0 - 第一层索引； 1 - 第二层索引</p>
</blockquote>
</blockquote>
<p><br></p>
<h3 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h3><ul>
<li><strong>df.pivot_table(index=col1, values=[col2,col3], aggfunc=max)</strong>：创建一个按列col1进行分组，并计算col2和col3的最大值的数据透视表</li>
</ul>
<p><br></p>
<h2 id="格式：数字、时间与日期"><a href="#格式：数字、时间与日期" class="headerlink" title="格式：数字、时间与日期"></a>格式：数字、时间与日期</h2><blockquote>
<p><strong>pandas库是基于整列的操作</strong></p>
</blockquote>
<h3 id="格式转换-通用"><a href="#格式转换-通用" class="headerlink" title="格式转换 - 通用"></a>格式转换 - 通用</h3><ul>
<li>DataFrame<strong>.astype</strong>(dtype, copy=True, errors=’raise’, **kwargs) ：Cast a pandas object to a specified dtype <code>dtype</code></li>
</ul>
<blockquote>
<p><strong>dtype</strong> : data type, or dict of column name</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser = pd.Series([<span class="number">1</span>, <span class="number">2</span>], dtype=<span class="string">'int32'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line">dtype: int32</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ser.astype(<span class="string">'int64'</span>)</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line">dtype: int64  <span class="comment"># dtype 注意此处</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="数字操作"><a href="#数字操作" class="headerlink" title="数字操作"></a>数字操作</h3><h4 id="格式转换-1"><a href="#格式转换-1" class="headerlink" title="格式转换"></a>格式转换</h4><ul>
<li>pandas.<strong>to_numeric</strong>(arg, errors=’raise’, downcast=None) ：将变量<strong>转为数值类型</strong></li>
</ul>
<blockquote>
<p><strong>arg</strong> : list, tuple, 1-d array, or Series</p>
<p><strong>downcast</strong> : {‘integer’, ‘signed’, ‘unsigned’, ‘float’} , default None</p>
<ul>
<li>‘integer’ or ‘signed’: smallest signed int dtype (min.: np.int8)</li>
<li>‘unsigned’: smallest unsigned int dtype (min.: np.uint8)</li>
<li>‘float’: smallest float dtype (min.: np.float32)</li>
</ul>
</blockquote>
<p><br></p>
<p><br></p>
<h4 id="数字格式定义"><a href="#数字格式定义" class="headerlink" title="数字格式定义"></a>数字格式定义</h4><ul>
<li><strong>str.format( { : } )</strong>  ：格式化输出字符串使用<strong>format()</strong>函数, 字符串即<strong>类</strong>, 可以使用方法。可使用 <code>print(&quot;FORMAT&quot;.format(NUMBER));</code> 来运行示例  <a href="http://blog.xiayf.cn/2013/01/26/python-string-format/" target="_blank" rel="external">http://blog.xiayf.cn/2013/01/26/python-string-format/</a><ul>
<li><strong>语法是{ }中带 : 号</strong>   <code>&#39;{:,}&#39;.format(&#39;str&#39;)</code></li>
<li>符号 <code>{}</code> 是替换变量的占位符</li>
<li>转义大括号：若你需要使用大括号，只要写两次就可以了</li>
</ul>
</li>
</ul>
<blockquote>
<p>字符串的参数使用 <strong>{ num }</strong> 进行表示 ,<strong>0, 表示第一个参数</strong>,<strong>1, 表示第二个参数</strong> </p>
<p>使用<strong>“:”</strong>, 指定代表元素需要的<strong>操作</strong>  , 如”:.3”小数点三位, “:8”占8个字符空间等;</p>
<p>添加特定的<strong>字母</strong></p>
<blockquote>
<p><strong>‘b’</strong> - 二进制. 将数字以2为基数进行输出.</p>
<p>‘c’ - 字符. 在打印之前将整数转换成对应的Unicode字符串.</p>
<p><strong>‘d’</strong> - 十进制整数. 将数字以10为基数进行输出.</p>
<p>‘o’ - 八进制. 将数字以8为基数进行输出. </p>
<p>‘x’ - 十六进制. 将数字以16为基数进行输出, 9以上的位数用小写字母.</p>
<p><strong>‘e’</strong> - 幂符号. 用科学计数法打印数字, 用’e’表示幂. </p>
<p>‘g’ - 一般格式. 将数值以fixed-point格式输出. 当数值特别大的时候, 用幂形式打印. </p>
<p>‘n’ - 数字. 当值为整数时和’d’相同, 值为浮点数时和’g’相同. 不同的是它会根据区域设置插入数字分隔符. </p>
<p><strong>‘%’</strong> - 百分数. 将数值乘以100然后以fixed-point(‘f’)格式打印, 值后面会有一个百分号. </p>
</blockquote>
<p><strong>对齐方式</strong></p>
<blockquote>
<p>&lt; （默认）左对齐</p>
<p>> 右对齐</p>
<p>^ 中间对齐</p>
<p>= （只用于数字）在小数点后进行补齐</p>
</blockquote>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"># 主要用法 </div><div class="line">'&#123;:,&#125;'.format('str')</div><div class="line"></div><div class="line"></div><div class="line"># 符号 &#123;&#125; 是替换变量的占位符。若没有指定格式，则直接将变量值作为字符串插入。 </div><div class="line">"glazed with &#123;&#125; water beside the &#123;&#125; chickens".format("rain", "white")</div><div class="line"></div><div class="line"></div><div class="line"># 可以使用变量的位置数值，在字符串中改变它们，进行格式化时。如果搞错了顺序，你可以轻易地修正而不需要打乱所有的变量。</div><div class="line">s1 = " &#123;0&#125; is better than &#123;1&#125; ".format("emacs", "vim")</div><div class="line">s2 = " &#123;1&#125; is better than &#123;0&#125; ".format("emacs", "vim")</div><div class="line"></div><div class="line"># 默认顺序为0</div><div class="line">str = "Oh &#123;0&#125;, &#123;0&#125;! wherefore art thou &#123;0&#125;?".format("Romeo")</div><div class="line">&gt;&gt;&gt; Oh Romeo, Romeo! wherefore art thou Romeo?</div><div class="line"></div><div class="line"># 命名参数：将新的格式字符串用作模板引擎，使用命名参数，这样就不要求有严格的顺序。</div><div class="line">madlib = " I &#123;verb&#125; the &#123;object&#125; off the &#123;place&#125; ".format(verb="took", object="cheese", place="table")</div><div class="line">&gt;&gt;&gt; I took the cheese off the table</div><div class="line"></div><div class="line"># 转义大括号：若你需要使用大括号，只要写两次就可以了</div><div class="line">print(" The &#123;&#125; set is often represented as &#123; &#123;0&#125; &#125; ".format("empty"))</div></pre></td></tr></table></figure>
<p><br></p>
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>+3.14</td>
<td><strong>带符号</strong>保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1.00</td>
<td><strong>带符号</strong>保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>5</td>
<td>{:0&gt;2d}</td>
<td>05</td>
<td>数字补零 (填充左边, 宽度为2)</td>
</tr>
<tr>
<td>5</td>
<td>{:x&lt;4d}</td>
<td>5xxx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>10</td>
<td>{:x&lt;4d}</td>
<td>10xx</td>
<td>数字补x (填充右边, 宽度为4)</td>
</tr>
<tr>
<td>1000000</td>
<td>{:, }</td>
<td>1,000,000</td>
<td>以<strong>逗号分隔</strong>的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td><strong>百分比</strong>格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00e+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>13</td>
<td>{:10d}</td>
<td>13</td>
<td>右对齐 (默认, 宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:&lt;10d}</td>
<td>13</td>
<td>左对齐 (宽度为10)</td>
</tr>
<tr>
<td>13</td>
<td>{:^10d}</td>
<td>13</td>
<td>中间对齐 (宽度为10)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<p>【应用到列】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义函数</span></div><div class="line">de format_qian(a):</div><div class="line">  b = <span class="string">'&#123;:,&#125;'</span>.format(a)</div><div class="line">  retrun(b)</div><div class="line">  </div><div class="line">qian_all_data[<span class="string">'参与人次'</span>].apply(format_qian)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h3 id="日期操作"><a href="#日期操作" class="headerlink" title="日期操作"></a>日期操作</h3><h4 id="格式转换-2"><a href="#格式转换-2" class="headerlink" title="格式转换"></a>格式转换</h4><p>#####转为日期格式</p>
<ul>
<li>pandas.<strong>to_datetime</strong>( arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’ )：将字符类型转化成<strong>时间格式</strong></li>
</ul>
<blockquote>
<p><strong>dayfirst</strong> : boolean, default False ;  If True, parses dates with the day first, eg 10/11/12 is parsed as 2012-11-10.</p>
<p><strong>box</strong> : boolean, default True</p>
<ul>
<li>If True returns a DatetimeIndex</li>
<li>If False returns ndarray of values.</li>
</ul>
<p><strong>format</strong> : string, default None</p>
<p><strong>errors</strong> : {‘ignore’, ‘raise’, ‘coerce’}, default ‘raise’</p>
<ul>
<li>If ‘raise’, then invalid parsing will raise an exception <strong>引发异常</strong></li>
<li>If ‘coerce’, then invalid parsing will be set as NaT </li>
<li>If ‘ignore’, then invalid parsing will return the input</li>
</ul>
<p><strong>unit</strong> : string, default ‘ns’</p>
<blockquote>
<p>unit of the arg (D,s,ms,us,ns) denote the unit</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(&#123;<span class="string">'year'</span>: [<span class="number">2015</span>, <span class="number">2016</span>],</div><div class="line">                       <span class="string">'month'</span>: [<span class="number">2</span>, <span class="number">3</span>],</div><div class="line">                       <span class="string">'day'</span>: [<span class="number">4</span>, <span class="number">5</span>]&#125;)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(df)</div><div class="line"><span class="number">0</span>   <span class="number">2015</span><span class="number">-02</span><span class="number">-04</span></div><div class="line"><span class="number">1</span>   <span class="number">2016</span><span class="number">-03</span><span class="number">-05</span></div><div class="line">dtype: datetime64[ns]</div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment"># 指定格式  </span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_datetime(<span class="string">'13000101'</span>, format=<span class="string">'%Y%m%d'</span>, errors=<span class="string">'ignore'</span>)</div><div class="line">datetime.datetime(<span class="number">1300</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p>#####转为日期差值</p>
<ul>
<li>pandas.<strong>to_timedelta</strong>(arg, unit=’ns’, box=True, errors=’raise’) ：Convert argument to timedelta<ul>
<li>timedelta <strong>表示两个datetime之间的时间差。</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>pd.to_timedelta([<span class="string">'1 days 06:05:01.00003'</span>, <span class="string">'15.5us'</span>, <span class="string">'nan'</span>])</div><div class="line">TimedeltaIndex([<span class="string">'1 days 06:05:01.000030'</span>, <span class="string">'0 days 00:00:00.000015'</span>, NaT],</div><div class="line">               dtype=<span class="string">'timedelta64[ns]'</span>, freq=<span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<ul>
<li>DatetimeIndex<strong>.strftime(date_format)</strong> ：返回指定格式的<strong>字符串格式</strong></li>
</ul>
<p><br></p>
<ul>
<li>Series<strong>.dt.strftime</strong>(*args, **kwargs) ：<strong>单列</strong>转为字符串格式，<strong>格式化输出</strong></li>
</ul>
<blockquote>
<p><strong>date_format</strong> : str ;      date format string (e.g. “%Y-%m-%d”)</p>
</blockquote>
<ul>
<li><p>Timestamp<strong>.strptime()</strong> ：string, format -&gt; new datetime parsed from a string (like time.strptime()).</p>
<p>​</p>
</li>
</ul>
<p><br></p>
<p>####基本操作</p>
<p><strong>【选取】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 过滤某个时间片的数据&amp;取某个时间片的数据</span></div><div class="line">df[df[<span class="string">'date'</span>]&lt;=pd.datetime(<span class="number">2016</span>,<span class="number">6</span>,<span class="number">10</span>)]</div></pre></td></tr></table></figure>
<p><strong>【返回】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 返回某个日期是周几</span></div><div class="line">pd.to_datetime(df[<span class="string">'date'</span>]).dt.weekday_name   <span class="comment"># 返回星期名；</span></div><div class="line"></div><div class="line">pd.to_datetime(df[<span class="string">'date'</span>]).dt.weekday  <span class="comment"># 返回数字；</span></div></pre></td></tr></table></figure>
<p><strong>【判断】</strong></p>
<ul>
<li><strong>dt.is_month_start</strong> ：判断是否为一个月的第一天</li>
<li><strong>dt.is_month_end</strong>：判断是否为一个月的最后一天</li>
</ul>
<p><br></p>
<p><br></p>
<h4 id="日期格式定义"><a href="#日期格式定义" class="headerlink" title="日期格式定义"></a>日期格式定义</h4><p><strong>【datetime格式定义】</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>4位数的年</td>
</tr>
<tr>
<td>%y</td>
<td>2位数的年</td>
</tr>
<tr>
<td>%m</td>
<td>2位数的月 [01, 12]</td>
</tr>
<tr>
<td>%d</td>
<td>2位数的日 [01, 31]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%F</td>
<td>%Y-%m-%d 简写形式；2012-04-18</td>
</tr>
<tr>
<td>%D</td>
<td>%m/%d/%y 简写形式；04/18/12</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>时间（24小时制） [00, 23]</td>
</tr>
<tr>
<td>%I</td>
<td>时间（12小时制） [00, 12]</td>
</tr>
<tr>
<td>%M</td>
<td>2位数的分钟 [00, 59]</td>
</tr>
<tr>
<td>%S</td>
<td>秒 [00, 61] (秒60和61用于闰秒)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%w</td>
<td>用整数表示的星期几 （星期天为第0天） [0, 6]</td>
</tr>
<tr>
<td>%U</td>
<td>每年的第几周 [00, 53]。<strong>星期天被认为是每周的第一天</strong>，每年第一个星期天之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td>%W</td>
<td>每年的第几周 [00, 53]。<strong>星期一被认为是每周的第一天</strong>，每年第一个星期一之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%z</td>
<td>以+HHMM 或-HHMM 表示的UTC时区偏移量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<p><strong>【特定于当前环境的日期格式】</strong></p>
<table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>星期几的简写</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称</td>
</tr>
<tr>
<td>%b</td>
<td>月份的简写</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称</td>
</tr>
<tr>
<td>%c</td>
<td>完成的日期和时间；Tue 01 May 2012 04:20:57 pm</td>
</tr>
<tr>
<td>%p</td>
<td>不同环境中的AM 或PM</td>
</tr>
<tr>
<td>%x</td>
<td>适用于当前环境的日期格式  ；若在美国， “May 1 2012” 会产生 “05/01/2012”</td>
</tr>
<tr>
<td>%X</td>
<td>适用于当前环境的时间格式； “04:24:12 PM”</td>
</tr>
</tbody>
</table>
<p><br></p>
<p><br></p>
<p><br></p>
<p>##合并数据</p>
<h3 id="横向合并-类同-join"><a href="#横向合并-类同-join" class="headerlink" title="横向合并 - 类同 join"></a>横向合并 - 类同 join</h3><ul>
<li><p><strong>DataFrame</strong>.<strong>join(other, <em>on=None</em>, <em>how=’left’</em>, <em>lsuffix=’’</em>, <em>rsuffix=’’</em>, <em>sort=False</em>)</strong> </p>
<blockquote>
<p><strong>other : DataFrame, Series with name field set, or list of DataFrame</strong></p>
<ul>
<li>方法对象必须是DataFrame，但join的对象可以是多个类型的；通用性比 <code>pd.merge</code> 更加好</li>
</ul>
<p><strong>on</strong> ：若不指定，按照索引来进行join； column name, tuple/list of column names, or array-like Column(s) in the caller to join on the index in other.</p>
<p><strong>lsuffix</strong> / <strong>rsuffix</strong>  : string. Suffix to use from left /right frame’s overlapping columns； 均在已有列名之后跟字符串</p>
<p><strong>sort</strong> : boolean, default False</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 使用索引进行连接</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>caller.join(other, lsuffix=<span class="string">'_caller'</span>, rsuffix=<span class="string">'_other'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>    A key_caller    B key_other</div><div class="line">    <span class="number">0</span>  A0         K0   B0        K0</div><div class="line">    <span class="number">1</span>  A1         K1   B1        K1</div><div class="line">    <span class="number">2</span>  A2         K2   B2        K2</div><div class="line">    <span class="number">3</span>  A3         K3  NaN       NaN</div><div class="line">    <span class="number">4</span>  A4         K4  NaN       NaN</div><div class="line">    <span class="number">5</span>  A5         K5  NaN       NaN</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># 使用关键列进行连接；需要指定连接的列名</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>caller.join(other.set_index(<span class="string">'key'</span>), on=<span class="string">'key'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>pd.merge(df1,df2, on =’val’, how=’inner’)</strong>：将df1，df2根据val列进行内联接<ul>
<li><strong>pd.merge(df1, df2, on = ,[left_on=] how = , [left_index=False, srot=True, copy=True, suffixes=(‘_x’,’_y’)])</strong></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>df1, df2 ：必须都是DataFrame</strong></p>
<p>on = ‘val’  用于连接的列名；若不指定则以列名的交集作为连接列</p>
<ul>
<li>当涉及左右两个表单列名不相同时，需使用left_on / right_on</li>
<li>left_on = ‘val1’   左侧表中用作连接的列</li>
<li>right_on = ‘val2’  右侧表中用作连接的列</li>
</ul>
<p>left_index / right_index =True ,将索引列作为 [连接列]</p>
<p>how = ‘inner’ / ‘left’ / ‘right’ / ‘outer’   （outer为求并集）</p>
<p>sort = True/False ，根据连接列对合并的数据进行排序，默认为True</p>
<p>suffixs，字符串元组，在两个表中有重复的列名时，可用将字符串追加到重叠列名的末尾，默认为(‘_x’,’_y’)</p>
<p>copy = True，默认为True，即将结果复制到数据结构中</p>
</blockquote>
<p><br></p>
<blockquote>
<p>对于层次化索引，以 <strong>[列表的形式]</strong> 指名作用合并键的多个列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; pd.merge(lefth, righth, left_on = [<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="keyword">True</span>)</div><div class="line">&gt;    data   key1  key2  event1  event2</div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></div><div class="line">&gt; <span class="number">1</span>     <span class="number">1</span>   Ohio  <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></div><div class="line">&gt; <span class="number">2</span>     <span class="number">2</span>   Ohio  <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></div><div class="line">&gt; <span class="number">3</span>     <span class="number">3</span>  Nevda  <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></div><div class="line">&gt;</div><div class="line">&gt; lefth</div><div class="line">&gt;    data   key1  key2</div><div class="line">&gt; <span class="number">0</span>     <span class="number">0</span>   Ohio  <span class="number">2000</span></div><div class="line">&gt; <span class="number">1</span>     <span class="number">1</span>   Ohio  <span class="number">2001</span></div><div class="line">&gt; <span class="number">2</span>     <span class="number">2</span>   Ohio  <span class="number">2002</span></div><div class="line">&gt; <span class="number">3</span>     <span class="number">3</span>  Nevda  <span class="number">2001</span></div><div class="line">&gt; <span class="number">4</span>     <span class="number">4</span>  Nevda  <span class="number">2002</span></div><div class="line">&gt;</div><div class="line">&gt; righth</div><div class="line">&gt;             event1  event2</div><div class="line">&gt; Nevda <span class="number">2001</span>       <span class="number">0</span>       <span class="number">1</span></div><div class="line">&gt;       <span class="number">2000</span>       <span class="number">2</span>       <span class="number">3</span></div><div class="line">&gt; Ohio  <span class="number">2000</span>       <span class="number">4</span>       <span class="number">5</span></div><div class="line">&gt;       <span class="number">2000</span>       <span class="number">6</span>       <span class="number">7</span></div><div class="line">&gt;       <span class="number">2001</span>       <span class="number">8</span>       <span class="number">9</span></div><div class="line">&gt;       <span class="number">2002</span>      <span class="number">10</span>      <span class="number">11</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h3 id="纵向合并-增加行"><a href="#纵向合并-增加行" class="headerlink" title="纵向合并 - 增加行"></a>纵向合并 - 增加行</h3><ul>
<li><strong>df1.append(df2)</strong>：将df2中的 <strong>[行]</strong> 添加到df1的尾部</li>
</ul>
<ul>
<li><strong>df.concat([df1,df2], ignore_index = True)</strong> ：纵向合并，将df2中的 <strong>[所有行] 添加到df1的尾部</strong></li>
</ul>
<blockquote>
<p>ignore_index = True，表示进行纵向合并，不保留轴上的索引，产生一组新的索引 </p>
</blockquote>
<p><br></p>
<p><br></p>
<h2 id="数据选取与删除"><a href="#数据选取与删除" class="headerlink" title="数据选取与删除"></a>数据选取与删除</h2><h3 id="行列选取"><a href="#行列选取" class="headerlink" title="行列选取"></a>行列选取</h3><blockquote>
<p>涉及<strong>布尔判断</strong>时，默认的对象为<strong>所有观测行的所有列</strong></p>
<p>选取的内容会包含<strong>索引</strong>与<strong>数值</strong></p>
<p>通过索引方式返回的列只是相应数据的视图。对此所做的任何修改，<strong>会直接反映到源数据。</strong></p>
</blockquote>
<ul>
<li><strong>df[col]</strong>：根据列名，并以<strong>Series的形式</strong>返回 [列]</li>
<li><strong>df[ [col1, col2] ]</strong>：以<strong>DataFrame形式</strong>返回 [多列]</li>
<li><strong>df[ df[col] &gt; 0.5 ]</strong>：选择col列的值大于0.5的所有行<ul>
<li>先对 df[col] &gt;0.5 进行布尔判断，返回True 和 False，再选取所有True的值</li>
<li><strong><u>对具体的观测行进行条件选取</u></strong> ；等价于 <code>Select * From table where col &gt; 0.5</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>也可为布尔型数组(过滤行)、切片（行切片）、布尔型DataFrame</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 指定列中的特定值，并返回所有的行</span></div><div class="line">data[data[<span class="string">'three'</span>]&gt;<span class="number">5</span>]</div><div class="line">          one  two  three  four</div><div class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></div><div class="line">Utah        <span class="number">8</span>    <span class="number">9</span>     <span class="number">10</span>    <span class="number">11</span></div><div class="line">New York   <span class="number">12</span>   <span class="number">13</span>     <span class="number">14</span>    <span class="number">15</span></div><div class="line"></div><div class="line"><span class="comment"># 返回布尔值</span></div><div class="line">data &gt; <span class="number">5</span></div><div class="line">            one    two  three   four</div><div class="line">Ohio      <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span>  <span class="keyword">False</span></div><div class="line">Colorado  <span class="keyword">False</span>  <span class="keyword">False</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div><div class="line">Utah       <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div><div class="line">New York   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span>   <span class="keyword">True</span></div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>df.loc[ n [, m] ]</strong> ：通过 <strong>[ 行标签 ] </strong>索引<strong>行数据</strong> 。 主要基于<strong><u>标签</u></strong>的, 但也可以与<strong><u>布尔数组</u></strong>一起使用。<ul>
<li>n 为行标签；若行标签为字符串，则也需要用字符串表示。loc[‘d’] 表示索引的是第’d’行（index 是字符）</li>
<li>若出现m，则表示可以索引行与列</li>
<li><strong>起始索引值为0；</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>df.iloc[ n [,m] ]</strong>：通过 <strong>[ 行号 ] </strong> 索引<strong>行数据</strong> 。 主要基于<strong><u>整数位置</u></strong> (从0到 length-1 轴), 但也可以与<strong><u>布尔数组</u></strong>一起使用。<ul>
<li>n 为行号；</li>
<li>若出现m，则表示可以索引行与列</li>
</ul>
</li>
</ul>
<blockquote>
<p>loc 在index的标签上进行索引,<strong>范围包括start和end.</strong> </p>
<p>iloc 在index的位置上进行索引,<strong>不包括end.</strong> </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ---- loc -------</span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </div><div class="line">index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]  </div><div class="line">df = pd.DataFrame(data=data, index=index, columns=columns)  </div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df </div><div class="line">a	b	c</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"><span class="number">2</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span> df[<span class="number">0</span>:<span class="number">1</span>]</div><div class="line">a	b	c</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">2</span>	<span class="number">3</span></div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"></div><div class="line"><span class="comment"># 索引某行某列</span></div><div class="line">df.loc[<span class="string">'d'</span>,[<span class="string">'b'</span>,<span class="string">'c'</span>]]  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ---- iloc -------</span></div><div class="line"><span class="comment">## 索引第一列的所有数据</span></div><div class="line">df.iloc[:,[<span class="number">1</span>]]</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="多条件选取"><a href="#多条件选取" class="headerlink" title="多条件选取"></a>多条件选取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">data = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]  </div><div class="line">index = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]  </div><div class="line">columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]  </div><div class="line">df = pd.DataFrame(data=data, index=index, columns=columns)  </div><div class="line"></div><div class="line"><span class="comment"># 所有列的多条件选取</span></div><div class="line">df[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>)]</div><div class="line"></div><div class="line">    a	b	c</div><div class="line"><span class="number">1</span>	<span class="number">4</span>	<span class="number">5</span>	<span class="number">6</span></div><div class="line"><span class="number">2</span>	<span class="number">7</span>	<span class="number">8</span>	<span class="number">9</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 指定列的多条件选取</span></div><div class="line">df[<span class="string">'c'</span>][(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>)]</div><div class="line"><span class="number">1</span>    <span class="number">6</span></div><div class="line"><span class="number">2</span>    <span class="number">9</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 指定列的多条件选取</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'c'</span>]</div><div class="line"><span class="number">1</span>    <span class="number">6</span></div><div class="line"><span class="number">2</span>    <span class="number">9</span></div><div class="line">Name: c, dtype: int64</div><div class="line"><span class="comment"># 指定多列的 多条件选择</span></div><div class="line">df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'b'</span>:<span class="string">'c'</span>]</div><div class="line"></div><div class="line"></div><div class="line">    </div><div class="line"><span class="comment"># 获取值</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.loc[(df[<span class="string">'b'</span>]&gt;<span class="number">2</span> ) &amp; (df[<span class="string">'a'</span>]&gt;<span class="number">1</span>),<span class="string">'c'</span>].values</div><div class="line">array([<span class="number">6</span>, <span class="number">9</span>], dtype=int64)</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>df.ix[1, val ] 因为容易混淆，建议不使用。</p>
</blockquote>
<ul>
<li><strong>df.ix[1, val ]</strong>：<strong>既能通过行号，也可以通过索引位置来进行选取</strong>，但ix中的索引<strong>右端为包含</strong>； 因为容易混淆，建议不要使用。<ul>
<li><strong>若行的索引名为数字时，在进行选中时，选择的为行索引的数值名称，而非位置</strong></li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 因行索引不为数字，故代表位置，右端不包含</span></div><div class="line">data.ix[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line">          one  two  three  four</div><div class="line">Ohio        <span class="number">0</span>    <span class="number">1</span>      <span class="number">2</span>     <span class="number">3</span></div><div class="line">Colorado    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span>     <span class="number">7</span></div><div class="line"></div><div class="line"><span class="comment"># 因行索引为数字，故代表的为行索引的名称</span></div><div class="line">data.ix[<span class="number">0</span>:<span class="number">2</span>]</div><div class="line">	Id	Survived</div><div class="line"><span class="number">0</span>	<span class="number">1</span>	<span class="number">0</span></div><div class="line"><span class="number">1</span>	<span class="number">2</span>	<span class="number">1</span></div><div class="line"><span class="number">2</span>	<span class="number">3</span>	<span class="number">1</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###条件选取 - filter</p>
<ul>
<li><strong>df.filter(item=[val], like= , regex=’’, axis=1)</strong>：选择DataFrame中满足条件的子集<ul>
<li><strong><u>filter的条件判断是对 行索引/ 列名 进行的匹配，而非具体的观测值</u></strong></li>
</ul>
</li>
</ul>
<blockquote>
<p> item：指定的列名；若不指定，则表示全体</p>
<p> regex：满足正则表达式的<strong>列名</strong> ，此时axis=1</p>
<p> like ：满足like的行索引的<strong>所有行</strong>，此时axis=0  （该功能是SQL中没有的）</p>
<p> axis = 1 ：基于列； </p>
<p> axis = 0 ：基于行</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df</div><div class="line">one  two  three</div><div class="line">mouse     <span class="number">1</span>    <span class="number">2</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select columns by name</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(items=[<span class="string">'one'</span>, <span class="string">'three'</span>])</div><div class="line">         one  three</div><div class="line">mouse     <span class="number">1</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select columns by regular expression</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(regex=<span class="string">'e$'</span>, axis=<span class="number">1</span>)</div><div class="line">         one  three</div><div class="line">mouse     <span class="number">1</span>      <span class="number">3</span></div><div class="line">rabbit    <span class="number">4</span>      <span class="number">6</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># select rows containing 'bbi'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.filter(like=<span class="string">'bbi'</span>, axis=<span class="number">0</span>)</div><div class="line">one  two  three</div><div class="line">rabbit    <span class="number">4</span>    <span class="number">5</span>      <span class="number">6</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###随机与排序选取</p>
<ul>
<li><strong>df.sample(frac=0.5)</strong>：随机选取所有数据中的50%的观测行</li>
<li><strong>df.sample(n=10)</strong>：随机选取10行</li>
<li><strong>df.nlargest(n, ‘value’)</strong>：根据’value’进行排列，并选取最前面的n个值</li>
<li><strong>df.nsmallest(n, ‘value’)</strong>:根据n进行排序，并选取最后面的n个值</li>
</ul>
<ul>
<li>s.iloc[0]：按位置选取数据</li>
<li>s.loc[‘index_one’]：按索引选取数据</li>
</ul>
<br>



<h3 id="重复值-duplicated"><a href="#重复值-duplicated" class="headerlink" title="重复值 - duplicated"></a>重复值 - duplicated</h3><ul>
<li><strong>df.duplicated()</strong>：<strong>判断</strong>是否有重复行</li>
<li><strong>df.duplicates()</strong>：<strong>移除</strong>重复行，默认<strong>保留第一个出现的值</strong>组合<ul>
<li><strong>df.duplicates([val1, val2], take_last=True)</strong>：指定部分列进行重复项判断； take_last=True 指定保留最后一个</li>
</ul>
</li>
</ul>
<ul>
<li>s.dropna()：将Series中删除所有包含空值的行</li>
<li>s.astype(float)：将Series中的数据类型更改为float类型</li>
<li>s.replace(1,’one’)：用‘one’代替所有等于1的值</li>
<li>s.replace([1,3],[‘one’,’three’])：用’one’代替1，用’three’代替3</li>
</ul>
<p><br></p>
<h3 id="唯一值-unique"><a href="#唯一值-unique" class="headerlink" title="唯一值 - unique"></a>唯一值 - unique</h3><ul>
<li><strong>df[‘val’].unique</strong>：返回某一列的唯一值</li>
<li><strong>df.[‘val’].value_conuts</strong>：计算列中每个值出现的次数</li>
</ul>
<p><br></p>
<h3 id="数据删除-drop"><a href="#数据删除-drop" class="headerlink" title="数据删除 - drop"></a>数据删除 - drop</h3><ul>
<li><strong>df.drop(val, axis=0 )</strong>：删除<strong>索引行/变量列</strong>，并返回一个<strong>新的对象</strong></li>
</ul>
<blockquote>
<p><strong>axis默认为0</strong>，删除索引为val1,val2的<strong>观测 [行]</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">df.drop([val1,val2], axis=<span class="number">1</span>)  <span class="comment"># 删除列名为val1,val2的 [列]，并返回一个新的对象；</span></div></pre></td></tr></table></figure>
<ul>
<li>s.drop()</li>
</ul>
<p><br></p>
<h3 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h3><h3 id="返回某列中不为NUll的所有行"><a href="#返回某列中不为NUll的所有行" class="headerlink" title="返回某列中不为NUll的所有行"></a>返回某列中不为NUll的所有行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">data1 = data0[data0[<span class="string">'column'</span>].notnull()]</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="创建新变量"><a href="#创建新变量" class="headerlink" title="创建新变量"></a>创建新变量</h2><blockquote>
<p><strong>往往需要用到apply函数，然后用 merge 或者 join 来进行合并</strong></p>
</blockquote>
<p><br></p>
<h3 id="增加列"><a href="#增加列" class="headerlink" title="增加列"></a>增加列</h3><ul>
<li><strong>df[‘Volumn’]</strong> = df.Length * df.Height</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">219</span>]: df[<span class="string">'b'</span>]=<span class="number">1</span>  </div><div class="line">  </div><div class="line">In [<span class="number">220</span>]: df  </div><div class="line">Out[<span class="number">220</span>]:   </div><div class="line">   c  a  b  </div><div class="line"><span class="number">0</span>  <span class="number">1</span>  <span class="number">5</span>  <span class="number">1</span>  </div><div class="line"><span class="number">1</span>  <span class="number">2</span>  <span class="number">6</span>  <span class="number">1</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>pd.Series</strong>(my_list)：从可迭代对象my_list创建一个Series对象</li>
</ul>
<blockquote>
<p>若不指定索引 index = [‘’, ‘’ ] ，则会自动创建从0开始的索引列</p>
<p>通过索引返回/赋值的数据，是对应数据的视图；<strong>所做的修改都会直接反映在源数据上；</strong></p>
<p>算术运算中，会<strong>自动对齐不同索引的数据</strong>，若<strong>对应索引不存在，则填充为NaN</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">obj2 = Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index = [<span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])  <span class="comment"># 指定索引</span></div><div class="line"></div><div class="line"><span class="comment"># 字典创建：字典中的 键 = 索引</span></div><div class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Orgen'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</div><div class="line">obj3 = Series(sdata)</div></pre></td></tr></table></figure>
<ul>
<li><strong>df.index = pd.date_range</strong>(‘1900/1/30’, periods=df.shape[0])：增加一个日期索引</li>
</ul>
<p><br></p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul>
<li><strong>DataFrame.apply</strong>(func, axis=0, broadcast=False, raw=False, reduce=None, args=(), **kwds)<ul>
<li><strong>若提前定义了函数，默认将之前的才变量传入为第一个参数</strong>； 例如 apply(sum)，其实是将变量传递给sum()的第一个变量</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>func</strong> : Function to apply to <strong>each column/row</strong></p>
<ul>
<li>np.mean / np.sum  ：常规统计函数均可用np.xxx 表示对每一列使用该函数</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.apply(numpy.sum, axis=<span class="number">0</span>) <span class="comment"># equiv to df.sum(0)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 定义链接的函数；为apply做准备；</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(a)</span>:</span></div><div class="line">    a = str(a)  <span class="comment"># 必须是字符串格式</span></div><div class="line">    link = <span class="string">'http://xinyitong.gensee.com/webcast/site/entry/join-5c9543e2905146aa9a6f2b16bd1f6de0'</span></div><div class="line">    c = <span class="string">'?nickName=visitor'</span></div><div class="line">    <span class="keyword">return</span> (link + c + a)</div><div class="line">  </div><div class="line">  </div><div class="line">link_add = tb0[<span class="string">'员工编号'</span>].apply(link);</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="重编码-字符串"><a href="#重编码-字符串" class="headerlink" title="重编码 - 字符串"></a>重编码 - 字符串</h2><blockquote>
<p>字符串操作：Python内置、Re模块、矢量化操作</p>
<p>Re模块的函数主要分三个大类：匹配模式、替换、拆分</p>
<p><strong>矢量化”(简化)是重写循环的过程，使得不是将阵列的单个元素处理N次，而是将阵列的4个元素同时N / 4次处理。</strong></p>
<ul>
<li><strong>使用 str.func</strong> </li>
<li><strong>在str属性上使用索引</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># 使用str.func</span></div><div class="line">&gt; matches = df.str.match(pattern)</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment"># 在str属性上使用索引</span></div><div class="line">&gt; matches.str[<span class="number">0</span>]</div><div class="line">&gt;</div><div class="line">&gt; matches.str.get(<span class="number">1</span>)</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<ul>
<li><strong>常常需要结合 apply 函数进行批量操作</strong></li>
</ul>
<p><br></p>
<h3 id="匹配-find-amp-match-amp-search"><a href="#匹配-find-amp-match-amp-search" class="headerlink" title="匹配 - find &amp; match &amp; search"></a>匹配 - find &amp; match &amp; search</h3><blockquote>
<p>Python 内置</p>
</blockquote>
<ul>
<li><strong>find()</strong>：返回<strong>第一个发现的子串的第一个字符</strong>所在的位置；否则返回 -1</li>
<li><strong>rfind()</strong>：返回<strong>最后一个发现的子串的第一个字符</strong>所在的位置；否则返回 -1</li>
<li><strong>index()</strong>：返回子串第一个字符所在的<strong>位置</strong>；若没有找到返回ValueError</li>
<li><strong>startswith() / endswith()</strong> ：判断字符是否以<strong>某个前缀/后缀 开始或结尾</strong>，返回True</li>
<li><strong>count</strong>：返回子串在字符串中出现的次数<strong>（非重复）</strong></li>
</ul>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><strong>match(pattern, string, flags=0)</strong>：字符串string的<strong>开头 开始搜索</strong>正则表达式模式pattern；若匹配成功，则返回一个匹配对象<u>（仅返回匹配的部分）</u>；否则返回None</li>
<li><strong>search(pattern,string, flags=0)</strong>：从字符串string中<strong>（任意位置）</strong>搜索正则表达式模式pattern <strong>第一次出现的地方</strong>； 如果匹配成功，则返回一个匹配对象；否则返回None</li>
<li><strong>findall(pattern, string [,flags])</strong> ：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，并返回一个匹配对象的 <strong>[列表 list]</strong></li>
<li><strong>finditer(pattern, string [, flags])</strong>：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，返回一个<strong>迭代器</strong>，该迭代器返回一个匹配对象</li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化的字符串方法</p>
<p><strong>df.str.func</strong></p>
</blockquote>
<ul>
<li><p>match() ：根据指定的正则表达式<strong>对各个元素执行</strong>re.match</p>
</li>
<li><p>findall()</p>
</li>
<li><p>startswith / endswith </p>
</li>
<li><p><strong>contains()</strong> ：返回各字符串是<strong>否含有指定模式的布尔型数组</strong></p>
</li>
<li><p>count：模式出现的次数</p>
<p>​</p>
</li>
</ul>
<p><br></p>
<h3 id="替换-replace-amp-sub"><a href="#替换-replace-amp-sub" class="headerlink" title="替换 - replace &amp; sub"></a>替换 - replace &amp; sub</h3><blockquote>
<p>python内置</p>
</blockquote>
<ul>
<li><strong>strip / lstrip / rstrip</strong>：去除空格（包括换行符）。相当于对各个元素执行x.strip()</li>
<li><strong>ljust /rjust</strong> ：<strong>用空格（或其他字符）填充</strong>字符串的空白侧以返回符合最低宽度的字符串</li>
</ul>
<ul>
<li><p><strong>df.replace(1,’one’)</strong>：用‘one’代替所有等于1的值</p>
<ul>
<li><strong>df.replcae([1,2], [‘one’, ‘two’])</strong> ：多个值之间替换</li>
<li><strong>df.replace({-999:na.nan, -1000:0})</strong>： 传入的参数也可以是字典</li>
</ul>
<blockquote>
<p>replace - 替换； 此处的替换为<strong>对整个值进行查找</strong>，而非值中的部分值</p>
<p>eg: 第3个观测行daf\n ，无法用 data.replace(’\n‘, ‘’) 进行替换</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">df.replace(old, new [,max])  <span class="comment"># 将old值替换为new</span></div><div class="line"><span class="comment"># max，可选字符串, 替换不超过 max 次</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>lower / upper ()</strong> ：转化为小写/大写</li>
</ul>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><p><strong>re.sub(pattern, repl ,string, max = 0)</strong> : 把字符串string中所有匹配正则表达式pattern的地方 <strong>替换</strong>成 字符串 repl </p>
<ul>
<li>如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。</li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行替换</p>
</blockquote>
</li>
<li><p><strong>subn()</strong> ：该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数</p>
</li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化的字符串</p>
</blockquote>
<ul>
<li><strong>strip / lstrip / rstrip</strong>：去除空格（包括换行符）。相当于对各个元素执行x.strip()</li>
<li><strong>pad()</strong>：在字符串左边、右边或两侧添加空白符</li>
<li><strong>center()</strong>：相当于pad(side=’both’)</li>
<li><strong>replace()</strong>：用指定字符串替换找到的模式</li>
<li><strong>repeat()</strong>：重复值； s.str.repeat(3) 相当于对各个字符串执行 x *3 </li>
<li><strong>get()</strong>：获取各元素的第i个元素</li>
<li><strong>len()</strong>：计算各字符串长度</li>
<li><strong>lower / upper ()</strong> ：转化为小写/大写</li>
</ul>
<p><br></p>
<p><br></p>
<h3 id="分隔与连接"><a href="#分隔与连接" class="headerlink" title="分隔与连接"></a>分隔与连接</h3><blockquote>
<p>Python内置</p>
</blockquote>
<ul>
<li><p><strong>split</strong>：通过指定的分隔符将字符串拆分为一组子串</p>
</li>
<li><p><strong>‘sep’.join(seq)</strong> ：将字符串用作<strong>连接</strong>其他字符串序列的<strong>分隔符</strong></p>
<blockquote>
<p>sep：分隔符；可以为空</p>
<p>seq：要连接的元素序列、字符串、元组、字典</p>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>seq1 = [<span class="string">'hello'</span>,<span class="string">'good'</span>,<span class="string">'boy'</span>,<span class="string">'doiido'</span>]  </div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">':'</span>.join(seq1)  </div><div class="line">hello:good:boy:doiido</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>Re模块</p>
</blockquote>
<ul>
<li><strong>split</strong>：根据找到的模式将字符串<strong>拆分为数段</strong></li>
</ul>
<p><br></p>
<blockquote>
<p>矢量化字符串函数</p>
</blockquote>
<ul>
<li><strong>split()</strong></li>
<li><strong>slice()</strong>：对Series中的各个字符串进行子串截取；</li>
<li><strong>cat()</strong>：实现元素级的字符串连接操作，可指定分隔符</li>
</ul>
<p><br></p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><ol>
<li><strong>dir()</strong>：获得对象的所有属性与类型 </li>
<li><strong>type()</strong>  - 判断对象类型</li>
<li><strong>instance()</strong>  - 判断一个对象<strong>是否为某种类型：返回布尔值Ture/Falses</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 指定判断类型</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'a'</span>, str)</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">123</span>, int)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="comment"># 先创建判断的对象</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = Animal()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>d = Dog()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>h = Husky()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(h, Husky)</div><div class="line"><span class="keyword">True</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 还可以判断一个变量是否是某些类型中的一种</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (list, tuple))</div><div class="line"><span class="keyword">True</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (list, tuple))</div><div class="line"><span class="keyword">True</span></div></pre></td></tr></table></figure>
<blockquote>
<p>能用type()判断的基本类型也可以用isinstance()判断</p>
</blockquote>
<p><br></p>
<h3 id="常规格式转化"><a href="#常规格式转化" class="headerlink" title="常规格式转化"></a>常规格式转化</h3><ul>
<li>int(x [,base ]) ：将x转换为一个<strong>整数</strong></li>
<li>long(x [,base ]) ：将x转换为一个长整数    </li>
<li><strong>float(x)</strong>：将x转换到一个浮点数    </li>
<li><strong>str(x)</strong>：将对象 x 转换为<strong>字符串</strong>    </li>
<li>repr(x)：将对象 x 转换为表达式字符串    </li>
<li>eval(str) ：用来计算在字符串中的有效Python表达式,并返回一个对象    </li>
<li>tuple(s)：将序列 s 转换为一个元组    </li>
<li>list(s)：将序列 s 转换为一个列表    </li>
<li><strong>chr(x)</strong> ：将一个整数转换为一个<strong>字符</strong>    </li>
<li>unichr(x) ：将一个整数转换为<strong>Unicode字符</strong>    </li>
<li>ord(x)：将一个字符转换为它的<strong>整数值</strong></li>
<li>hex(x)：将一个整数转换为一个十六进制字符串 </li>
<li>oct(x)：将一个整数转换为一个八进制字符串   </li>
<li>complex(real [,imag ])：创建一个复数</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="缺失值"><a href="#缺失值" class="headerlink" title="缺失值"></a>缺失值</h2><p>###判断</p>
<ul>
<li><strong>df.isnull()</strong>：检查DataFrame对象中的空值，并返回一个Boolean数组</li>
<li><strong>df.notnull()</strong>：检查DataFrame对象中的非空值，并返回一个Boolean数组</li>
</ul>
<blockquote>
<p>Python中内置的<code>None</code>会被当做NA处理</p>
<p>pandas用浮点值NaN (Not a Number) 表示浮点和非浮点数据中的缺失数据；其类型为 float</p>
</blockquote>
<p><br></p>
<p>###移除</p>
<ul>
<li><strong>df.dropna()</strong>：删除所有包含空值的行，返回为剔除后的对象（<strong>一行中只要有一个值为NaN，就删除整行</strong>）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">df.dropna(how=<span class="string">'all'</span>, axis=<span class="number">1</span>, thresh=n)</div><div class="line"></div><div class="line"><span class="comment">## how='all', 指定排除一行中 [所有值均NA] 行/列</span></div><div class="line"><span class="comment">## axis=1, 删除所有包含空值的 [列]; 默认axis=0, 即删除所有包含空置的[行]</span></div><div class="line"><span class="comment">## axis=1,thresh=n, 删除所有 [小于n个非空值] 的 [行]</span></div></pre></td></tr></table></figure>
<p><br></p>
<p>###重编码</p>
<ul>
<li><strong>df.fillna(x, inplace=True)</strong>：用x替换DataFrame对象中所有的空值，inplace表示在源数据中修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fillna(value [, method = <span class="string">'ffill'</span>,limit =n, axis=<span class="number">0</span>, inplace=<span class="keyword">False</span>])</div><div class="line"><span class="comment"># value 填充值</span></div><div class="line"><span class="comment"># method 差值方式，默认为ffill；也可为bfill</span></div><div class="line"><span class="comment"># limit  可以连续填充的最大数量</span></div><div class="line"><span class="comment"># axis 待填充的轴，默认为0</span></div><div class="line"><span class="comment"># inplace 默认为False，表示返回新对象；若为True，则对原始数据进行修改</span></div><div class="line"></div><div class="line">df.fillna(<span class="number">0</span>)  <span class="comment"># 将缺失值替换为0</span></div><div class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">3</span>: <span class="number">-1</span>&#125;)  <span class="comment"># 对位置值为1的 [列]，缺失值替换为0.5；即对第二列，将NaN值替换为0.5</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="汇总与描述统计"><a href="#汇总与描述统计" class="headerlink" title="汇总与描述统计"></a>汇总与描述统计</h2><blockquote>
<p>常规情况下，axis=1 代表列； axis=0 代表行；</p>
<p><strong>计算情况下</strong>，axis=1 代表<strong>沿着每一行遍历所有的列，并向下执行方法</strong></p>
</blockquote>
<p><br></p>
<h3 id="常规统计值"><a href="#常规统计值" class="headerlink" title="常规统计值"></a>常规统计值</h3><ul>
<li>count()：非NA的数量</li>
<li>describe()：计算统计汇总</li>
<li>sum()</li>
<li>mean() / median() </li>
<li>quantile()</li>
<li>min() / max()</li>
<li>var()：方差 / std()：标准差</li>
<li>mad() :根据平均值计算平均绝对离差</li>
<li>argmin() / argmax()：计算能够获取到最小值/最大值的<strong>索引位置（整数）</strong>  （对应 iloc）</li>
<li>idxmin() / idxmax()：计算能过获取到最小值/最大值的所<strong>索引值</strong>  （对应loc）</li>
</ul>
<p><br></p>
<h3 id="常规统计值-高阶"><a href="#常规统计值-高阶" class="headerlink" title="常规统计值 - 高阶"></a>常规统计值 - 高阶</h3><ul>
<li>cumsum()：累计和</li>
<li>cummin() /cummax() ：累计最小值/累计最大值</li>
<li>cumprod()：累计积</li>
<li>skew()：偏度（三阶矩）</li>
<li>kurt()：峰度（四阶矩）</li>
<li>diff()：一阶差分（对时间序列很有用）</li>
<li>pct_change()：百分数变化</li>
<li>corr()：相关系数</li>
<li>ocv()：协方差</li>
</ul>
<p><br></p>
<h2 id="数据聚合与分组"><a href="#数据聚合与分组" class="headerlink" title="数据聚合与分组"></a>数据聚合与分组</h2><p>分组聚合是由三个过程来组成的：拆分Split - 应用Apply - 合并Combine</p>
<ol>
<li>数据根据所提供的<strong>一个或多个键被拆分 (Split) 为多组</strong>。并且拆分操作是在<strong>对象的特定轴 (axis=1 列； 或 axis=0 - 行)上执行的</strong></li>
<li>将一个函数Apply应用到各个分组并产生一个新的值</li>
<li>将所有的结果合并Combine到最终结果的对象中</li>
</ol>
<blockquote>
<p><strong>grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df[‘key1’]的中间数据而已。该对象已经有了所需的一切信息</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">df = pd.DataFrame(&#123;<span class="string">'key1'</span>:[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>,<span class="string">'a'</span>],</div><div class="line">               <span class="string">'key2'</span>:[<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'one'</span>],</div><div class="line">               <span class="string">'data1'</span>:np.random.randn(<span class="number">5</span>),</div><div class="line">               <span class="string">'data2'</span>:np.random.randn(<span class="number">5</span>)&#125;)</div><div class="line"></div><div class="line"><span class="comment"># grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已</span></div><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div><div class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x000000000876EBA8</span>&gt;</div><div class="line"></div><div class="line"><span class="comment"># 调用GroupBy的方法进行聚合计算</span></div><div class="line">grouped.mean()</div><div class="line">       key1</div><div class="line">a    <span class="number">0.486419</span></div><div class="line">b   <span class="number">-0.771562</span></div><div class="line">Name: data1, dtype: float64</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><blockquote>
<p>groupby：在分组的基础上，计算<strong>非NA</strong>的值统计量；</p>
<p>并且对<strong>所有的数值数据</strong>进行统计计算，而对非数据数据列则会排除。</p>
<p><strong>默认对axis=0上进行分组；该场景应认为是计算的场景，axis=0  表示以列为单位，遍历每一行；即对该列中的各个值进行分组</strong>；效果等同于SQL中的groupby </p>
</blockquote>
<ul>
<li><strong>df.groupby(‘ col’ )</strong>：返回一个按列col进行分组的Groupby对象</li>
<li><strong>df.groupby( [‘col1’,’col2’] )</strong>：<strong><u>多条件分组</u></strong>； （ 等价于SQL中<code>Group by key1, key2</code> ）</li>
<li><strong>df.groupby().size()</strong>：返回一个包含<strong>分组大小</strong>的Series</li>
</ul>
<blockquote>
<p>as_index = False ：以 <strong>“无索引”</strong> 的形式返回聚合数据</p>
<p>group_keys = False ：禁止分组键。分组键会跟原始对象的索引共同构成结果对象中的层次化索引。该函数可禁止该效果。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># grouped 是一个GroupBy对象。它实际上还没有进行任何计算，只是包含了一些有关分子间df['key1']的中间数据而已</span></div><div class="line">grouped = df[<span class="string">'data1'</span>].groupby(df[<span class="string">'key1'</span>])</div><div class="line">grouped</div><div class="line">&lt;pandas.core.groupby.SeriesGroupBy object at <span class="number">0x000000000876EBA8</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 调用GroupBy的方法进行聚合计算</span></div><div class="line">grouped.mean()</div><div class="line">       key1</div><div class="line">a    <span class="number">0.486419</span></div><div class="line">b   <span class="number">-0.771562</span></div><div class="line">Name: data1, dtype: float64</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># 对所有的数值数据进行统计计算，而对非数据数据列则会排除。 'key2'列自动被排除在外</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).mean()</div><div class="line">      data1	data2</div><div class="line">key1		</div><div class="line">a	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-0.771562</span>	<span class="number">-0.562044</span>    </div><div class="line">    </div><div class="line">  </div><div class="line"><span class="comment"># -----------df.groupby(['col1', 'col2'])-----------------</span></div><div class="line"><span class="comment"># 一次传入多个数组，表示多条件分组 </span></div><div class="line">df.loc[:,<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>],df[<span class="string">'key2'</span>]]).mean()  <span class="comment"># 等价于SQL中 Group by key1, key2</span></div><div class="line">           key1  key2</div><div class="line">a     one     <span class="number">0.882282</span></div><div class="line">      two    <span class="number">-0.305308</span></div><div class="line">b     one    <span class="number">-1.010323</span></div><div class="line">      two    <span class="number">-0.532800</span></div><div class="line">Name: data1, dtype: float64</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># ---------------Size--------------------</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).size()</div><div class="line">    key1</div><div class="line">a    <span class="number">3</span></div><div class="line">b    <span class="number">2</span></div><div class="line">dtype: int64</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="层次化索引的重塑-stack-1"><a href="#层次化索引的重塑-stack-1" class="headerlink" title="层次化索引的重塑 - stack"></a>层次化索引的重塑 - stack</h4><blockquote>
<p>可构建类似数据透视表的结构</p>
</blockquote>
<ul>
<li><strong>stack()</strong>：列转行；将数据的列 “旋转” 为行</li>
<li><strong>unstack()</strong>：<strong><u>列转行</u></strong>；将数据的行 “旋转” 为列</li>
</ul>
<blockquote>
<p>stack操作的是对<strong>最内层的索引</strong>进行操作。</p>
<blockquote>
<p>若用字符串表示，则直接输入该索引的名称 .stack(‘number’)</p>
<p>若用数字表示，0 - 第一层索引； 1 - 第二层索引</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">df.loc[:,<span class="string">'data1'</span>].groupby([df[<span class="string">'key1'</span>],df[<span class="string">'key2'</span>]]).mean().unstack()</div><div class="line"></div><div class="line">key2	one	two</div><div class="line">key1		</div><div class="line">a	<span class="number">0.882282</span>	<span class="number">-0.305308</span></div><div class="line">b	<span class="number">-1.010323</span>	<span class="number">-0.532800</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="选取部分列-分组"><a href="#选取部分列-分组" class="headerlink" title="选取部分列 分组"></a>选取部分列 分组</h4><ul>
<li><strong>df[‘data1’].groupby(df[‘key1’])</strong>：返回的一个已分组的数据框对象（语法糖：<strong>df.groupby(‘key1’)[‘data1’]</strong> ）</li>
<li><strong>df[[‘data1’]].groupby(df[‘key1’])</strong> ： 语法糖为<strong>df.groupby(‘key1’)[[‘data1’]]</strong> </li>
</ul>
<p><br></p>
<h4 id="通过函数-分组"><a href="#通过函数-分组" class="headerlink" title="通过函数 - 分组"></a>通过函数 - 分组</h4><ul>
<li><p>任何被当做分组键的函数都会在<strong>各个索引值 （行的索引值，而非列名）</strong>上被调用一次，其返回值就会被用作分组名称。</p>
<ul>
<li>若索引为人的名字；假设你希望<strong>根据人名的长度进行分组</strong>，虽然可以求取一个字符串长度数组，但其实仅需 传入len函数即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">people.groupby(len).sum()</div></pre></td></tr></table></figure>
<p><br></p>
</li>
</ul>
<p>####通过索引级别 - 分组</p>
<blockquote>
<p>针对层次化索引数据集，可以根据索引级别进行分组；通过level 关键字传入 级别编码 或者 名称 即可。</p>
</blockquote>
<ul>
<li><strong>df.groupby(level=’cty’, axis=1)</strong>.mean()  对层次化索引的数据，根据索引级别进行聚合.通过level关键字传入<strong>级别编号或名称</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hier_df.groupby(level=<span class="string">'cty'</span>, axis=<span class="number">1</span>).count()</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h4 id="对分组进行迭代"><a href="#对分组进行迭代" class="headerlink" title="对分组进行迭代"></a>对分组进行迭代</h4><h4 id="通过字典或Series-分组"><a href="#通过字典或Series-分组" class="headerlink" title="通过字典或Series 分组"></a>通过字典或Series 分组</h4><blockquote>
<p>传入一个 字典或Series 根据其值的内容分别分组</p>
</blockquote>
<p><br></p>
<h3 id="数据聚合"><a href="#数据聚合" class="headerlink" title="数据聚合"></a>数据聚合</h3><blockquote>
<p>聚合：从数组产生标量值的数据转换过程</p>
<p>GroupBy会高效地对Series进行切片，然后对各片调用Piece，最后将这些结果组装为最终结果</p>
</blockquote>
<p><br></p>
<h4 id="自定义聚合函数"><a href="#自定义聚合函数" class="headerlink" title="自定义聚合函数"></a>自定义聚合函数</h4><blockquote>
<p>将自定义的函数<strong>传入aggregate 或 agg方法</strong>即可</p>
<p><strong>aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(col1).agg(np.mean)</strong>：返回按列col1分组的<strong>所有列的均值</strong>df </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">peak_to_peak</span><span class="params">(arr)</span>:</span></div><div class="line">    <span class="keyword">return</span> arr.max() - arr.min()</div><div class="line"></div><div class="line">df.groupby(<span class="string">'key1'</span>).agg(peak_to_peak)</div></pre></td></tr></table></figure>
<blockquote>
<p>优化过的GroupBy 方法</p>
<p>.count() ： 非NA值的数量<br>.sum() ： 非NA值的和<br>.mean()<br>.mdian()： 非NA值的算术中位数<br>.std / .var： 无偏（分母为n-1）标准差和方差<br>.min / .max<br>.prod()： 非NA值的积<br>.first / .last ：第一个和最后一个非NA的值</p>
</blockquote>
<p><br></p>
<h4 id="面向列的多函数应用"><a href="#面向列的多函数应用" class="headerlink" title="面向列的多函数应用"></a>面向列的多函数应用</h4><blockquote>
<p><strong>一次应用多个函数</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby( [‘sum’, ‘mean’]) ：一次应用多个函数</strong>：对于描述统计，可以将函数名以 <strong>字符串str</strong> 的形式传入，并作为一个 <strong>列表list</strong> 传入，得到一个<strong>以相应的函数命名的列</strong></li>
<li><strong>df.groupby( [ (‘foo’, ‘mean’), (‘bar’, ‘sum’) ]) ：传入多个函数，并重命名列名</strong>。<ul>
<li>当传入的是一个由 <strong>(name, function)元组组成的列表list</strong> ，则各元组的第一个元素会被用作DataFrame的列名（可以将这种二元元组看做一个有序映射） </li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).agg([<span class="string">'sum'</span>,<span class="string">'mean'</span>])</div><div class="line">	       data1	data2</div><div class="line">       sum	mean	sum	mean</div><div class="line">key1				</div><div class="line">a	<span class="number">1.459256</span>	<span class="number">0.486419</span>	<span class="number">-1.138960</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-1.543123</span>	<span class="number">-0.771562</span>	<span class="number">-1.124087</span>	<span class="number">-0.562044</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ---- 先定义要传入的多个函数为对象A；也可以运行</span></div><div class="line">fc = [<span class="string">'count'</span>, <span class="string">'mean'</span>, <span class="string">'max'</span>]    </div><div class="line">df.groupby(<span class="string">'key1'</span>).agg(fc)</div><div class="line"></div><div class="line">			data1		data2</div><div class="line">	count	mean	max	count	mean	max</div><div class="line">key1						</div><div class="line">a	<span class="number">3</span>	<span class="number">0.486419</span>	<span class="number">1.041325</span>	<span class="number">3</span>	<span class="number">-0.379653</span>	<span class="number">0.010709</span></div><div class="line">b	<span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.532800</span>	<span class="number">2</span>	<span class="number">-0.562044</span>	<span class="number">0.038084</span></div><div class="line"></div><div class="line"><span class="comment"># 传入带有自定义名称的元组列表</span></div><div class="line">fc_name = [(<span class="string">'计数'</span>,<span class="string">'count'</span>),(<span class="string">'最大值'</span>,<span class="string">'max'</span>)]</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>对不同的列使用不同的聚合函数</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(‘key1’).agg( { ‘tip’: np.max, ‘size’: ‘sum’} )</strong> ：向 agg 传入一个<strong><u>列名映射到函数的 字典dict</u></strong><ul>
<li><strong>df.groupby(‘key1’).agg( { ‘tip_pct’ : [‘min’, ‘,max’], ‘size’: ‘sum’})</strong> ：对不同列完成不同数量的聚合</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="分组运算transform-amp-apply"><a href="#分组运算transform-amp-apply" class="headerlink" title="分组运算transform &amp; apply"></a>分组运算transform &amp; apply</h3><blockquote>
<p>transform &amp; apply 只能产生两种结果：</p>
<ol>
<li>一个可以广播出去的标量值</li>
<li>一个相同大小的结果数组</li>
</ol>
<p><strong>aggregation会返回数据的缩减版本，而transformation能返回完整数据的某一变换版本供我们重组。</strong></p>
</blockquote>
<ul>
<li><strong>df.groupby(‘val’).transform( func )</strong>：将一个函数应用到各个分组，<strong>返回该结果的值</strong>； 若产生的是一个标量值，则该值会被<strong>广播</strong>出去。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>)</div><div class="line">	data1	data2</div><div class="line"><span class="number">0</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">1</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"><span class="number">2</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">3</span>	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"><span class="number">4</span>	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 对比 df.groupby('key1').mean()</span></div><div class="line">	   data1	data2</div><div class="line">key1		</div><div class="line">a	<span class="number">0.486419</span>	<span class="number">-0.379653</span></div><div class="line">b	<span class="number">-0.771562</span>	<span class="number">-0.562044</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 分组运算并合并数据</span></div><div class="line">df.groupby(<span class="string">'key1'</span>).transform(<span class="string">'mean'</span>).add_prefix(<span class="string">'mean_'</span>)  <span class="comment"># DataFrame.add_prefix(prefix) 将前缀字符串与面板项名称串联在一起。</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<blockquote>
<p>apply 是更一般性的 “拆分-应用-合并”；</p>
<p><strong>传入的函数一般都是需要提前定义的；而无法直接调用已有的函数（sum/mean等）</strong></p>
</blockquote>
<ul>
<li><strong>GroupBy.apply(func)</strong>：<ul>
<li><strong>data.apply(np.mean)</strong>：对DataFrame中的每一 <strong>[列]</strong> 应用函数np.mean</li>
</ul>
</li>
</ul>
<blockquote>
<p>axis = 0 默认：以行为单位，遍历列的所以行；可以理解为  SQL中指定某列的Group by </p>
<p>axis = 1 ：以列为单位，遍历行的所有列。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 定义函数：根据分组选出最高的5个tip_pct值</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(df, n=<span class="number">5</span>, column = <span class="string">'tip_pct'</span>)</span>:</span></div><div class="line">    <span class="keyword">return</span> df.sort_index(by=column)[-n:]</div><div class="line">  </div><div class="line"><span class="comment"># 将该函数应用</span></div><div class="line">tips.groupby(<span class="string">'smoker'</span>).apply(top)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -----------------------------------------------</span></div><div class="line"><span class="comment"># 如果传入的函数能够接受其他参数或关键字，可以将这些内容直接放在函数名后面一并传入apply</span></div><div class="line">tips.groupby([<span class="string">'smoker'</span>, <span class="string">'day'</span>]).apply(top, n=<span class="number">1</span>, column = <span class="string">'totoal_bill'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="样式输出-style"><a href="#样式输出-style" class="headerlink" title="样式输出 - style"></a>样式输出 - style</h2><blockquote>
<p><strong>【提醒】</strong></p>
<ul>
<li>采用格式化函数之后，整个对象类型则变更为 <code>styler</code> ，此时不应该赋值给原对象。因为赋值后，无法应用任何 <code>DataFrame</code>的函数；</li>
<li>格式输出并不改变原对象的值</li>
</ul>
<ul>
<li><strong>在最后阶段应用格式化输出的函数</strong></li>
</ul>
</blockquote>
<h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><ul>
<li>Styler<strong>.format</strong>(formatter, subset=None)：格式化单元格的文本显示值<ul>
<li>pandas.io.formats.style.Styler.format</li>
<li><strong>对象必须是 DataFrame；对于Series无效；即若只取 DataFrame的一列，则会报错</strong>；</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>formatter: str, callable, or dict</strong></p>
<blockquote>
<p><strong>&lt; formatter是 a  或 dict {column name： a}  &gt;； a 是如下之一</strong></p>
<ul>
<li>str: this will be wrapped in: <code>a.format(x)</code>   ； 这将包装在：<code>a.format(x)</code></li>
<li>callable:  called with the value of an individual cell 使用单个单元格的值调用</li>
</ul>
</blockquote>
<p><strong>subset: IndexSlice</strong></p>
<blockquote>
<p>An argument to <code>DataFrame.loc</code> that restricts which elements <code>formatter</code> is applied to</p>
</blockquote>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>df = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">2</span>), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 对所有对象调用格式化函数</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.style.format(<span class="string">'&#123;:.2%&#125;'</span>)  <span class="comment"># 注意&#123;&#125;是用引号 括起来的</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df[<span class="string">'c'</span>] = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</div><div class="line"></div><div class="line"><span class="comment"># 通过字典的方式来指定特定列的输出格式   </span></div><div class="line"><span class="comment">## 对于数值类型，直接调用format函数； 对于文本，直接调用str.func</span></div><div class="line">df.style.format(&#123;<span class="string">'a'</span>:format(<span class="string">'&#123;:.2%&#125;'</span>),<span class="string">'b'</span>:format(<span class="string">'&#123;:.2%&#125;'</span>),<span class="string">'c'</span>:str.upper&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>对于数值类型，直接调用format函数； 对于文本，直接调用str.func</strong></p>
</blockquote>
<p>格式化单元格的文本显示值。</p>
<p><br></p>
<h2 id="参考说明"><a href="#参考说明" class="headerlink" title="参考说明"></a>参考说明</h2><h3 id="axis的含义"><a href="#axis的含义" class="headerlink" title="axis的含义"></a>axis的含义</h3><p><strong>【结论】</strong></p>
<ol>
<li><strong>常规情况下，axis=1 代表列； axis=0 代表行；</strong></li>
<li><strong>计算情况下，axis=1 代表沿着每一行遍历所有的列，并向下执行对一个的方法</strong></li>
</ol>
<blockquote>
<p>如果我们调用df.mean(axis=1),我们将得到按行计算的均值</p>
<p>如果我们调用 df.drop((name, axis=1),我们实际上删掉了一列，而不是一行</p>
</blockquote>
<p>df.mean其实是在每一行上取所有列的均值，而不是保留每一列的均值。也许简单的来记就是axis=0代表往<strong>跨行（down)</strong>，而axis=1代表<strong>跨列（across)</strong>，作为方法动作的副词（译者注）</p>
<p>换句话说：</p>
<ul>
<li>使用0值 表示沿着每一列或行标签\索引值向下执行方法</li>
<li>使用1值 表示沿着每一行或者列标签模向执行对应的方法</li>
</ul>
<p>下图代表在DataFrame当中axis为0和1时分别代表的含义:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2233157-b77105789e36c847.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>axis参数作用方向图示</p>
<p>另外，记住，Pandas保持了Numpy对关键字axis的用法，用法在Numpy库的词汇表当中有过解释：</p>
<p><strong>轴用来为超过一维的数组定义的属性，二维数据拥有两个轴：第0轴沿着行的垂直往下，第1轴沿着列的方向水平延伸。</strong></p>
<p>所以问题当中第一个列子 df.mean(axis=1)代表沿着列水平方向计算均值，而第二个列子df.drop(name, axis=1) 代表将name对应的列标签（们）沿着水平的方向依次删掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;df = pd.DataFrame([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]], \</div><div class="line">columns=[<span class="string">"col1"</span>, <span class="string">"col2"</span>, <span class="string">"col3"</span>, <span class="string">"col4"</span>])</div><div class="line">&gt;&gt;&gt;df</div><div class="line">   col1  col2  col3  col4</div><div class="line">    <span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></div><div class="line">    <span class="number">1</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span></div><div class="line">    <span class="number">2</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.mean(axis=<span class="number">1</span>)</div><div class="line"><span class="number">0</span>    <span class="number">1</span></div><div class="line"><span class="number">1</span>    <span class="number">2</span></div><div class="line"><span class="number">2</span>    <span class="number">3</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df.drop(<span class="string">"col4"</span>, axis=<span class="number">1</span>)</div><div class="line">   col1  col2  col3</div><div class="line"><span class="number">0</span>     <span class="number">1</span>     <span class="number">1</span>     <span class="number">1</span></div><div class="line"><span class="number">1</span>     <span class="number">2</span>     <span class="number">2</span>     <span class="number">2</span></div><div class="line"><span class="number">2</span>     <span class="number">3</span>     <span class="number">3</span>     <span class="number">3</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="两行相减-amp-环比"><a href="#两行相减-amp-环比" class="headerlink" title="两行相减 &amp; 环比"></a>两行相减 &amp; 环比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;pandas 指引 : &lt;a href=&quot;http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window&quot;&gt;http://pandas.pydata.org/pandas-docs/stable/api.html#function-application-groupby-window&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DataFrame 单独取出一列是 Series 格式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;根据pandas的官方文档，重新调整结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>阅读书籍</title>
    <link href="http://yoursite.com/2018/02/05/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2018/02/05/阅读书籍/阅读书籍汇总/阅读书籍汇总/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-13T13:52:53.694Z</updated>
    
    <content type="html"><![CDATA[<p><strong>记录阅读的所有书籍。</strong></p>
<a id="more"></a>
<p>[TOC]</p>
<blockquote>
<h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>《书名》_作者 / 购买时间 / 阅读时间 - 网址链接</p>
<blockquote>
<p>《原名》 - 原作者</p>
</blockquote>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</blockquote>
<p><br></p>
<h2 id="互联网运营"><a href="#互联网运营" class="headerlink" title="互联网运营"></a>互联网运营</h2><p><br></p>
<ol>
<li><p><strong>《运营之光：我的互联网运营方法论与自白 2.0》_黄有璨 / 2017-12-19 / 2018-02-06</strong> </p>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</li>
<li><p>​</p>
</li>
</ol>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;记录阅读的所有书籍。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>阅读书籍_2018年度</title>
    <link href="http://yoursite.com/2018/02/05/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%B1%87%E6%80%BB_2018%E5%B9%B4%E5%BA%A6/"/>
    <id>http://yoursite.com/2018/02/05/阅读书籍/阅读书籍汇总/阅读书籍汇总_2018年度/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-13T13:53:06.534Z</updated>
    
    <content type="html"><![CDATA[<p>记录2018年度阅读的书籍。</p>
<a id="more"></a>
<p>[TOC]</p>
<p><br></p>
<blockquote>
<h4 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h4><p>《书名》_作者 / 购买时间 / 阅读时间 - 网址链接</p>
<blockquote>
<p>《原名》 - 原作者</p>
</blockquote>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</blockquote>
<p><br></p>
<h2 id="互联网运营"><a href="#互联网运营" class="headerlink" title="互联网运营"></a>互联网运营</h2><p><br></p>
<ol>
<li><p><strong>《运营之光：我的互联网运营方法论与自白 2.0》_黄有璨 / 2017-12-19 / 2018-02-06</strong> </p>
<p>一句话概括整本书的核心内容，最多不超过三句话。这个是原则。</p>
</li>
<li><p>​</p>
</li>
</ol>
<p><br></p>
<blockquote>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录2018年度阅读的书籍。&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="汇总整理" scheme="http://yoursite.com/tags/%E6%B1%87%E6%80%BB%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Python_日期处理</title>
    <link href="http://yoursite.com/2018/02/05/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%97%A5%E6%9C%9F%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/02/05/软件应用_程序编程/Python/Python_专题总结/Python_日期处理/</id>
    <published>2018-02-04T16:00:00.000Z</published>
    <updated>2018-02-13T13:43:36.096Z</updated>
    
    <content type="html"><![CDATA[<h1 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h1><blockquote>
<p><strong><code>datetime</code>表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。</strong></p>
<p><strong>如果要存储<code>datetime</code>，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。</strong></p>
</blockquote>
<a id="more"></a>
<p>Python中关于时间、日期的处理库有三个：time、datetime和Calendar。</p>
<ul>
<li>datetime又有datetime.date、datetime.time、datetime.datetime三个类</li>
<li>时间又可以分为时间戳、本地时间和UTC时间（世界标准时间）</li>
</ul>
<p><code>from time import time</code></p>
<p><code>from datetime import datetime</code></p>
<p><br></p>
<p>时间序列的几种内容</p>
<ul>
<li>时间戳 (timestamp)，特定的时刻</li>
<li>固定时期 (period)，如2017年1月或2017年全年</li>
<li>时间间隔 (internal) ，由起始时间和结束时间戳表示。时期 (period) 可以看做间隔的一个特例</li>
</ul>
<p><br></p>
<h2 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h2><blockquote>
<p>datetime是Python处理日期和时间的标准库。</p>
<p><code>from datetime import datetime</code></p>
</blockquote>
<p>datetime模块。该模块中包含4个主要的类：</p>
<ul>
<li>datetime.date：日期类，只包含年、月、日、星期等日期信息。</li>
<li>datetime.time：时间类，只包含时、分、秒、微秒等时间信息。</li>
<li>datetime.datetime：日期时间类，包含以上两者的全部信息。</li>
<li>datetime.timedelta：时间日期差值类，用来表示两个datetime之间的差值（日、秒、毫秒）。</li>
</ul>
<blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; # 获取当前时间</div><div class="line">&gt; &gt;&gt;&gt; from datetime import datetime</div><div class="line">&gt; &gt;&gt;&gt; now = datetime.now() # 获取当前datetime</div><div class="line">&gt; &gt;&gt;&gt; print(now)</div><div class="line">&gt; 2015-05-18 16:28:07.198690</div><div class="line">&gt; &gt;&gt;&gt; print(type(now))</div><div class="line">&gt; &lt;class 'datetime.datetime'&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>注意到<code>datetime</code>是模块，<code>datetime</code>模块还包含一个<code>datetime</code>类，通过<code>from datetime import datetime</code>导入的才是<code>datetime</code>这个类。</p>
<p>如果仅导入<code>import datetime</code>，则必须引用全名<code>datetime.datetime</code>。</p>
<p><code>datetime.now()</code>返回当前日期和时间，其类型是<code>datetime</code>。</p>
</blockquote>
<p><br></p>
<h3 id="时间获取"><a href="#时间获取" class="headerlink" title="时间获取"></a>时间获取</h3><ul>
<li><strong>datetime.datetime.now()</strong>：获取当前日期与时间</li>
<li><strong>datetime.datetime(2012, 1, 12)</strong>：获取<strong>指定</strong>日期与时间</li>
</ul>
<p><br></p>
<p>####指定部分</p>
<ul>
<li><p><strong>datetime.year</strong> : 获取日期与时间的<strong>指定部分</strong></p>
<ul>
<li><p><code>datetime.year</code></p>
</li>
<li><p><code>datetime.month</code></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>datetime.day</code></li>
</ul>
<ul>
<li><code>datetime.hour</code></li>
</ul>
<ul>
<li><code>datetime.minute</code></li>
</ul>
<ul>
<li><code>datetime.second</code></li>
</ul>
<ul>
<li><code>datetime.microsecond</code>   In range(1000000) </li>
</ul>
<ul>
<li><p>datetime.date()：获得日期部分</p>
<ul>
<li>datetime.time()</li>
<li><strong>datetime.weekday()</strong>：将星期几作为整数返回，<strong>其中星期一为0，星期日为6</strong></li>
<li><strong>datetime.isoweek()</strong>：将星期几作为整数返回，<strong>星期一为1，星期日为7</strong></li>
</ul>
</li>
</ul>
<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><ul>
<li><strong>datetime.strftime( format )</strong> ：时间<strong>转为字符串</strong>    <em>f：表示from</em><ul>
<li>strftime() 用来<strong>格式化</strong>  datetime对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>format : ‘%Y-%M-%D %H:%M:%S’</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># datetime.datetime类型转字符串</span></div><div class="line">print(a_datetime_local.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>))  </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 字符串转datetime.datetime格式</span></div><div class="line">a_datetime = datetime.datetime.strptime(<span class="string">"2016-11-15, 15:32:12, 2"</span>, <span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>)</div></pre></td></tr></table></figure>
<ul>
<li><strong>datetime.strptime( ‘date_string’, ‘%Y-%M-%D’)</strong>：字符串<strong>转为时间格式</strong><ul>
<li>datetime.strptime 是通过已知的格式进行日期解析的方式。但每次都必须要编写格式定义。</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>parser.parse(‘str’ ,dayfirst =True)</strong>：可以解析几乎所有人类能够理解的日期表示形式（中文除外）<ul>
<li>对于常见的日期格式，可以使用<code>dateutil</code> 第三方包中的 <code>parser.parse</code> 方法</li>
<li>注意：它并不是一个完美的工具；因为会把一些原本不是日期的字符串认作是日期（比如 “42”会被解析为2042年的今天）</li>
</ul>
</li>
</ul>
<blockquote>
<p>dayfirst =True ，将日期显示在最前面；因为国际通用格式中，日通常排在月的前面。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</div><div class="line">parse(<span class="string">'2011-03-11'</span>)</div><div class="line"></div><div class="line">[out]:datetime.datetime(<span class="number">2011</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="timedelta对象-加减"><a href="#timedelta对象-加减" class="headerlink" title="timedelta对象 + 加减"></a>timedelta对象 + 加减</h3><p>datetime.timedelta <strong>表示两个datetime之间的时间差。</strong></p>
<p>给datetime对象加上一个或多个 timedelta，会产生一个新的对象；</p>
<ul>
<li><p><strong>now + timedelta(days=n, hours=m)</strong>：在原有基础上加减日期</p>
<ul>
<li>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</li>
</ul>
</li>
</ul>
<blockquote>
<p>years<br>months<br>days<br>hours<br>minutes<br>seconds </p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 日期加减</span></div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</div><div class="line">start = datetime(<span class="number">2011</span>,<span class="number">1</span>,<span class="number">7</span>)</div><div class="line"></div><div class="line">start + timedelta(<span class="number">12</span>)</div><div class="line">[out]:datetime.datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">19</span>, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">  </div><div class="line">  </div><div class="line"><span class="comment"># 返回间隔</span></div><div class="line">delta = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>) - datetime(<span class="number">2008</span>, <span class="number">6</span>, <span class="number">24</span>)</div><div class="line">delta</div><div class="line">[out]:datetime.timedelta(<span class="number">927</span>)</div><div class="line"></div><div class="line">delta.days</div><div class="line">[out]:<span class="number">927</span></div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><p>在time模块中，时间有三种表现形式：</p>
<ul>
<li>时间戳，一般指Unix时间戳，是从1970年开始到现在的秒数。<ul>
<li>1970年以前的时间timestamp为负数</li>
</ul>
</li>
<li>本地时间的struct_time形式：一个长度为11的命名元组，第一位为年，第二位为月….</li>
<li>UTC时间的struct_time形式：一个长度为11的命名元组，类似于上个，只不过为UTC时间</li>
</ul>
<blockquote>
<p>其中后两者的类型一致，区别在于一个是本地时间（localtime），一个是utc时间。</p>
</blockquote>
<p><br></p>
<h3 id="时间获取-1"><a href="#时间获取-1" class="headerlink" title="时间获取"></a>时间获取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 时间戳：1479193181.829338</span></div><div class="line">print(<span class="string">"time stamp:"</span>, time.time())         </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间</span></div><div class="line">print(<span class="string">"local time:"</span>, time.localtime())    </div><div class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">14</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">41</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">320</span>, tm_isdst=<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的utc时间</span></div><div class="line">print(<span class="string">"utc time:"</span>, time.gmtime())         </div><div class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">15</span>, tm_hour=<span class="number">6</span>, tm_min=<span class="number">59</span>, tm_sec=<span class="number">41</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">320</span>, tm_isdst=<span class="number">0</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="字符串转换-1"><a href="#字符串转换-1" class="headerlink" title="字符串转换"></a>字符串转换</h3><ul>
<li><strong>time.strptime()：</strong>字符串<strong>转为时间格式</strong></li>
<li><strong>time.strftime()</strong>：时间格式<strong>转为字符串</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 时间戳转字符串(本地时间字符串)</span></div><div class="line">print(time.ctime(time_stamp))       </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间转字符串</span></div><div class="line">print(time.asctime(local_time))   </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的utc时间转字符串</span></div><div class="line">print(time.asctime(utc_time))       </div><div class="line"></div><div class="line"><span class="comment"># struct_time类型的本地时间转字符串：自定义格式</span></div><div class="line">print(time.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>, local_time))</div><div class="line"><span class="comment"># struct_time类型的utc时间转字符串：自定义格式</span></div><div class="line">print(time.strftime(<span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>, utc_time))</div><div class="line"></div><div class="line">struct_time = time.strptime(<span class="string">"2016-11-15, 15:32:12, 2"</span>, <span class="string">"%Y-%m-%d, %H:%M:%S, %w"</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><img src="https://pic3.zhimg.com/80/v2-69d0c2ed958b802e9902c8e3815c19e9_hd.jpg" alt="img"></p>
<p><br></p>
<p><br></p>
<h2 id="datetime-与-timestamp转换"><a href="#datetime-与-timestamp转换" class="headerlink" title="datetime 与 timestamp转换"></a>datetime 与 timestamp转换</h2><p>在计算机中，时间实际上是用数字表示的。我们把1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为<code>0</code>（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 可以认为</span></div><div class="line">timestamp = <span class="number">0</span> = <span class="number">1970</span><span class="number">-1</span><span class="number">-1</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> UTC+<span class="number">0</span>:<span class="number">00</span></div><div class="line"></div><div class="line"><span class="comment"># 对应的北京时间是：</span></div><div class="line">timestamp = <span class="number">0</span> = <span class="number">1970</span><span class="number">-1</span><span class="number">-1</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> UTC+<span class="number">8</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，因为全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。</p>
</blockquote>
<p><br></p>
<h3 id="datetime-转-timestamp"><a href="#datetime-转-timestamp" class="headerlink" title="datetime 转 timestamp"></a>datetime 转 timestamp</h3><ul>
<li><strong>dt.timestamp()</strong>：把datetime对象转化为timestamp</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></div><div class="line"><span class="number">1429417200.0</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="timestamp-转-datetime"><a href="#timestamp-转-datetime" class="headerlink" title="timestamp 转 datetime"></a>timestamp 转 datetime</h3><ul>
<li><strong>datetime.fromtimestamp(t)</strong>：从timestamp 转为datetime<strong>（本地时间）</strong><ul>
<li>注意到timestamp是一个浮点数，<strong>它没有时区的概念</strong>，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。</li>
</ul>
</li>
<li><strong>datetime. utcfromstimestamp(t)</strong>：从timestamp 转为datetime<strong>（UTC时间）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t)) <span class="comment"># 本地时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></div><div class="line">    </div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间</span></div><div class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<p>类型和时间戳、struct_time类型的相互转换</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="comment"># datetime类型转时间戳</span></div><div class="line">time_stamp = a_datetime_local.timestamp()   </div><div class="line">print(time_stamp)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 时间戳转datetime.datetime类型的本地时间</span></div><div class="line">a_datetime_local = datetime.datetime.fromtimestamp(time.time())     </div><div class="line">a_datetime_utc = datetime.datetime.utcfromtimestamp(time.time())    <span class="comment"># 时间戳转datetime.datetime类型的utc时间</span></div><div class="line">print(a_datetime_local, a_datetime_utc)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># datetime类型转struct_time类型</span></div><div class="line">print(a_datetime_local.timetuple())    </div><div class="line">print(a_datetime_utc.utctimetuple())    <span class="comment"># datetime类型转struct_time类型</span></div></pre></td></tr></table></figure>
<p><br></p>
<p><img src="https://pic1.zhimg.com/80/v2-e623f9c109960af3805ec3eadfeaaa11_hd.jpg" alt="img"></p>
<p><br></p>
<h2 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h2><h3 id="本地时间转UTC时间"><a href="#本地时间转UTC时间" class="headerlink" title="本地时间转UTC时间"></a>本地时间转UTC时间</h3><blockquote>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
</blockquote>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tz_utc_8 = timezone(timedelta(hours=<span class="number">8</span>)) <span class="comment"># 创建时区UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>now</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.replace(tzinfo=tz_utc_8) <span class="comment"># 强制设置为UTC+8:00</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dt</div><div class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>, tzinfo=datetime.timezone(datetime.timedelta(<span class="number">0</span>, <span class="number">28800</span>)))</div></pre></td></tr></table></figure>
<p><br></p>
<p>###时区转换</p>
<ul>
<li><strong>utcnow()</strong>：获取当前的UTC时间</li>
<li>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。</li>
<li>利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(bj_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">08</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div><div class="line">      </div><div class="line"><span class="comment"># astimezone()将bj_dt转换时区为东京时间:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt2)</div><div class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p>
</blockquote>
<p><br></p>
<h2 id="格式定义"><a href="#格式定义" class="headerlink" title="格式定义"></a>格式定义</h2><h3 id="datetime格式定义"><a href="#datetime格式定义" class="headerlink" title="datetime格式定义"></a>datetime格式定义</h3><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%Y</td>
<td>4位数的年</td>
</tr>
<tr>
<td>%y</td>
<td>2位数的年</td>
</tr>
<tr>
<td>%m</td>
<td>2位数的月 [01, 12]</td>
</tr>
<tr>
<td>%d</td>
<td>2位数的日 [01, 31]</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%F</td>
<td>%Y-%m-%d 简写形式；2012-04-18</td>
</tr>
<tr>
<td>%D</td>
<td>%m/%d/%y 简写形式；04/18/12</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%H</td>
<td>时间（24小时制） [00, 23]</td>
</tr>
<tr>
<td>%I</td>
<td>时间（12小时制） [00, 12]</td>
</tr>
<tr>
<td>%M</td>
<td>2位数的分钟 [00, 59]</td>
</tr>
<tr>
<td>%S</td>
<td>秒 [00, 61] (秒60和61用于闰秒)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%w</td>
<td>用整数表示的星期几 （星期天为第0天） [0, 6]</td>
</tr>
<tr>
<td>%U</td>
<td>每年的第几周 [00, 53]。<strong>星期天被认为是每周的第一天</strong>，每年第一个星期天之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td>%W</td>
<td>每年的第几周 [00, 53]。<strong>星期一被认为是每周的第一天</strong>，每年第一个星期一之前的那几天被认为是 “第0周”</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>%z</td>
<td>以+HHMM 或-HHMM 表示的UTC时区偏移量</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<h3 id="特定于当前环境的日期格式"><a href="#特定于当前环境的日期格式" class="headerlink" title="特定于当前环境的日期格式"></a>特定于当前环境的日期格式</h3><table>
<thead>
<tr>
<th>代码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%a</td>
<td>星期几的简写</td>
</tr>
<tr>
<td>%A</td>
<td>星期几的全称</td>
</tr>
<tr>
<td>%b</td>
<td>月份的简写</td>
</tr>
<tr>
<td>%B</td>
<td>月份的全称</td>
</tr>
<tr>
<td>%c</td>
<td>完成的日期和时间；Tue 01 May 2012 04:20:57 pm</td>
</tr>
<tr>
<td>%p</td>
<td>不同环境中的AM 或PM</td>
</tr>
<tr>
<td>%x</td>
<td>适用于当前环境的日期格式  ；若在美国， “May 1 2012” 会产生 “05/01/2012”</td>
</tr>
<tr>
<td>%X</td>
<td>适用于当前环境的时间格式； “04:24:12 PM”</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><h4 id="输出为-月-日格式"><a href="#输出为-月-日格式" class="headerlink" title="输出为 月-日格式"></a>输出为 月-日格式</h4><p><br></p>
<h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><p>pandas最基本的时间序列类型就是<strong>以时间戳为索引</strong>的Series；</p>
<p>当创建一个<strong>带有DatatimeIndex</strong> 的Series时，pandas就会知道该对象是一个<strong>时间序列</strong></p>
<blockquote>
<p>索引是 时间格式的字段；</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;日期与时间&quot;&gt;&lt;a href=&quot;#日期与时间&quot; class=&quot;headerlink&quot; title=&quot;日期与时间&quot;&gt;&lt;/a&gt;日期与时间&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;datetime&lt;/code&gt;表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果要存储&lt;code&gt;datetime&lt;/code&gt;，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数据分析_组织架构</title>
    <link href="http://yoursite.com/2018/02/04/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E9%83%A8%E9%97%A8_%E7%BB%84%E7%BB%87%E6%9E%B6%E6%9E%84_20180204/"/>
    <id>http://yoursite.com/2018/02/04/数据分析/数据部门_组织架构_20180204/</id>
    <published>2018-02-03T16:00:00.000Z</published>
    <updated>2018-02-12T12:49:27.928Z</updated>
    
    <content type="html"><![CDATA[<p>S：对数据工作做了总结之后（分为两大模块：数据平台、数据使用），想了解当前社会对数据分析工作的定位是如何的；引发通过了解 数据分析部门所处的组织架构去认识</p>
<p>W：通过对组织架构的研究，去定义/剖析不同组织架构下数据分析部门当前所处的阶段与机制；</p>
<p>B：达到状态：能够去辨别一家公司对数据分析工作的定位与重视度</p>
<blockquote>
<p>在一个企业中，可能数据部门在一个公司中组织架构中的位置，决定了部门的定位和一些做的事情，数据部门所处的组织架构对数据价值实现是一个很重要因素。</p>
</blockquote>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="数据部门发展的阶段"><a href="#数据部门发展的阶段" class="headerlink" title="数据部门发展的阶段"></a>数据部门发展的阶段</h2><p>这是一个必须要经历的过程。</p>
<p><img src="http://s3.51cto.com/wyfs02/M00/7A/57/wKioL1aoLliAi5sUAAGtpVWm3FI986.jpg-wh_651x-s_895689990.jpg" alt="img"></p>
<p><br></p>
<h2 id="数据工作的两大模块"><a href="#数据工作的两大模块" class="headerlink" title="数据工作的两大模块"></a>数据工作的两大模块</h2><p>数据部门分成二个部门：</p>
<ol>
<li>后端：数据仓库，大数据平台等；</li>
<li>前端，例如：数据分析，数据挖掘，数据产品等;</li>
</ol>
<p><br></p>
<h2 id="常见的部门架构"><a href="#常见的部门架构" class="headerlink" title="常见的部门架构"></a>常见的部门架构</h2><h3 id="分散式"><a href="#分散式" class="headerlink" title="分散式"></a>分散式</h3><p><strong>数据平台由技术部建设，技术没有数据分析/业务分析人员</strong>；这部分人员都分到各个业务块中。</p>
<p><strong>技术部负责搭建大数据平台</strong>(在传统主要叫数据仓库)。目前大数据平台，如果比较大型的公司基本上会包括几块内容：</p>
<ol>
<li>分布式：hadoop 平台;</li>
<li>实时计算: storm平台</li>
<li>内存计算：spark 平台</li>
<li>传统关系数据库</li>
</ol>
<p><strong>业务分析人员获取数据</strong></p>
<ol>
<li>向数据平台接口人提需求，最终<strong>以报表的形式获取数据。</strong>把业务方的进行转化，转为PRD文档，让ETL开发工程师，报表开发工程师实现 。<u>【业务人员是没有访问数据仓库的权限的】</u></li>
<li>开放所有给业务人员进行去访问，业务可以自己访问部分数据，去写SQL去取数据。</li>
</ol>
<p><strong>适合情况</strong>： 在一些业务变化不快，或者业务相对不那么复杂的公司可能比较好。</p>
<p>对一些业务复杂，业务变化非常快的可能就不适合：</p>
<ul>
<li>数据平台/仓库建议跟不上业务变化。造成数据仓库效率低，数据口径混乱。因为数据仓库架构离业务比较远，对业务理解不深。</li>
<li>业务数据分析师很多人的知识不能很有效沉淀下来。</li>
</ul>
<p>这会<strong>导致业务要求为各个业务建议自己 “数据集市”，当这种数据集市我的时候，又会造成数据仓库负担中，各个业务方的数据“各大自为政”。</strong>最终公司数据混乱，后面大家对数据都摇头。</p>
<p>对于不把数据分析独立存在的公司，数据分析只是个数据展现工具，根本谈不上分析，而形成不了整体的营销能力.</p>
<p><img src="http://s3.51cto.com/wyfs02/M02/7A/57/wKioL1aoLqnwrtsiAAG1g9SgjmQ970.jpg-s_1537300888.jpg" alt="img"></p>
<p><br></p>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p><strong>公司所有的数据相关都归到一个部门中。</strong>业务方有任何需要都会向数据部门提出，数据部门会在内部对这些需求和报表进行沟通，避免重复开发，也便于对需求进行总结。</p>
<p>优势：所有的数据都是一个部门出，相对来说数据的口径会比较统一;</p>
<p>劣势：如果部门组织的不好。会造成数据部门离业务比较远 ;有时候对于数据的思考不够深入，造成与业务部门的沟通成本上升。</p>
<p><img src="http://s4.51cto.com/wyfs02/M02/7A/58/wKiom1aoLq7RFdXFAAGqOo9TwXo720.jpg-s_3999238439.jpg" alt="img"></p>
<p><br></p>
<h3 id="混合式"><a href="#混合式" class="headerlink" title="混合式"></a>混合式</h3><p><strong>大数据平台建设由技术负责，他们核心是把数据平台建设的足够强大。</strong></p>
<ul>
<li>有一个比较大的数据部门，负责数据分析，挖掘，数据统一工作。一般来说这个部门会直接像管理层汇报，主要服务公司管理层;同时也会和业务方的数据分析师合作一起解决某个具体问题。</li>
</ul>
<p><strong>在业务方也会有自己的小数据分析团队。</strong></p>
<ul>
<li>这个数据团队主要服务由自己这个业务团队，同时也会和公司的数据部门有沟通和合作。</li>
</ul>
<p><img src="http://s4.51cto.com/wyfs02/M01/7A/57/wKioL1aoL6rRKA2WAAGwX7e22cA183.jpg-s_519638876.jpg" alt="img"></p>
<p><br></p>
<p><br></p>
<h2 id="传统BI"><a href="#传统BI" class="headerlink" title="传统BI"></a>传统BI</h2><blockquote>
<p><strong>问题：为什么传统BI没有达到今天互联网数据应用的高度呢?</strong></p>
</blockquote>
<p>在传统的BI中，<strong>更多只实现最底层价值。</strong> </p>
<p>$$ &lt; 数据存储技术与成本 \to 数据运算效率 \to 公司数据价值意识 \to 数据相关部门架构 &gt; $$</p>
<ul>
<li>传统的BI，更多是<strong>偏重数据仓库的架构</strong>，根据需求来帮报表。</li>
<li>在数据部门没有一批主动去思考业务，思考业务与数据关系的人。<strong>这种人很可能都是在业务方，他们更多把业务问题转为要看的报表，然后与数据部门沟通报表开发</strong>，数据部门收集需求沟通后，进行排期</li>
</ul>
<p><br></p>
<h2 id="对当前公司架构的思考"><a href="#对当前公司架构的思考" class="headerlink" title="对当前公司架构的思考"></a>对当前公司架构的思考</h2><p>组织架构：<strong>混合式的优化版</strong></p>
<ol>
<li>大数据平台、数据仓库由技术部门统一负责</li>
<li>各个业务团队成立独立的数据分析部门，进行数据分析、挖掘、数据统一工作。也是由专业的数据分析人员构成，而非业务端的人员担任。</li>
</ol>
<p>优势：(1) 分析人员独立于业务部门，可以统一数据口径，并给出客观中立的报表； (2) 站在业务与后端IT 中间，作为两者最佳的构成桥梁，减少了沟通成本</p>
<p>劣势：一方面并没有真正贴近业务，另一方面偏离数据源有一定距离；一个是业务的理解，一个是资源分配与沟通；若处理不好，会进退两难；但若管理得当，是一个强有利的推进器。</p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;S：对数据工作做了总结之后（分为两大模块：数据平台、数据使用），想了解当前社会对数据分析工作的定位是如何的；引发通过了解 数据分析部门所处的组织架构去认识&lt;/p&gt;
&lt;p&gt;W：通过对组织架构的研究，去定义/剖析不同组织架构下数据分析部门当前所处的阶段与机制；&lt;/p&gt;
&lt;p&gt;B：达到状态：能够去辨别一家公司对数据分析工作的定位与重视度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个企业中，可能数据部门在一个公司中组织架构中的位置，决定了部门的定位和一些做的事情，数据部门所处的组织架构对数据价值实现是一个很重要因素。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>数据分析_发展历史</title>
    <link href="http://yoursite.com/2018/02/03/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/20_%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90_%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2_20180203/"/>
    <id>http://yoursite.com/2018/02/03/数据分析/20_数据分析/数据分析_发展历史_20180203/</id>
    <published>2018-02-02T16:00:00.000Z</published>
    <updated>2018-02-12T12:47:55.081Z</updated>
    
    <content type="html"><![CDATA[<p>觉察点 </p>
<p>S：看了《运营之光》中关于 “产品经理” 岗位需求猛增的原因，<strong>认识到一个事物/现在背后一个很重要且无法抗拒的变量：发展历史 及 当前所处的阶段</strong>；而当前自己正在重新思考数据分析的定义、价值，认为很有必要去做任务的了解</p>
<p>W：(1) 显性目的：了解数据分析发展的历史、当前所处阶段、未来发展阶段；（很明显这不是真正的目的）</p>
<p>​    (2) 隐形目的：结合自身，思考自己目前所处的是哪一个阶段；以及今后要努力的方向（改变行为）</p>
<p>​    (3) 达到状态：能够用自己的话将它表述出来，并清楚各个阶段的核心内容/关键点</p>
<p>O：应该从哪些角度去思考/寻找一个事物的发展历史？（方法论）</p>
<ul>
<li>基本概念、<strong>驱动因素、发展阶段、构成要素、模式类别</strong>、最佳实践、导入方法  ——《知而深知的七个快捷键》</li>
</ul>
<p>o：确定各个模块的具体内容，然后在思考从什么渠道去寻找这类信息。（书籍、网站）</p>
<p>R：这件事能够解决我的目的；还需要什么？</p>
<p>D：Defend your time.</p>
<a id="more"></a>
<p><br></p>
<h1 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>大师、企业家、权威机构；</p>
<p>求同，取精</p>
</blockquote>
<p><br></p>
<h2 id="驱动因素"><a href="#驱动因素" class="headerlink" title="驱动因素"></a>驱动因素</h2><blockquote>
<p>为什么产生、为什么受到关注、为什么变得流行</p>
</blockquote>
<p><br></p>
<h2 id="发展阶段"><a href="#发展阶段" class="headerlink" title="发展阶段"></a>发展阶段</h2><blockquote>
<p>特征、代表性观点/事件/人物、时间点</p>
</blockquote>
<p><br></p>
<h2 id="构成要素"><a href="#构成要素" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<p><br></p>
<h2 id="模式类别"><a href="#模式类别" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>分模块 或者 分模式</p>
</blockquote>
<p><strong>数据只有结合了业务才是有价值的，数据体现可以用四个字词概括，<u>看数据、用数据、依赖数据、数据变现</u>。</strong></p>
<blockquote>
<p><a href="http://www.afenxi.com/post/39570" target="_blank" rel="external">http://www.afenxi.com/post/39570</a></p>
</blockquote>
<ol>
<li><strong>看数据，</strong> 能然让业务准确、及时、完整的看到数据， 落地是在报表、取数等；</li>
<li><strong>用数据，</strong> 业务上通过数据做出决策 ，落地是异常监控/专题分析；</li>
<li><strong>依赖数据，</strong>数据嵌入到业务的日常流程中，通过<strong>数据挖掘高价值信息推进业务</strong>，落地点在数据产品，数据挖掘产品；</li>
<li><strong>数据变现，</strong>利用数据来赚钱了，落地点可在外部数据平台，数据产品上；</li>
</ol>
<p>在这整个环节中”数据分析师“是做什么呢？我们从分析师的日常工作来分析看，临时需求、报表、数据分析与模型、数据产品，数据挖掘这几个角度来聊一下；</p>
<p><strong>临时需求，</strong>就是解决业务的一次性，临时的数据需求；报表，是根据业务的需要，对于常规且定期查看与分析的数据，形成report；</p>
<p><strong>数据分析与模型</strong>，与业务一起沟通，分析业务上的各种问题，提供一些业务上的建议与取舍，根据业务需要搞一些挖掘模型等；</p>
<p><strong>数据产品，</strong>是通过可视化的方式解决一些结构化（固化）业务问题；把数据分析模型、分析思路与数据结合、面向定向业务提供分析产品；</p>
<p><strong>数据挖掘，</strong><u>数据直接作用到业务上，比如作弊用户、标签推荐、用户行为的定向引导；</u></p>
<p><br></p>
<h2 id="导入方法"><a href="#导入方法" class="headerlink" title="导入方法"></a>导入方法</h2><blockquote>
<p>工作 &amp; 成果</p>
</blockquote>
<p>数据人就要考虑在当前的业务状态中，该如何考虑对业务做到帮助与支持，或者是做数据的的人必须深入到业务中，如何深入呢，或者说是消息一定要灵通；</p>
<p>1、要与各种boss 1vs1 了解他们的想法。</p>
<p>2、参与到管理层的会议中，可以不用发言，但是要一定了解公司的管理层的理念、思路与战略、甚至是feature 的发布；</p>
<p>3、多的时数据人应该与运营在一起、一些活动、一些运营数据分析师也要参与进去也要尝试去一起做一下；</p>
<p>4、参与到公司的日常产品设计中去，在产品的立项阶段就去尝试获取信息；</p>
<p><br></p>
<h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote>
<p>资料来源：《数据挖掘与数据化运营实战》 - 卢辉 ；<a href="http://www.chforce.com/books/datamining-om-by-data/index.html" target="_blank" rel="external">http://www.chforce.com/books/datamining-om-by-data/index.html</a></p>
</blockquote>
<h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>数据挖掘是指从数据集合中<strong>自动抽取隐藏在数据中的</strong>那些有用信息的非平凡过程，这些信息的表现形式为规则、概念、规律及模式等。</p>
<p>数据挖掘融合了数据库、人工智能、机器学习、统计学、高性能计算、模式识别、神经网络、数据可视化、信息检索和空间数据分析等多个领域的理论和技术</p>
<p><br></p>
<h2 id="驱动因素-1"><a href="#驱动因素-1" class="headerlink" title="驱动因素"></a>驱动因素</h2><p><br></p>
<h2 id="发展阶段-1"><a href="#发展阶段-1" class="headerlink" title="发展阶段"></a>发展阶段</h2><p>数据挖掘起始于20世纪下半叶，是在当时多个学科发展的基础上发展起来的。随着数据库技术的发展应用，数据的积累不断膨胀，导致简单的查询和统计已经无法满足企业的商业需求，急需一些革命性的技术去挖掘数据背后的信息。同时，这期间计算机领域的人工智能（Artificial Intelligence）也取得了巨大进展，进入了机器学习的阶段。因此，人们将两者结合起来，<strong>用数据库管理系统存储数据，用计算机分析数据</strong>，并且尝试挖掘数据背后的信息。这两者的结合促生了一门新的学科，即数据库中的知识发现<strong>（Knowledge Discovery in Databases，KDD）</strong>。1989年8月召开的第11届国际人工智能联合会议的专题讨论会上首次出现了知识发现（KDD）这个术语，到目前为止，KDD的重点已经从发现方法转向了实践应用。</p>
<p>数据挖掘（Data Mining）则是知识发现（KDD）的核心部分，它指的是从数据集合中自动抽取隐藏在数据中的那些有用信息的非平凡过程，这些信息的表现形式为：规则、概念、规律及模式等。</p>
<p><br></p>
<h2 id="构成要素-1"><a href="#构成要素-1" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<p>数据挖掘融合了<u><strong>数据库、人工智能、机器学习、统计学、高性能计算、模式识别</strong></u>、神经网络、数据可视化、<u><strong>信息检索</strong></u>和空间数据分析等多个领域的理论和技术</p>
<p><br></p>
<h3 id="统计分析-VS-数据挖掘"><a href="#统计分析-VS-数据挖掘" class="headerlink" title="统计分析 VS. 数据挖掘"></a>统计分析 VS. 数据挖掘</h3><h4 id="应用过程"><a href="#应用过程" class="headerlink" title="应用过程"></a>应用过程</h4><ul>
<li>统计分析的基础之一就是<strong>概率论</strong>，在对数据进行统计分析时，分析人员常常需要对数据分布和变量间的关系做<strong>假设</strong>，确定<strong>用什么概率函数来描述变量间的关系</strong>，以及如何<strong>检验参数的统计显著性</strong></li>
<li>在数据挖掘的应用中，分析人员<strong>不需要对数据分布做任何假设</strong>，数据挖掘中的<strong>算法会自动寻找</strong>变量间的关系。</li>
</ul>
<p><br></p>
<h4 id="侧重点-解释-VS-预测"><a href="#侧重点-解释-VS-预测" class="headerlink" title="侧重点 - 解释 VS. 预测"></a>侧重点 - 解释 VS. 预测</h4><ul>
<li>统计分析在预测中的应用常表现为一个或一组<strong>函数关系式</strong> （易于解释）</li>
<li>数据挖掘在预测应用中的<strong>重点在于预测的结果</strong>，很多时候并不会从结果中产生明确的函数关系式，有时候甚至<strong>不知道到底是哪些变量在起作用，又是如何起作用的。</strong> （也无需知道）<ul>
<li>最典型的例子就是“神经网络”挖掘技术，它里面的隐蔽层就是一个“黑箱”，没有人能在所有的情况下读懂里面的非线性函数是如何对自变量进行组合的。</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="结合应用"><a href="#结合应用" class="headerlink" title="结合应用"></a>结合应用</h3><p>针对具体的业务分析需求，<strong>先确定分析思路，然后根据这个分析思路去挑选和匹配合适的分析算法、分析技术</strong>，而且一个具体的分析需求一般都会有两种以上不同的思路和算法可以去探索，最后可根据验证的效果和资源匹配等一系列因素进行综合权衡，从而决定最终的思路、算法和解决方案。</p>
<p><br></p>
<h2 id="模式类别-1"><a href="#模式类别-1" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><ol>
<li>概念：建模过程类似一棵树的成长过程，即从根部开始，到树干，到分枝，再到细枝末节的分叉，最终生长出一片片的树叶。在决策树里，所分析的数据样本先是集成为一个树根，然后经过层层分枝，最终形成若干个结点，每个结点代表一个结论。</li>
<li>优势：<strong>易解释、高容错性</strong><ul>
<li>它所产生的一系列从树根到树枝（或树叶）的规则，可以很<strong>容易地被分析师和业务人员理解</strong>，而且这些典型的规则甚至不用整理（或稍加整理），就是现成的可以应用的业务优化策略和业务优化路径。</li>
<li>决策树技术<strong>对数据的分布甚至缺失非常宽容</strong>，不容易受到极值的影响。</li>
</ul>
</li>
<li>应用：<strong>分类、预测</strong><ul>
<li>作为分类、预测问题的典型支持技术，它在用户划分、行为预测、规则梳理等方面具有广泛的应用前景，决策树甚至可以作为其他建模技术前期进行变量筛选的一种方法，即通过决策树的分割来筛选有效地输入自变量。</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><ol>
<li>概念：“神经网络” 就是通过输入多个非线性模型以及不同模型之间的<strong>加权互联</strong>（加权的过程在隐蔽层完成），最终得到一个输出模型。其中，隐蔽层所包含的就是非线性函数。<ul>
<li>目前最主流的“神经网络”算法是反馈传播（Backpropagation），该算法在多层前向型（Multilayer Feed-Forward）神经网络上进行学习，而多层前向型神经网络又是由一个输入层、一个或多个隐蔽层以及一个输出层组成的</li>
</ul>
</li>
<li>优势：<strong>自适应性、自组织性、高容错性</strong><ul>
<li>拥有特有的大规模<strong>并行结构</strong>和信息的<strong>并行处理</strong>等特点，因此它具有良好的自适应性、自组织性和高容错性，并且具有较强的学习、记忆和识别功能。</li>
</ul>
</li>
<li>劣势：<strong>不可解释性</strong><ul>
<li>知识和结果的不可解释性，没有人知道隐蔽层里的非线性函数到底是如何处理自变量的</li>
</ul>
</li>
<li>应用：<strong>分类、预测</strong><ul>
<li>在用户划分、行为预测、营销响应等诸多方面具有广泛的应用前景。</li>
</ul>
</li>
<li>模型的重要因素：<ul>
<li>层数</li>
<li>每层中输入变量的数量</li>
<li>联系的种类</li>
<li>联系的程度</li>
<li>转换函数，又称激活函数或挤压函数</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><ol>
<li><p>概念：回归（Regression）分析包括线性回归（Linear Regression），这里主要是指<strong>多元线性回归</strong>和<strong>逻辑斯蒂回归</strong>（Logistic Regression）。</p>
<p>​</p>
</li>
<li><p>多元线性回归主要描述一个因变量如何随着一批自变量的变化而变化，其回归公式（回归方程）就是因变量与自变量关系的数据反映。因变量的变化包括两部分：系统性变化与随机变化，其中，系统性变化是由自变量引起的（自变量可以解释的），随机变化是不能由自变量解释的，通常也称作残值。</p>
<ul>
<li>用来估算多元线性回归方程中自变量系数的方法中，最常用的是<strong>最小二乘法</strong>，即找出一组对应自变量的相应参数，以使因变量的<strong>实际观测值与回归方程的预测值之间的总方差减到最小</strong>。</li>
<li>主要假设：<ul>
<li>输入变量是确定的变量，不是随机变量，而且输入的变量间无线性相关，即<u>无共线性</u>。</li>
<li>随机误差的期望值总和为零，即<u>随机误差与自变量不相关</u>。</li>
<li>随机误差呈现<u>正态分布</u></li>
</ul>
</li>
</ul>
</li>
<li><p>逻辑斯蒂回归，它又包括响应预测、分类划分等。凡是预测“两选一”事件的可能性（比如，“响应”还是“不响应”；“买”还是“不买”；“流失”还是“不流失”），都可以采用逻辑斯蒂回归方程。</p>
<ul>
<li>因变量是介于0和1之间的概率</li>
<li><strong>最大似然法</strong>是逻辑斯蒂回归所采用的参数估计方法，<strong>其原理是找到这样一个参数，可以让样本数据所包含的观察值被观察到的可能性最大。</strong>这种寻找最大可能性的方法需要反复计算，对计算能力有很高的要求。最大似然法的优点是在大样本数据中参数的估值稳定、偏差小，估值方差小。</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><ol>
<li><p>概念：关联规则数据挖掘的主要目的是找<strong>出数据集中的频繁模式</strong>（Frequent Pattern），即多次重复出现的模式和并发关系（Cooccurrence Relationships），即同时出现的关系，频繁和并发关系也称作关联（Association）。</p>
<ul>
<li>应用关联规则最经典的案例就是购物篮分析（Basket Analysis），通过分析顾客购物篮中商品之间的关联，可以挖掘顾客的购物习惯，从而帮助零售商更好地制定有针对性的营销策略。</li>
<li>支持度（Support）和置信度（Confidence）是衡量关联规则强度的两个重要指标，它们分别反映着所发现规则的有用性和确定性。<ul>
<li>支持度：规则X→Y的支持度是指事物全集中包含X∪Y的<strong>事物百分比</strong>。支持度主要衡量规则的<strong>有用性</strong>，如果支持度太小，则说明相应规则只是偶发事件。在商业实战中，偶发事件很可能没有商业价值；</li>
<li>置信度：规则X→Y的置信度是指既包含了X又包含了Y的事物数量<strong>占所有包含了X的事物数量的百分比</strong>。置信度主要衡量规则的<strong>确定性（可预测性）</strong>，如果置信度太低，那么从X就很难可靠地推断出Y来</li>
</ul>
</li>
</ul>
<blockquote>
<p>婴儿尿不湿→啤酒[支持度=10%，置信度=70%]</p>
<p>这个规则表明，在所有顾客中，有10%的顾客同时购买了婴儿尿不湿和啤酒，而在所有购买了婴儿尿不湿的顾客中，占70%的人同时还购买了啤酒。发现这个关联规则后，超市零售商决定把婴儿尿不湿和啤酒摆放在一起进行促销，结果明显提升了销售额，这就是发生在沃尔玛超市中“啤酒和尿不湿”的经典营销案例。</p>
</blockquote>
</li>
<li><p>主要算法：Apriori</p>
<ul>
<li>（1）生成所有的频繁项目集。一个频繁项目集（Frequent Itemset）是一个支持度高于最小支持度阀值（min-sup）的项目集。</li>
<li>（2）从频繁项目集中生成所有的可信关联规则。这里可信关联规则是指置信度大于最小置信度阀值（min-conf）的规则。</li>
</ul>
</li>
<li><p>应用：比如发现单词间的并发关系以及Web的使用模式</p>
<ul>
<li>不但在数值型数据集的分析中有很大用途，而且在纯文本文档和网页文件中，也有着重要用途。</li>
</ul>
<p>​</p>
</li>
</ol>
<p><br></p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><ol>
<li><p>概念：针对几个特定的业务指标，可以将观察对象的群体按照相似性和相异性进行不同群组的划分。经过划分后，每个群组内部各对象间的相似度会很高，而在不同群组之间的对象彼此间将具有很高的相异度。</p>
</li>
<li><p>方法：算法可以分为<strong>划分的方法</strong>（Partitioning Method）、<strong>层次的方法</strong>（Hierarchical Method）、基于密度的方法（Density-based Method）、基于网格的方法（Grid-based Method）、基于模型的方法（Model-based Method）等，其中，前面两种方法最为常用。</p>
<ul>
<li>划分的方法（Partitioning Method），当给定m个对象的数据集，以及希望生成的细分群体数量K后，即可采用这种方法将这些对象分成K组（K≤m），使得每个组内对象是相似的，而组间的对象是相异的。<ul>
<li>常用的划分方法是K-Means方法，其具体原理是：首先，随机选择K个对象，并且所选择的每个对象都代表一个组的初始均值或初始的组中心值；对剩余的每个对象，根据其与各个组初始均值的距离，将它们分配给最近的（最相似）小组；然后，重新计算每个小组新的均值；这个过程不断重复，直到所有的对象在K组分布中都找到离自己最近的组。</li>
</ul>
</li>
<li>层次的方法（Hierarchical Method）则是指依次让最相似的数据对象两两合并，这样不断地合并，最后就形成了一棵聚类树。</li>
</ul>
</li>
<li><p>应用：既可以直接作为模型对观察对象进行群体划分（为业务方的精细化运营提供具体的细分依据和相应的运营方案建议）；又可在数据处理阶段用作数据探索的工具，包括发现离群点、孤立点，数据降维的手段和方法，通过聚类发现数据间的深层次的关系等。</p>
<p>​</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h3 id="贝叶斯方法"><a href="#贝叶斯方法" class="headerlink" title="贝叶斯方法"></a>贝叶斯方法</h3><ol>
<li><p>概念：贝叶斯分类方法（Bayesian Classifier）是非常成熟的统计学分类方法，它主要用来<strong>预测类成员间关系的可能性</strong>。比如通过一个给定观察值的相关属性来判断其属于一个特定类别的概率。贝叶斯分类方法是基于贝叶斯定理的，已经有研究表明，朴素贝叶斯分类方法作为一种简单贝叶斯分类算法甚至可以跟决策树和神经网络算法相媲美。</p>
<p>$$P(H|X) = {P(H|X)P(X) \over P(X)}$$</p>
<ul>
<li>其中，X表示n个属性的测量描述；H为某种假设，比如假设某观察值X属于某个特定的类别C；对于分类问题，希望确定P(H|X)，即能通过给定的X的测量描述，来得到H成立的概率，也就是给出X的属性值，计算出该观察值属于类别C的概率。因为P(H|X)是后验概率（Posterior Probability），所以又称其为在条件X下，H的后验概率。</li>
</ul>
<blockquote>
<p>举例来说，假设数据属性仅限于用教育背景和收入来描述顾客，而X是一位硕士学历，收入10万元的顾客。假定H表示假设我们的顾客将购买苹果手机，则P(H|X)表示当我们知道顾客的教育背景和收入情况后，该顾客将购买苹果手机的概率；相反，P(X|H)则表示如果已知顾客购买苹果手机，则该顾客是硕士学历并且收入10万元的概率；而P(X)则是X的先验概率，表示顾客中的某个人属于硕士学历且收入10万元的概率；P(H)也是先验概率，只不过是任意给定顾客将购买苹果手机的概率，而不会去管他们的教育背景和收入情况。</p>
<p>从上面的介绍可见，相比于先验概率P(H)，后验概率P(H|X)基于了更多的信息（比如顾客的信息属性），而P(H)是独立于X的。</p>
</blockquote>
</li>
<li><p>概念：朴素贝叶斯分类法（Naive Bayesian Classifier）。如果给定数据集里有M个分类类别，通过朴素贝叶斯分类法，可以预测给定观察值是否属于具有<strong>最高后验概率的特定类别</strong>，也就是说，朴素贝叶斯分类方法预测X属于类别Ci时，表示当且仅当</p>
<p>$$P(C_i|X) &gt; P(C_j|X) ; 1 \le j \le m， j \ne m$$</p>
<p>此时如果最大化P(Ci|X)，其P(Ci|X)最大的类Ci被称为最大后验假设，根据贝叶斯定理</p>
<p>$$P(C_i|X) = { P(X|C_i)P(C_i) \over P(X)}$$</p>
<p>可知，由于P(X)对于所有的类别是均等的，因此只需要P(X|Ci)P(Ci)取最大即可。为了预测一个未知样本X的类别，可对每个类别Ci估算相应的P(X|Ci)P(Ci)。样本X归属于类别Ci，当且仅当</p>
<p>P(Ci|X)＞P(Cj|X)1≤j≤m，j≠i</p>
</li>
<li><p>应用：<strong>分类</strong></p>
</li>
</ol>
<p><br></p>
<h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><ol>
<li>概念：支持向量机以结构风险最小为原则。在线性的情况下，就在原空间寻找两类样本的最优分类超平面。在非线性的情况下，它使用一种非线性的映射，将原训练集数据映射到较高的维上。在新的维上，它搜索线性最佳分离超平面。使用一个适当的对足够高维的非线性映射，两类数据总可以被超平面分开。<ul>
<li>设给定的训练样本集为{(x1,y1),(x2,y2),…,(xn,yn)}，其中xi∈Rn,y∈{-1,1}。</li>
<li>再假设该训练集可被一个超平面线性划分，设该超平面记为(w,x)+b=0。</li>
</ul>
</li>
<li>距离超平面最近的一类向量被称为支持向量（Support Vector），一组支持向量可以唯一地确定一个超平面。通过学习算法，SVM可以自动寻找出那些对分类有较好区分能力的支持向量，由此构造出的分类器则可以最大化类与类的间隔</li>
<li>优势：较好的适应能力和较高的分类准确率。</li>
<li>应用：分类、预测</li>
</ol>
<p><br></p>
<h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><ol>
<li>概念：主成分分析会通过线性组合将多个原始变量合并成若干个主成分，这样每个主成分都变成了原始变量的线性组合。<ul>
<li>这种转变的目的，一方面是可以大幅降低原始数据的维度，同时也在此过程中发现原始数据属性之间的关系。</li>
</ul>
</li>
<li>步骤：<ul>
<li>1）通常要先进行各变量的标准化工作，标准化的目的是将数据按照比例进行缩放，使之落入一个小的区间范围之内，从而让不同的变量经过标准化处理后可以有平等的分析和比较基础。</li>
<li>2）选择协方差阵或者相关阵计算特征根及对应的特征向量。</li>
<li>3）计算方差贡献率，并根据方差贡献率的阀值选取合适的主成分个数。</li>
<li>4）根据主成分载荷的大小对选择的主成分进行命名。</li>
<li>5）根据主成分载荷计算各个主成分的得分。</li>
</ul>
</li>
<li>因子分析：将主成分进行推广和延伸即成为因子分析（Factor Analysis），<strong>因子分析在综合原始变量信息的基础上将会力图构筑若干个意义较为明确的公因子</strong>；也就是说，采用少数几个因子描述多个指标之间的联系，将比较密切的变量归为同一类中，每类变量即是一个因子。之所以称其为因子，是因为它们实际上是不可测量的，只能解释。</li>
<li>主分成分析 VS. 因子分析 （主成分分析是因子分析的一个特例）<ul>
<li>主成分分析会<strong>把主成分表示成各个原始变量的线性组合</strong>，而因子分析则<strong>把原始变量表示成各个因子的线性组合</strong>。</li>
<li>主成分分析的重点在于解释原始变量的<strong>总方差</strong>，而因子分析的重点在于解释原始变量的<strong>协方差</strong>。</li>
<li>在主成分分析中，有几个原始变量就有几个主成分，而在因子分析中，因子个数可以根据业务场景的需要人为指定，并且指定的因子数量不同，则分析结果也会有差异。</li>
<li>在主成分分析中，给定的协方差矩阵或者相关矩阵的特征值是唯一时，主成分也是唯一的。但是在因子分析中，因子不是唯一的，并且通过旋转可以得到不同的因子。</li>
</ul>
</li>
<li>应用：<strong>数据处理、降维、变量间关系的探索</strong></li>
</ol>
<p><br></p>
<h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><ol>
<li>概念：假设检验的基本原理就是<strong>小概率事件原理</strong>，即观测小概率事件在假设成立的情况下是否发生。<u>如果在一次试验中，小概率事件发生了，那么说明假设在一定的显著性水平下不可靠或者不成立；如果在一次试验中，小概率事件没有发生，那么也只能说明没有足够理由相信假设是错误的，但是也并不能说明假设是正确的，因为无法收集到所有的证据来证明假设是正确的。</u><ul>
<li>假设检验的结论是在一定的显著性水平下得出的。因此，当采用此方法观测事件并下结论时，有可能会犯错，这些错误主要有两大类：<ul>
<li>第Ⅰ类错误：当原假设为真时，却否定它而犯的错误，即拒绝正确假设的错误。犯第Ⅰ类错误的概率记为α，通常也叫α错误，α=1-置信度。</li>
<li>第Ⅱ类错误：当原假设为假时，却肯定它而犯的错误，即接受错误假设的错误。犯第Ⅱ类错误的概率记为β，通常也叫β错误。</li>
</ul>
</li>
<li>上述这两类错误在其他条件不变的情况下是相反的，即α增大时，β就减小；α减小时，β就增大。α错误容易受数据分析人员的控制，因此在假设检验中，通常会先控制第Ⅰ类错误发生的概率α，具体表现为：在做假设检验之前先指定一个α的具体数值，通常取0.05或0.01，也可以取0.1或0.001。</li>
</ul>
</li>
<li>应用：运营效果的评估</li>
</ol>
<p><br></p>
<h1 id="大数据平台"><a href="#大数据平台" class="headerlink" title="大数据平台"></a>大数据平台</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>大师、企业家、权威机构；</p>
<p>求同，取精</p>
</blockquote>
<p><br></p>
<h2 id="驱动因素-2"><a href="#驱动因素-2" class="headerlink" title="驱动因素"></a>驱动因素</h2><blockquote>
<p>为什么产生、为什么受到关注、为什么变得流行</p>
</blockquote>
<h3 id="数据产品的产生"><a href="#数据产品的产生" class="headerlink" title="数据产品的产生"></a>数据产品的产生</h3><p>​    互联网企业随着数据更加逐渐被重视，分析师、数据开发在<strong>面对大量的数据需求、海量的临时需求疲惫不堪</strong>，变成了资源的瓶颈，在当时的状态传统的各类的Report、Olap 工具都无法满足互联网行业个性化的数据需求。<strong>开始考虑把需求固定化变为一个面向最终用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果</strong>，当总结出的指标、分析方法(模型)、使用流程与工具有机的结合在一起时<strong><u>数据产品</u></strong>就诞生了。</p>
<p>​    数据产品按照面向的功能与业务可以划分为<strong>面向平台级别的工具型产品、面向用户端的业务级数据产品。</strong></p>
<p>​    按照用户分类可以分为面向内部用户数据产品，面向外部用户个人数据产品、商户(企业)数据产品。<br>​    面向平台级别有数据质量、元数据、调度、资管配置、数据同步分发等等。</p>
<p><br></p>
<h2 id="发展阶段-2"><a href="#发展阶段-2" class="headerlink" title="发展阶段"></a>发展阶段</h2><blockquote>
<p>特征、代表性观点/事件/人物、时间点</p>
</blockquote>
<h3 id="非互联网时代"><a href="#非互联网时代" class="headerlink" title="非互联网时代"></a>非互联网时代</h3><p>自从数据仓库发展起来到现在，基本上可以分为五个时代、四种架构</p>
<ol>
<li>约在1991年前的全企业集成</li>
<li>1991年后的企业数据集成EDW时代</li>
<li>1994年-1996年的数据集市</li>
<li>1996-1997年左右的两个架构吵架</li>
<li>1998年-2001年左右的合并年代</li>
</ol>
<p>五个时代划分是以重要事件或代表人物为标志：</p>
<ol>
<li>在<strong>企业数据集成EDW</strong>时代其重要代表人物是<strong>Bill Inmon</strong> 代表作<strong>数据仓库</strong>一书，更重要是他提出了如何建设数据仓库的指导性意见与原则。他遵循的是自上而下的建设原则，这个导致后来数据仓库在千禧年传到中国后的几年内，几个大实施厂商都是遵守该原则的实施方法，后来的数据仓库之路等各种专业论坛上针对数据仓库ODS-EDW的结构讨论</li>
<li>在<strong>数据集市</strong>年代其代表人物是<strong>Ralph kilmball</strong>，他的代表作是”The Data Warehouse Toolkit“，在数据仓库的建设上Ralph kilmball 提出的是自下而上的建设方法，刚好与Bill Innmon的建设方法相反，这两种架构方式各有千秋，所以就进入了争吵时代。</li>
<li>Bill Inmon 提出的CIF（corporation information factory） 架构模式、这也算是数据仓库的第三代架构，其架构特点是把整个架构划分为不同层次，把每一层次的定义与功能都详细的描述下来，从04年后国内的很多数据仓库架构、甚至互联网刚开始搞数据平台数据仓库架构模式也是这一种。</li>
</ol>
<p><br></p>
<p>ETL 代指数据从不同源到数据平台的整个过程，ETL Mapping 可理解为 数据加工算法，</p>
<p><br></p>
<h3 id="互联网时代"><a href="#互联网时代" class="headerlink" title="互联网时代"></a>互联网时代</h3><h4 id="数据源：多样化"><a href="#数据源：多样化" class="headerlink" title="数据源：多样化"></a>数据源：多样化</h4><p>​    做数据的人，从非互联网进入到互联网最显著的特点是面对的数据源类型忽然多了起来，在传统企业数据人员面对的是结构化存储数据，基本来自excel、表格、DB系统等，在数据的处理技术上与架构上是非常容易总结的，但是在互联网因为业务独特性导致了所接触到的数据源特性多样化，网站点击日志、视频、音频、图片数据等很多非结构化快速产生与保存</p>
<p>​    目前最火热的移动互联网,大家都在通过自己的手机、平板去访问网站、购物等所以每个人都是数据的生产者，移动用户在使用习惯上呈现移动化、碎片化，以至于业务特性、商业模式比传统互联网又有显著差别, 用户在不同位置需求是不同的、使用APP 也是不同的、手机终端类型也是多样化。这些差异性比较导致移动互联网的数据与传统的互联网时代又产生显著差异性。</p>
<blockquote>
<p>例如买家通过Pc购物从浏览物品到支付可能在很短时间内完成，但是通过手购物碎片化就显得多一些，可能在某个空余时间浏览物品，保存或放入购物车，等有时间在去做支付。大约在2009年到2012年之间做用户行为分析感觉很多原有网页端拍下物品去支付，逐渐转为PC端下单通过移动端支付。</p>
</blockquote>
<p>表 - 不同时代数据源的对比</p>
<table>
<thead>
<tr>
<th>行业域</th>
<th>非互联网</th>
<th>互联网</th>
<th>移动互联网</th>
</tr>
</thead>
<tbody>
<tr>
<td>数据来源(相对于数据平台来讲)</td>
<td>结构化各类数据库(DB系统)、结构化文本、Excel表格等，少量word</td>
<td>Web、自定义、系统的日志，各类结构化DB数据、长文本、视频 主要是来自网页</td>
<td>除了互联网那些外还含有大量定位数据、自动化传感器、嵌入式设备、自动化设备等</td>
</tr>
<tr>
<td>数据包含信息</td>
<td>CRM客户信息、事务性 ERP/MRPII 数据、资金账务数据 等。</td>
<td>除了传统企业数据信息外，还含有用户各类点击日志、社交数据、多媒体、搜索、电邮数据等等</td>
<td>除了传统互联网的数据外，还含有Gps、穿戴设备、传感器各类采集数据、自动化传感器采集数据等等</td>
</tr>
<tr>
<td>数据结构特性</td>
<td>几乎都是结构化数据</td>
<td>非结构化数据居多</td>
<td>非结构化数据居多</td>
</tr>
<tr>
<td>数据存储/数据量</td>
<td>主要以DB结构化存储为主，从几百兆到 百G级别</td>
<td>文件形式、DB形式，流方式、 从TB 到PB</td>
<td>文件形式、流方式、DB范式，非结构化 从TB 到PB</td>
</tr>
<tr>
<td>产生周期</td>
<td>慢，几天甚至周为单位</td>
<td>秒或更小为单位</td>
<td>秒或更小为单位</td>
</tr>
<tr>
<td>对消费者行为采集与还原</td>
<td>粒度粗</td>
<td>粒度较细</td>
<td>粒度非常细</td>
</tr>
<tr>
<td>数据价值</td>
<td>长期有效</td>
<td>随着时间衰减</td>
<td>随着时间快速衰减</td>
</tr>
<tr>
<td>单位时间内数据聚合度</td>
<td>高度聚合</td>
<td>聚合度低</td>
<td>聚合度很低</td>
</tr>
</tbody>
</table>
<p><br></p>
<h4 id="数据平台的用户"><a href="#数据平台的用户" class="headerlink" title="数据平台的用户"></a>数据平台的用户</h4><ol>
<li><p><strong>阶段1：在2008年-2011年初。</strong>建设与使用上与非互联网数据平台有这蛮大的相似性，主要相似点在数据平台的建设角色、与使用到的技术上。</p>
<ul>
<li>老板们、运营的需求主要是依赖于报表、分析报告、临时需求、商业智能团队的<a href="http://www.thebigdata.cn/JiShuBoKe/31800.html" target="_blank" rel="external">数据分析</a>师去各种分析、临时需求、挖掘，这些角色是数据平台的适用方。</li>
<li>ETL开发工程师、数据模型建模、数据架构师、报表设计人员 ，同时这些角色又是数据平台数据建设与使用方。</li>
<li>数据平台的技术框架与工具实现主要有技术架构师、JAVA 开发等。</li>
<li>用户面对是结构化的生产数据、PC端非结构化log等 数据。</li>
<li>ELT的数据处理方式(备注在数据处理的方式上，由传统企业的ETL 基本进化为ELT)。</li>
</ul>
</li>
<li><p><strong>阶段2：约在2011年到2014 年。数据产品的诞生。</strong>互联网的数据平台除了受到技术、数据量的驱动外，同时还来自数据产品经理梳理用户的需求按照产品的思维去构建并部署在了数据的平台上。随着数据平台的建设逐渐的进入快速迭代期，数据产品、数据产品经理这两个词逐渐的升温以及被广泛得到认可，同时<strong>数据产品</strong>也随着需求、平台特性分为<strong>面向用户级数据产品、面向平台工具型产品</strong>两个维度分别去建设数据平台。</p>
<ul>
<li>企业各个主要角色都是数据平台用户。</li>
<li>各类数据产品经理(偏业务数据产品、偏工具平台数据产品)推进数据平台的建设。</li>
<li>分析师参与数据平台直接建设比重增加。</li>
<li>数据开发、数据模型角色都是数据平台的建设者与使用者(备注：相对与传统数据平台的数据开发来说，逐渐忽略了数据质量的关注度，数据模型设计角色逐渐被弱化)。</li>
<li>用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。</li>
<li>原有ETL中部分数据转换功能逐渐前置化，放到业务系统端进行(备注：部分原有在ETL阶段需要数据标准化一些过程前置在业务系统数据产生阶段进行，比如Log 日志。 移动互联网的日志标准化。</li>
</ul>
</li>
<li><p><strong>阶段3：</strong>从经营、分析的诉求重点转为数据化的<strong>精细运营上</strong>，对数据的粒度要求<strong>由高汇总逐渐转为过程化细粒度明细数据。</strong></p>
<ul>
<li>随着数据应用的深入，用数据往往不知道数据的口径与来源，加工数据的不知道业务含义，不同部门口径又是不一样，有的从交易来、有的从账务来。这里数据使用与数据加工上就出现了”断层”。有时在层级与功能部门前边也可能存在一个断层，对数据价值的内在衡量是不一样的，角色不一样，对于数据价值的的看法也就不同。</li>
<li>用数据的一些角色(分析师、运营或产品)会自己参与到从数据整理、加工、分析阶段。</li>
<li>当数据平台变为自由全开放，使用数据的人也参与到数据的体系建设时，基本会因为不专业型，导致数据质量问题、重复对分数据浪费存储与资源、口径多样化等等原因。此时原有建设数据平台的多个角色可能转为对其它非专业做数据人员的培训、咨询与落地写更加适合当前企业数据应用的一些方案等。</li>
<li>给用户提供的各类丰富的分析、取数的产品，简单上手的可以使用。</li>
<li>原有ETL、数据模型角色转为给用户提供平台、产品、数据培训与使用咨询。</li>
<li>数据分析师直接参与到数据平台过程、数据产品的建设中去。</li>
<li>用户面对是数据源多样化，比如日志、生产数据库的数据、视频、音频等非结构化数据。</li>
</ul>
<blockquote>
<p>比如说她，是银行的一名普通职员，每天的任务是结算、结汇，从早到晚都在跟数据打交道；因为只用整理好的数据，所以自然不在乎也不注意，数据是如何来的；<strong>整个总结下来是，用数据的人不知道数据哪里来的，做数据的人不知道数据有什么用处；</strong>回忆了下，这还真是一个普遍的现象；</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h2 id="构成要素-2"><a href="#构成要素-2" class="headerlink" title="构成要素"></a>构成要素</h2><blockquote>
<p>模块、方面组成</p>
</blockquote>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><blockquote>
<p>在互联网时代被弱化的数据模型</p>
</blockquote>
<p>在传统数据平台要背后有一个完整数据仓库团队去服务业务方，业务方嗷嗷待哺的等待被动方式去满足。中低层数据基本不会对业务方开放，所以不管数据模型采用何种建模方式，主要满足当时数据架构规划即可。</p>
<p>互联网业务的快速发展使得大家已经从经营、分析的诉求重点转为数据化的精细运营上，如何做好精细化运营问题上来，当资源不够时用户就叫喊，甚至有的业务方会挽起袖子来自己参与到从数据整理、加工、分析阶段。</p>
<p><br></p>
<h2 id="模式类别-2"><a href="#模式类别-2" class="headerlink" title="模式类别"></a>模式类别</h2><blockquote>
<p>特点、典型代表、优劣势、适用情况</p>
<p>优劣势 &amp; 适用情况 很重要；一则可以是具体的工作与场景，二则可以是不同的企业/行业发展阶段</p>
</blockquote>
<p><br></p>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><blockquote>
<p>分模块 或者 分模式</p>
</blockquote>
<p><br></p>
<h2 id="导入方法-1"><a href="#导入方法-1" class="headerlink" title="导入方法"></a>导入方法</h2><blockquote>
<p>工作 &amp; 成果</p>
</blockquote>
<p><br></p>
<h1 id="数据产品"><a href="#数据产品" class="headerlink" title="数据产品"></a>数据产品</h1><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><p>要想把数据产品定义清楚，要拆分成 “数据”、“产品” 两个维度来看。</p>
<p><strong>“产品”</strong> 是一组将输入转化为输出的相互关联或相互作用的活动的结果，<strong>即“过程” 的结果“</strong>。在经济领域中,通常也可理解为组织制造的任何制品或制品的组合。<strong>产品的狭义概念:被生产出的物品；产品的广义概念:可以满足人们需求的载体。</strong></p>
<p><strong>互联网产品的概念</strong>是从传统意义上的“产品”延伸而来的，是在互联网领域中产出而用于经营的商品，它是满足互联网用户需求和欲望的无形载体。简单来说，互联网产品就是指网站为满足用户需求而创建的用于运营的功能及服务，它是网站功能与服务的集成。<em>大家可以分析下百度、腾讯、新浪、优酷、谷歌、facebook 各自的“产品”是什么？</em></p>
<p><strong>移动互联网产品又是什么呢？</strong>我是没有找到比较贴切的概念，只好依照自己简单的想象<u>“已移动设别、网络为基础，构建满足人们的需求而创造出来的功能与服务”，</u>例如基于手机、平板设备上的各种App，微信、手机百度、ingress手游、网易客户端等。</p>
<p><strong>所谓的产品，简单讲就是满足人们某个需求、或解决某个问题的东西。</strong></p>
<p><br></p>
<h2 id="发展阶段-3"><a href="#发展阶段-3" class="headerlink" title="发展阶段"></a>发展阶段</h2><p>自1954年计算机用于工资处理以后，一直到2016年的今天，企业在信息化处理上得到了长足的发展。在这个发展中经历过了数据处理系统、Mis管理系统、决策支持、商业智能。</p>
<p><br></p>
<h3 id="DSS决策支持"><a href="#DSS决策支持" class="headerlink" title="DSS决策支持"></a>DSS决策支持</h3><p><strong>Dss决策支持系统</strong>是建立在对传统企业历史数据集成基础上的数据探索应用，自从数据仓库的出现给对企业的决策支持注入了新的活力，发展到现在的互联网、移动互联网对数据的应用又是一个崭新阶段。</p>
<p>在<strong>20世纪60年到70年</strong>，决策中往往是需要查询多种异构数据源的业务系统、参考外部的数据，进行大量的数据分析后才能做出相关的决策来。</p>
<p>进入到<strong>20世纪80年代</strong>后，随着计算机技术发展、各类数据统计分析的工具逐步健全，尤其是数据仓库的技术发展给传统企业的决策支持系统带来了更大的便利性。传统企业更多的是围绕着日常经营去做经营分析，比如财务绩效状况、资产运营状况、偿债能力状况、发展能力状况等。</p>
<p><br></p>
<h3 id="商业智能"><a href="#商业智能" class="headerlink" title="商业智能"></a>商业智能</h3><p><strong>商业智能（Business Intelligence，简称BI）</strong>的概念最早是Gartner Group 的 Howard Dresner在<strong>1996 年</strong>提出来，传到国内有将之翻译为”商业智能”或”商务智能”。商业智能的应用领域典型电信、银行、保险、零售等，所有建立了数据仓库的企业其商业智能建设的<strong>主要目标是企业决策支持。</strong>商业智能通过对信息技术的运用在不同层面为战略、决策提供新的支持：提升决策者洞察力以及支持信息获取与分析。</p>
<p><strong>在传统企业的商业智能时代</strong>，我个人对其的认识是商业智能本来是<strong>把数据分析和统计运算的结果以多角度的方式存储，然后在OLAP、Report平台上形成一个个面向不同业务需要的数据集市以可视化的展现</strong>，让公司的管理层可以通过看及时和合适方式展示出来的信息来决策，让基层可以用统计运算后的数据进行经营分析与企业日常运作。</p>
<p>这种方式的<strong>核心</strong>是Bill Inmon 、Ralph Kimball的数据仓库Data Warehouse与Codd创造OLAP一词，E.F.Codd发明了在线分析处理（OLAP）一词，来表示多维分所结合的模式，为客户提供OLAP 平台，通过开发一些Report、Dashboard，后台通过ETL 自动刷新数据。        <em>其中ETL工具在当时使用的是Datastage、Informatica、微软Dts或自己开发的脚本等系列来做数据的清洗、转换、加载，而OLAP 平台基本上为BO、Congos、Oracle 等几家的OLAP引擎与报表设计平台。在数据仓库 Data warehouse 中大家可以看到DW层为存储、管理数据设计的模型、数据集市中为 OLAP 而设计的模型。其中数据集市的数据就是数据仓库各层的数据Join与Aggregate的数据集合。</em></p>
<p><strong>传统的数据团队的困惑</strong>在盲目的跟着需求开发，导致开发成果无法确认是否有用、够用，也无法避免无休止的需求变更，导致系统开发成本高、周期长、失败率居高不下。这样的数据平台最大的特点是庞大，初次使用感觉功能非常新鲜，但是在面对具体需求时使用起来难用，无法真正的解决问题。根本没有系统化、产品化，只是一堆数据的堆砌，僵死的报表或cube 开发、设计与开发与业务脱节非常严重，没有任何衔接可言。</p>
<p>——–分割线——–</p>
<p>随着时间的发展，业界听到的BI的声音越来越少了，反而是<strong>对探索数据的价值的数据分析、数据挖掘独立的声音出现</strong>，因为早期传统企业的BI在这件上非常吃力，在过去只是简单从不同角度的堆积数据看统计指标已经不适应决策要看原因，要看影响的程度，执行层面要根据数据分析、挖掘精确来执行。</p>
<ul>
<li>比如过去我们只是看商场的不同品牌的货物卖出多少，在现在要看商品在一天的那个时间段卖的好、摆放哪个位置卖的好、什么样的顾客容易买，客户总消费多少钱，客户订单次数，客户平均客单价、客户最近订单时间等等。</li>
</ul>
<p><strong>初BI</strong>刚进入企业眼前的时候，认为BI可以做很多厉害的事情，各种智能化。随着时间推移，BI从天上掉到了地下，90%多的企业只<strong>剩下数据集成和报表生成部门</strong>。目前一般企业普遍采用的办法是由业务部门提出分析需求，让BI部门统计和分析数据出结果，这样的组合看似合理，却有很多隐患。</p>
<ul>
<li>记得有家公司组建自己的BI团队前，曾经去寻找多家第三方企业来实BI，建立了数据模型和数据处理，交付物开发出各个业务线的需求报表，按照会员维度的日报、周报、月报，商户维度的日报、周报、月报。<strong>然后呢</strong>，业务上尝鲜几天时还挺爽，随后越来越少用直至不用，因为随着堆积迭代无法满足后来的业务需求，其主要数据质量有问题，每个报表数据经常不准、报表上根本看不出什么业务问题来，需要多张报表数据下载进一步加工，这是典型的不深入了解业务而导致数据模型、数据报表堆砌效应引起的。</li>
</ul>
<p><strong>当时大多数BI只能发挥不到1/3的作用，所受限制在于业务与数据的反复磨合，还有数据洞察与整合的客观的业务需要代沟，所谓的数据驱动只是停留在数据与业务分开干的阶段。</strong></p>
<p><br></p>
<h3 id="数据运营"><a href="#数据运营" class="headerlink" title="数据运营"></a>数据运营</h3><p><strong>大家已经从经营、分析的诉求重点转为数据化的精细运营上</strong>。随之而来的面临创新压力、如何做好精细化运营是当今企业遇到的问题。比如一款产品，想在互联网生存下去， 用户是基础，没有用户的产品或许可以自娱自娱自乐，否则将会面临一个问题，如何拉新、如何研究新用户，如何根据不同的用户习惯来调整产品。 对于产品的新用户，使用时会遇到各种问题，产品运营就必须去关注、去分析、以及去解决，<strong>这些过程都是需要数据来衡量与定位的。</strong>如果整个公司都处在一种由之前简单粗暴运营向经营分析乃至数据驱动的运营，必然会造成数据需求暴增。</p>
<p><strong>【数据产品产生的原因】</strong></p>
<ul>
<li>数据化运营对数据需求量越来越大，分析师、数据开发在面对大量的数据需求、海量的临时需求疲惫不堪，变成了资源的瓶颈， 用户其聚焦在无法快速的响应日常需求其表现为，做数据的已经无法满足当前业务日益增长的数据需求。</li>
<li>互联网企业在运营上精细化已经对数据的粒度要求由高汇总逐渐转为过程化细粒度明细数据。而传统的各类的Report、OLAP 工具都无法满足互联网行业个性化的数据需求。</li>
<li>统计过某公司近两个月分析师们的工作内容,背景是从3月份-5月份大家在邮件、需求登记管理平台等内容。大约覆盖分析师3个月工作85%左右，临时需求在69.44%之间，产品发布评估占到 8.89%、周期性需求为（新业务日报周报）6.11%、专题分析8%、数据类项占比为6.67%。这个团队的分析师平均每月工作天数如果全饱和，单纯临时需求总共消耗分析师超过140%时间，均超过35%人月，分析师没有一点时间搞其他的。变成了<strong>纯粹人肉取数机</strong>，更何况分析师还有其它日常工作、专题分析等，更不要说让分析师更有价值。</li>
</ul>
<p>当数据平台、数据分析师想摆脱临时需求的困扰，提高自身的价值时，开始考虑把需求固定化变为一个面向用户自助式、半自助的产品来满足快速获取数据&amp;分析的结果，<strong>当总结出的指标、分析方法（模型）、使用流程与工具有机的结合在一起时候，适合互联网时代的一类数据产品就诞生了。</strong></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;觉察点 &lt;/p&gt;
&lt;p&gt;S：看了《运营之光》中关于 “产品经理” 岗位需求猛增的原因，&lt;strong&gt;认识到一个事物/现在背后一个很重要且无法抗拒的变量：发展历史 及 当前所处的阶段&lt;/strong&gt;；而当前自己正在重新思考数据分析的定义、价值，认为很有必要去做任务的了解&lt;/p&gt;
&lt;p&gt;W：(1) 显性目的：了解数据分析发展的历史、当前所处阶段、未来发展阶段；（很明显这不是真正的目的）&lt;/p&gt;
&lt;p&gt;​    (2) 隐形目的：结合自身，思考自己目前所处的是哪一个阶段；以及今后要努力的方向（改变行为）&lt;/p&gt;
&lt;p&gt;​    (3) 达到状态：能够用自己的话将它表述出来，并清楚各个阶段的核心内容/关键点&lt;/p&gt;
&lt;p&gt;O：应该从哪些角度去思考/寻找一个事物的发展历史？（方法论）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本概念、&lt;strong&gt;驱动因素、发展阶段、构成要素、模式类别&lt;/strong&gt;、最佳实践、导入方法  ——《知而深知的七个快捷键》&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;o：确定各个模块的具体内容，然后在思考从什么渠道去寻找这类信息。（书籍、网站）&lt;/p&gt;
&lt;p&gt;R：这件事能够解决我的目的；还需要什么？&lt;/p&gt;
&lt;p&gt;D：Defend your time.&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>R转战Python</title>
    <link href="http://yoursite.com/2018/02/01/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/R%E8%BD%AC%E6%88%98Python_20180201/"/>
    <id>http://yoursite.com/2018/02/01/软件应用_程序编程/Python/Python_专题总结/R转战Python_20180201/</id>
    <published>2018-01-31T16:00:00.000Z</published>
    <updated>2018-02-13T13:12:59.942Z</updated>
    
    <content type="html"><![CDATA[<p> <strong>从R转战Python：这些包你一定要知道！</strong></p>
<a id="more"></a>
<h3 id="统计学习"><a href="#统计学习" class="headerlink" title="统计学习"></a>统计学习</h3><ul>
<li><strong>R包glm，knn，randomForest，e1071 —&gt; Python模块scikit-learn</strong></li>
</ul>
<p>R中机器学习算法被进行分割，然后以各种包的形式存放，这意味着除非具有单个（或一组）能够执行一些公共算法的机器学习库，否则每个算法都会存在单独的包中。看着这些复杂、但又很清楚的算法时感觉会有点不错，但当日复一日的在算法之间来回切换时，恐怕就会觉得不适了，Python中的scikit-learn模块很好的处理了这个问题。具体的说，scikit-learn提供了一组常见的ML算法，所有算法都在同一个API下，这使得LogisticRegression和GradientBoostingMachines之间可以直接切换。</p>
<p><br></p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><ul>
<li><strong>R包reshape/reshape2,plyr/dplyr —&gt; Python模块 pandas</strong></li>
</ul>
<p>Pandas继承了R中数据变换的较好部分，并且把它转变成一个Python包。该包包括了python中数据框的实现以及修改和重构数据框的方法。基本上它继承了reshape/reshape2和plyr/dplyr并且python化它。</p>
<p><br></p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul>
<li><strong>stringr -&gt; nothing</strong></li>
</ul>
<p>stringr 实在是个神器。它写得很棒，性能也很好（至少我这么认为），而且很方便安装（不要小看这一点，如果人们无法安装你的软件，那么开发就没有意义）。关于stringr 的自卖自夸就结束了。好消息是Python的字符串功能很强大，你甚至不需要一个单独的字符串库！它有<u>超棒的内置正则表达式库，re，和内置的字母串元库，叫string。</u>你太幸运了，Python自带了全部字符串相关的功能。</p>
<p><br></p>
<h4 id="动态报告"><a href="#动态报告" class="headerlink" title="动态报告"></a>动态报告</h4><ul>
<li><strong>R包Knitr —&gt; Python模块 Jupyter</strong></li>
</ul>
<p>Knitr是一种使用R创建可重现和高度可视化分析的好方法。它已经成为Rtudio中一种稳定的功能。在Python世界中，最类似的包是Jupyter。Jupyter笔记本提供了一个用于Python编程（和其他语言）的交互式环境，专注于再现和可视化—它甚至有针对于R的插件。</p>
<p><br></p>
<h3 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h3><ul>
<li><strong>R包SQLdf—&gt; Python模块 pandasql</strong></li>
</ul>
<p>Sqldf是SQL用户在熟练操作数据的伟大的方式。当我第一次开始学R时，我自己用的就是这个包。当时，Yhat实际上创建了类似的Python包，称为pandasql。相同的概念：对你的数据框写入SQL查询命令，获取数据框！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; &lt;strong&gt;从R转战Python：这些包你一定要知道！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_安装设置&amp;jupyter</title>
    <link href="http://yoursite.com/2018/01/24/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE&amp;Jupyter/"/>
    <id>http://yoursite.com/2018/01/24/软件应用_程序编程/Python/Python_专题总结/Python_安装设置&amp;Jupyter/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-02-13T13:44:28.505Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Anaconda安装"><a href="#Anaconda安装" class="headerlink" title="Anaconda安装"></a>Anaconda安装</h2><ul>
<li>‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。</li>
</ul>
<blockquote>
<p>这个问题本质其实就是，windows的cmd并不能识别python这个符号（即无法识别这个符号是一个可执行程序），因为windows这里也是类似的，遇到一个字符，先会在默认path路径查询这个符号是不是一个可执行程序</p>
</blockquote>
<p>右键我的电脑-&gt;属性-&gt;高级系统配置-&gt;点击高级一栏，在这里栏点开环境变量-&gt;在系统变量PATH加入python的安装路径即可，比如我的就是D:\Python27</p>
<ul>
<li><code>pip</code>不是内部或外部命令，也不是可运行的程序</li>
</ul>
<p>添加Python的Script  到环境变量；在Path后面追加一下内容(Path： 不要复制进去) <code>Path:;C:\python;C:\Python\Scripts</code></p>
<a id="more"></a>
<p><br></p>
<h2 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h2><blockquote>
<p>查看Python版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; cmd</div><div class="line">&gt; python -v </div><div class="line">&gt;</div><div class="line">&gt; <span class="comment"># 或者</span></div><div class="line">&gt; cmd</div><div class="line">&gt; python --version</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h3 id="pip-安装与卸载"><a href="#pip-安装与卸载" class="headerlink" title="pip 安装与卸载"></a>pip 安装与卸载</h3><blockquote>
<p>安装好Anaconda后，就默认安装了包管理工具pip</p>
</blockquote>
<ul>
<li>在命令提示符（cmd）窗口中使用命令pip install xxx（xxx表示要安装的包或模块名）。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pip install numpy  <span class="comment"># 安装</span></div><div class="line">pip install -U PackageName  <span class="comment"># 更新</span></div><div class="line">pip uninstall PackageName  <span class="comment"># 移除</span></div><div class="line">pip search PackageName  <span class="comment"># 搜索</span></div><div class="line">pip help  <span class="comment"># 帮助</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>conda 安装</strong></li>
</ul>
<p><br></p>
<h3 id="下载文件安装"><a href="#下载文件安装" class="headerlink" title="下载文件安装"></a>下载文件安装</h3><blockquote>
<p>若一种方法失败，可尝试用另一种方式</p>
</blockquote>
<ul>
<li>直接下载包或模块的安装文件，然后手动安装<ul>
<li><a href="https://pypi.python.org/pypi" target="_blank" rel="external">PyPI-the Python Package Index</a></li>
<li><a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml" target="_blank" rel="external">https://www.lfd.uci.edu/~gohlke/pythonlibs/#lxml</a></li>
<li><a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">Python Extension Packages</a></li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>PyPI-the Python Package Index</strong></p>
<ol>
<li>在上面右上角红线框住的search中输入你要下载的包或模块名，即可进入下载页面。下载的是<strong>压缩文件</strong></li>
<li>解压 </li>
<li>在命令提示符窗口中，使用cd进入到解压后的文件的路径下 </li>
<li>输入命令python setup.py install</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmd </div><div class="line">cd /d  G:\Downloads\Chrome</div><div class="line">python setup.py install</div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<ul>
<li><strong>Python Extension Packages</strong><ol>
<li>直接把文件拷贝到 $python_dir/Lib/site packages </li>
<li>在命令提示符窗口中，转到指定路径（.whl安装文件的路径） </li>
<li>pip install .whl 文件名</li>
</ol>
</li>
</ul>
<blockquote>
<p>site_packages 用来存放第三方库</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cmd</div><div class="line">cd /d G:\Downloads\Chrome</div><div class="line">pip install</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="单文件模块"><a href="#单文件模块" class="headerlink" title="单文件模块"></a>单文件模块</h3><ul>
<li>直接把文件拷贝到 $python_dir/Lib/site packages </li>
</ul>
<h3 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h3><ul>
<li><strong>Microsoft Visual C++ 14.0 is required.</strong><ul>
<li>往往并不是缺少 Visual 2015 ；而是缺少某个依赖包</li>
</ul>
</li>
</ul>
<p><br></p>
<h2 id="模块使用"><a href="#模块使用" class="headerlink" title="模块使用"></a>模块使用</h2><p><br></p>
<h4 id="获取模块地址"><a href="#获取模块地址" class="headerlink" title="获取模块地址"></a>获取模块地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> a_module</div><div class="line"><span class="keyword">print</span> a_module.__file__</div><div class="line"></div><div class="line"><span class="comment"># 上述代码将范围 .pyc 文件被加载的路径，如果需要跨平台解决方案，可用下面代码：</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line">path = os.path.dirname(amodule.__file__)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="导入与移除模块"><a href="#导入与移除模块" class="headerlink" title="导入与移除模块"></a>导入与移除模块</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导入 </span></div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> *</div><div class="line"></div><div class="line"><span class="comment"># 移除</span></div><div class="line"><span class="keyword">del</span> pd</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="连接数据库库"><a href="#连接数据库库" class="headerlink" title="连接数据库库"></a>连接数据库库</h2><blockquote>
<p>MySQL需要MySQLdb，SQL Server需要pymssql。两个模块大同小异，都遵循Python Database API</p>
<p> 必须先下载pymssql 模块，才能使用；<a href="http://www.pymssql.org/en/stable/" target="_blank" rel="external">http://www.pymssql.org/en/stable/</a></p>
</blockquote>
<p>安装pymssql好之后开工了。如果是连接本地的SQL Server需要在 SQL Server Configuration 中打开TCP/IP协议</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1335634-93526fa3dfa8f525.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/562" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#coding=utf-8</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(host=<span class="string">'127.0.0.1'</span>,user=<span class="string">'sa'</span>,</div><div class="line">                       password=<span class="string">'hello'</span>,database=<span class="string">'NPKW'</span>,</div><div class="line">                      charset=<span class="string">"utf8"</span>)</div><div class="line"><span class="comment">#查看连接是否成功</span></div><div class="line"><span class="keyword">print</span> conn</div><div class="line">cursor = conn.cursor()</div><div class="line">sql = <span class="string">'select * from contacts'</span></div><div class="line">cursor.execute(sql)</div><div class="line"><span class="comment">#用一个rs变量获取数据</span></div><div class="line">rs = cursor.fetchall()</div><div class="line"><span class="keyword">print</span> rs</div></pre></td></tr></table></figure>
<blockquote>
<p><pymssql.connection object="" at="" 0x02ff2cb0=""></pymssql.connection></p>
<p><pymssql.cursor object="" at="" 0x03124110=""><br>[(1, u’20111612210028’, u’ettingshausen’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’, u’’)]</pymssql.cursor></p>
</blockquote>
<p><br></p>
<h3 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h3><blockquote>
<p>Python Database API，只需要了解Connection Objects和Cursor Objects的常用方法。</p>
</blockquote>
<p>基本的步骤就是：</p>
<ol>
<li>使用<code>connect</code>创建连接对象</li>
<li><code>connect.cursor</code>创建游标对象，SQL语句的执行基本都在游标上进行</li>
<li><code>cursor.executeXXX</code>方法执行SQL语句，<code>cursor.fetchXXX</code>获取查询结果等<ul>
<li>通过cursor获取数据，具体可以是一次获取所有数据，也可以是一次获取一行。</li>
<li>整个结果集是元组列表，就是list类型的，而每一条记录是一个tuple，也就是元祖。</li>
</ul>
</li>
<li>如果是增、改数据，必须就要调用commit()函数来提交事务，否则程序已退出，数据库里的数据不会有变化。</li>
<li>调用<code>close</code>方法关闭游标<code>cursor</code>和数据库连接</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(server=<span class="string">'anly3.dm.ytx.com'</span> ,database=<span class="string">'ADHOC_FDGJ'</span>, as_dict=<span class="keyword">True</span>)</div><div class="line">cur = conn.cursor()</div><div class="line">cur.execute(<span class="string">"select ..."</span>)  </div><div class="line"></div><div class="line"><span class="comment"># 先将SQL语句赋值为变量a</span></div><div class="line">a = <span class="string">"select ..."</span></div><div class="line">cur.execute(a)</div><div class="line"></div><div class="line">b= cur.fetchall()</div><div class="line"></div><div class="line">conn.close()</div><div class="line"></div><div class="line">df_b = pd.DataFrame(b)  <span class="comment"># 转化为数据框格式</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="Connection-Objects"><a href="#Connection-Objects" class="headerlink" title="Connection Objects"></a>Connection Objects</h4><table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>connect</td>
<td>创建连接对象</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#cursor" target="_blank" rel="external">cursor</a></td>
<td>返回一个Cursor对象</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#commit" target="_blank" rel="external">commit</a></td>
<td>提交事务</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#rollback" target="_blank" rel="external">rollback</a></td>
<td>回滚</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#Connection.close" target="_blank" rel="external">close</a></td>
<td>关闭连接</td>
</tr>
</tbody>
</table>
<p><br></p>
<ul>
<li><strong>connect(host, user, password, database, as_dict=True)</strong> ：创建连接对象</li>
</ul>
<blockquote>
<p>host :主机名</p>
<p>user：用户名</p>
<p>password：密码</p>
<p>database：数据库</p>
<p>charset：数据库的字符集；不指定此参数值时，程序使用默认值’UTF-8’</p>
<p>as_dict：布尔值,指定返回值是字典还是元组</p>
<p>timeout：查询超时<br>login_timeout：登陆超时<br>max_conn：最大连接数<br>trusted：布尔值,指定是否使用windows身份认证登陆</p>
</blockquote>
<ul>
<li><strong>cursor(as_dict=True)</strong>：创建游标。  <strong>一个连接一次只能有一个游标的查询处于活跃状态</strong><ul>
<li>创建多个连接来保证多个查询可以并行执行在不同连接的游标上</li>
<li>使用<code>fetchall</code>方法获取到游标查询结果之后再执行下一个查询</li>
</ul>
</li>
</ul>
<blockquote>
<p>as_dict : 使游标返回字典变量。字典中的键为数据表的列名</p>
<ul>
<li>pd.DataFrame( cursor.fetchall())  : 可将数据有 列表list 转为 数据框DataFrame</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ------------一个连接一次只能有一个游标的查询处于活跃状态</span></div><div class="line">c1 = conn.cursor()</div><div class="line">c1.execute(<span class="string">'SELECT * FROM persons'</span>)</div><div class="line"></div><div class="line">c2 = conn.cursor()</div><div class="line">c2.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line"></div><div class="line">print( <span class="string">"all persons"</span> )</div><div class="line">print( c1.fetchall() )  <span class="comment"># 显示出的是c2游标查询出来的结果</span></div><div class="line"></div><div class="line">print( <span class="string">"John Doe"</span> )</div><div class="line">print( c2.fetchall() )  <span class="comment"># 不会有任何结果</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------解决办法：使用fetchall方法获取到游标查询结果之后再执行下一个查询--------------</span></div><div class="line">c1.execute(<span class="string">'SELECT ...'</span>)</div><div class="line">c1_list = c1.fetchall()</div><div class="line"></div><div class="line">c2.execute(<span class="string">'SELECT ...'</span>)</div><div class="line">c2_list = c2.fetchall()</div></pre></td></tr></table></figure>
<p><br></p>
<p>####Cursor Objects</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#id15" target="_blank" rel="external">execute</a></td>
<td>执行一条SQL语句</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#executemany" target="_blank" rel="external">executemany</a></td>
<td>执行多条语句</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchone" target="_blank" rel="external">fetchone</a></td>
<td>获取一行数据</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchmany" target="_blank" rel="external">fetchmany</a></td>
<td>获取n行的数据</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#fetchall" target="_blank" rel="external">fetchall</a></td>
<td>获取未返回（剩下的）数据</td>
</tr>
<tr>
<td>callproc</td>
<td>调用存储过程</td>
</tr>
<tr>
<td><a href="https://link.jianshu.com/?t=https://www.python.org/dev/peps/pep-0249/#Cursor.close" target="_blank" rel="external">close</a></td>
<td>关闭游标</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>注意：fetchone / fetchmany / fetchall 与 read 是同样的运行方式；一旦倒出来一条数据，就少一条数据；</strong></p>
<p>例如：cursor.fetchone()  ，则已经少了一行数据；</p>
</blockquote>
<p><br></p>
<ul>
<li><strong>execute()</strong>：执行一条SQL语句</li>
</ul>
<blockquote>
<p>例子中查询操作的参数使用的<code>%s</code>而不是<code>&#39;%s&#39;</code>，<strong>若参数值是字符串</strong>，在执行语句时会自动添加单引号</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)   <span class="comment"># 字符串没有使用引号</span></div><div class="line">row = cursor.fetchone()</div><div class="line"><span class="keyword">while</span> row:</div><div class="line">    print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="number">0</span>], row[<span class="number">1</span>]))</div><div class="line">    row = cursor.fetchone()</div></pre></td></tr></table></figure>
<ul>
<li><strong>executemany()</strong>：指定多条SQL语句</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stmt=<span class="string">'insert into student (name, age) values (%s,%s)'</span></div><div class="line">data=[</div><div class="line">     (<span class="string">'Lucy'</span>,<span class="number">21</span>),</div><div class="line">     (<span class="string">'Tom'</span>,<span class="number">22</span>),</div><div class="line">     (<span class="string">'Lily'</span>,<span class="number">21</span>)]</div><div class="line">cursor.executemany(stmt,data)</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>callproc( procname [, parameters ] )</strong>：调用存储过程</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pymssql.connect(server, user, password, database) <span class="keyword">as</span> conn:</div><div class="line">    <span class="keyword">with</span> conn.cursor(as_dict=<span class="keyword">True</span>) <span class="keyword">as</span> cursor:</div><div class="line">        <span class="comment"># 创建存储过程</span></div><div class="line">        cursor.execute(<span class="string">"""</span></div><div class="line">        CREATE PROCEDURE FindPerson</div><div class="line">            @name VARCHAR(100)</div><div class="line">        AS BEGIN</div><div class="line">            SELECT * FROM persons WHERE name = @name</div><div class="line">        END</div><div class="line">        """)</div><div class="line"></div><div class="line">        <span class="comment"># 调用存储过程</span></div><div class="line">        cursor.callproc(<span class="string">'FindPerson'</span>, (<span class="string">'Jane Doe'</span>,))   <span class="comment"># FindPerson 为之前创建的存储</span></div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">            print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="string">'id'</span>], row[<span class="string">'name'</span>]))</div></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>使用 <code>with</code> 函数 完成后自动关闭数据库连接</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pymssql.connect(server, user, password, <span class="string">"tempdb"</span>) <span class="keyword">as</span> conn:</div><div class="line">    <span class="keyword">with</span> conn.cursor(as_dict=<span class="keyword">True</span>) <span class="keyword">as</span> cursor:</div><div class="line">        cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> cursor:</div><div class="line">            print(<span class="string">"ID=%d, Name=%s"</span> % (row[<span class="string">'id'</span>], row[<span class="string">'name'</span>]))</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="中文乱码问题"><a href="#中文乱码问题" class="headerlink" title="中文乱码问题"></a>中文乱码问题</h3><blockquote>
<p><strong>sqlserver数据库编码为gbk</strong></p>
<p>文件头加上 #coding=utf8</p>
<p>连接的时候加入charset设置信息 \<charset='utf8'>运行正常，<strong>输出依然乱码</strong>；不指定此参数值时，程序使用默认值’UTF-8’</charset='utf8'></p>
<p>pymssql.connect(host=self.host,user=self.user,password=self.pwd,database=self.db,charset=”utf8”)</p>
</blockquote>
<ul>
<li><strong>代码中显式转码</strong><ul>
<li><strong>unicode变量.encode(‘latin1’).decode(‘gbk’)</strong></li>
<li>一般情况下对unicode编码不做encode处理，但必要时可以encode为Latin1，实现脱unicode操作，然后再以合适字符集decode为正确unicode</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">print</span> <span class="string">"\t"</span>.join([str(room_id),room_name.encode(<span class="string">'latin1'</span>).decode(<span class="string">'gbk'</span>)])</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 在执行时进行encode</span></div><div class="line">cur = conn.cursor()</div><div class="line">sql = <span class="string">"select top 10 [ID],[Name] from [User]"</span></div><div class="line">cur.execute(sql)</div><div class="line">list = cur.fetchall()</div><div class="line"><span class="keyword">for</span> row <span class="keyword">in</span> list:</div><div class="line">    print(row[<span class="string">"ID"</span>],row[<span class="string">"Name"</span>].encode(<span class="string">'latin-1'</span>).decode(<span class="string">'gbk'</span>))</div><div class="line">    </div><div class="line">    </div><div class="line"><span class="comment"># sql语句中有中文的时候进行encode </span></div><div class="line">insertSql = <span class="string">"insert into WeiBo([UserId],[WeiBoContent],[PublishDate]) values(1,'测试','2012/2/1')"</span>.encode(<span class="string">"utf8"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># --------某一列中文有乱码</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">code</span><span class="params">(a)</span>:</span></div><div class="line">  	a = a.encode(<span class="string">'latin-1'</span>).decode(<span class="string">'gbk'</span>)</div><div class="line">    <span class="keyword">return</span> a</div><div class="line"></div><div class="line">data[<span class="string">'访问次数'</span>] = data[<span class="string">'访问次数'</span>].apply(code)</div></pre></td></tr></table></figure>
<ul>
<li><strong>字符定义使用NVARCHAR</strong></li>
</ul>
<p>这种方式在存储和读取时都使用unicode编码，和python运转字节码一致，可以很好避免此类问题。当然<strong>数据库存储空间要牺牲一些</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[room_name] [nvarchar] (<span class="number">50</span>) COLLATE Chinese_PRC_CI_AS NULL</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymssql</div><div class="line">conn = pymssql.connect(server=<span class="string">'anly3.dm.ytx.com'</span> ,database=<span class="string">'ADHOC_FDGJ'</span>, as_dict=<span class="keyword">True</span>)</div><div class="line">cur = conn.cursor()</div><div class="line">cur.execute(<span class="string">"select ..."</span>)  </div><div class="line"></div><div class="line"><span class="comment"># 先将SQL语句赋值为变量a</span></div><div class="line">a = <span class="string">"select ..."</span></div><div class="line">cur.execute(a)</div><div class="line"></div><div class="line"><span class="comment"># 获取之后再赋值</span></div><div class="line">b= cur.fetchall()</div><div class="line"></div><div class="line">conn.close()</div><div class="line"></div><div class="line">df_b = pd.DataFrame(b)  <span class="comment"># 转化为数据框格式</span></div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># =-----------【代码参考】-----------------</span></div><div class="line"><span class="comment"># -*- coding:gbk -*-</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line"></div><div class="line"><span class="comment">#创建一个数据库连接，host是服务器的ip地址，如果是本机可以用"."，user是访问用户名，password是密码，database是数据库名，比ADO的连接似乎简单一些</span></div><div class="line">conn=pymssql.connect(host=<span class="string">"."</span>,user=<span class="string">"sa"</span>,password=<span class="string">"twinflag"</span>,database=<span class="string">"bbs"</span> , as_dict=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建游标对象，相当于ADO的记录集</span></div><div class="line">cou=conn.cursor()</div><div class="line"></div><div class="line"></div><div class="line">sql=<span class="string">"select id,name from user"</span></div><div class="line">cou.execute(sql)  <span class="comment">#执行命令</span></div><div class="line"><span class="comment"># -----------或者-------------</span></div><div class="line">cou.execute(<span class="string">'select id, name From user'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">#插入一条记录</span></div><div class="line">cou.execute(sql)</div><div class="line"></div><div class="line"><span class="comment">#只有执行了下面的命令，上面的操作才能生效，配合异常处理，可以实现pymssql的事务操作</span></div><div class="line">conn.commit()</div><div class="line"></div><div class="line"><span class="comment">#关闭数据库的连接</span></div><div class="line">conn.close()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># =-----------【代码参考】-----------------</span></div><div class="line"><span class="keyword">import</span> pymssql</div><div class="line"></div><div class="line"><span class="comment"># server    数据库服务器名称或IP</span></div><div class="line"><span class="comment"># user      用户名</span></div><div class="line"><span class="comment"># password  密码</span></div><div class="line"><span class="comment"># database  数据库名称</span></div><div class="line">conn = pymssql.connect(server, user, password, database)</div><div class="line"></div><div class="line">cursor = conn.cursor()</div><div class="line"></div><div class="line"><span class="comment"># 新建、插入操作</span></div><div class="line">cursor.execute(<span class="string">"""</span></div><div class="line">IF OBJECT_ID('persons', 'U') IS NOT NULL</div><div class="line">    DROP TABLE persons</div><div class="line">CREATE TABLE persons (</div><div class="line">    id INT NOT NULL,</div><div class="line">    name VARCHAR(100),</div><div class="line">    salesrep VARCHAR(100),</div><div class="line">    PRIMARY KEY(id)</div><div class="line">)</div><div class="line">""")</div><div class="line">cursor.executemany(</div><div class="line">    <span class="string">"INSERT INTO persons VALUES (%d, %s, %s)"</span>,</div><div class="line">    [(<span class="number">1</span>, <span class="string">'John Smith'</span>, <span class="string">'John Doe'</span>),</div><div class="line">     (<span class="number">2</span>, <span class="string">'Jane Doe'</span>, <span class="string">'Joe Dog'</span>),</div><div class="line">     (<span class="number">3</span>, <span class="string">'Mike T.'</span>, <span class="string">'Sarah H.'</span>)])</div><div class="line"><span class="comment"># 如果没有指定autocommit属性为True的话就需要调用commit()方法</span></div><div class="line">conn.commit()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 查询操作</span></div><div class="line">cursor.execute(<span class="string">'SELECT * FROM persons WHERE salesrep=%s'</span>, <span class="string">'John Doe'</span>)</div><div class="line">row = cursor.fetchone()</div><div class="line">print(row)</div><div class="line"></div><div class="line">    </div><div class="line"><span class="comment"># 也可以使用for循环来迭代查询结果</span></div><div class="line"><span class="comment"># for row in cursor:</span></div><div class="line"><span class="comment">#     print("ID=%d, Name=%s" % (row[0], row[1]))</span></div><div class="line"></div><div class="line"><span class="comment"># 关闭连接</span></div><div class="line">conn.close()</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="Juypter-Notebook"><a href="#Juypter-Notebook" class="headerlink" title="Juypter Notebook"></a>Juypter Notebook</h2><blockquote>
<p>知乎分享：<a href="https://www.zhihu.com/question/59392251" target="_blank" rel="external">https://www.zhihu.com/question/59392251</a>   品颜完月</p>
<p>27个技巧：<a href="http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html" target="_blank" rel="external">http://liuchengxu.org/pelican-blog/jupyter-notebook-tips.html</a></p>
</blockquote>
<p><br></p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p><strong>【命令模式】</strong></p>
<p>如果单元格的边框为绿色（即为编辑模式），请按ESC键，退回到命令模式。在命令模式下被选中的单元采用灰色边框显示。按<strong>上下方向键</strong>可以移动选择框。</p>
<ul>
<li>数字键：将单元格变为标题类型，数字越大标题越小</li>
<li><strong>m：将单元格变为markdown类型，在markdown类型的单元格内可以编写文档</strong><ul>
<li>注：将代码类型改为标题类型和markdown类型之后，按Ctrl+Enter对其进行格式化显示。</li>
</ul>
</li>
<li><strong>y：将单元格变为代码类型，在代码类型的单元格中输入Python代码</strong></li>
<li>d: 按两下d按键删除单元格</li>
<li>z: 撤销最后删除单元格操作</li>
<li>a: 在当前单元格之上创建一个新的单元格</li>
<li>b: 在当前单元格之下创建一个新的单元格</li>
<li>x: 剪切当前单元格</li>
<li>c: 复制当前单元格</li>
<li>v: 在当前单元格之下粘贴剪切板中的单元格</li>
<li><strong>shift+k: 将当前单元格上移</strong></li>
<li><strong>shift+j: 将当前单元格下移</strong></li>
</ul>
<blockquote>
<p>一旦 cell 被选中，接着你可以进行批量删除/复制/剪切/粘贴.当你需要移动一部分notebook时，这非常有用。</p>
</blockquote>
<ul>
<li><strong>shift+m:与下面的单元合并</strong></li>
<li>d, d ：连按两下d 删除所选cell</li>
</ul>
<p><br></p>
<p><strong>【编辑和运行】</strong></p>
<p>编辑模式下单元使用绿色边框显示，在命令模式时<strong>按Enter即可进入编辑模式。</strong></p>
<ul>
<li><strong>Ctrl+Enter</strong>：结束编辑，对于代码单元将运行其中的代码，<strong>对于标题单元和markdown单元将格式化显示</strong></li>
<li>Shift+Enter：运行<strong>当前选择</strong>的代码单元，并自动选择下一个单元。</li>
<li>Alt+Enter：运行当前的代码并在下面插入新的单元。</li>
<li>ctrl+/：为一行或多行添加或取消注释</li>
<li><strong>多光标操作</strong> ：按住 <code>Alt</code> 进行点击和拖拽鼠标即可（选择所要编辑的区域；若要在最后都加上逗号，应该单独选最后的一纵列，而不是连通前面的内容也一起选）</li>
</ul>
<p><br></p>
<p><strong>【在线帮助和自动完成】</strong></p>
<ul>
<li>输入代码时，按 <strong>[TAB]键</strong> 可以显示自动完成提示框。自动完成支持当前执行环境中已知的模块名、变量名、对象的属性名，以及文件和目录名。</li>
<li>对于当前环境中已知的对象，可以在其<strong>后面添加问号</strong>查看相应的说明信息和文档，<strong>添加两个问号</strong>可以查看对象对应的源程序。<strong>按Ctrl+Enter显示</strong></li>
<li>在 Help 菜单你可以找到一些常用库文档的连接，包括 NumPy, Pandas, SciPy 和 Matplotlib.同时别忘了在一个库，方法或变量前加上 ?，你可以获得它的一个快速语法说明。<ul>
<li><code>?sum()</code></li>
</ul>
</li>
</ul>
<ul>
<li>调用函数时，按 [shift+tab]组合键 可以显示函数的<strong>调用参数和说明文档</strong>，按一次组合键显示基本信息，两次显示详细信息，三次延时停留信息框，四次则将信息显示在下方的滑动窗口中。</li>
</ul>
<p><br></p>
<p><strong>【操作运算核】</strong></p>
<p>如果进入了Python的死循环，可以在<strong>命令模式下按两下 i 按键终止循环</strong>。</p>
<p>注意右上角图标<strong>从空心圈变为实心圈</strong>，如上图，表示运算核<strong>正在工作</strong>，无法执行新的代码。</p>
<p><img src="https://pic2.zhimg.com/80/v2-4a420e761f4b32320e55f152886338ce_hd.jpg" alt="img"></p>
<p><br></p>
<h3 id="markdown操作"><a href="#markdown操作" class="headerlink" title="markdown操作"></a>markdown操作</h3><ul>
<li>在命令模式下按Enter键进入编辑模式即可查看本段文字的Markdown代码。</li>
<li>在行内的数学公式使用单个$括起，单独占一行的数学公式使用$$括起</li>
<li>数学公式采用LaTeX格式编写，可以使用下面的在线编辑器编写LaTeX数学公式：<a href="http://www.codecogs.com/latex/eqneditor.php?lang=zh-cn" target="_blank" rel="external">http://www.codecogs.com/latex/eqneditor.php?lang=zh-cn</a></li>
</ul>
<p><br></p>
<p><br></p>
<p>###python 导入与运行</p>
<p><strong>【向jupyter notebook中导入python文件】</strong></p>
<ul>
<li>从本地导入python文件，可以直接使用<code>%load xxx.py</code>，比如把名字为untitled0.py的文件导入到jupyter中。<ul>
<li>注意：本地文件导入时的绝对路径和相对路径的引用方式的不同</li>
</ul>
</li>
<li>从网络中导入python代码，可以使用%load 网址</li>
</ul>
<p><br></p>
<p><strong>【jupyter中运行python文件】</strong></p>
<ul>
<li>输入：<code>%run xxx.py</code> 按Ctrl+Enter后</li>
</ul>
<p><br></p>
<h3 id="显示问题"><a href="#显示问题" class="headerlink" title="显示问题"></a>显示问题</h3><p><strong>【图片显示】</strong></p>
<ul>
<li>当在程序中使用了matplotlib绘图，不能直接显示时，需要加%matplotlib inline</li>
</ul>
<p><br></p>
<h3 id="输出设置"><a href="#输出设置" class="headerlink" title="输出设置"></a>输出设置</h3><h4 id="导出时去掉代码"><a href="#导出时去掉代码" class="headerlink" title="导出时去掉代码"></a>导出时去掉代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> IPython.core.display <span class="keyword">as</span> di</div><div class="line">di.display_html(<span class="string">'&lt;script&gt;jQuery(function() &#123;if (jQuery("body.notebook_app").length == 0) &#123; jQuery(".input_area").toggle(); jQuery(".prompt").toggle();&#125;&#125;);&lt;/script&gt;'</span>, raw=<span class="keyword">True</span>)</div></pre></td></tr></table></figure>
<h4 id="显示每行结果"><a href="#显示每行结果" class="headerlink" title="显示每行结果"></a>显示每行结果</h4><ul>
<li>可以选择修改 <code>ast_note_iteractively</code> kernal 选项来使得 Jupyter 为每一行的变量或语句执行这个操作，以便你可以立即看到多条语句一起输出。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure>
<ul>
<li>所有的Jupyter实例（Notebook和Console）都设置该选项，只需<strong>创建</strong> <code>~/.ipython/profile_default/ipython_config.py</code> 文件并写入一下内容</li>
</ul>
<blockquote>
<p><code>.ipython</code> 该文件夹一般在 user 的第一级目录下。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">c = get_config()</div><div class="line"><span class="comment"># Run all nodes interactively</span></div><div class="line">c.InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div></pre></td></tr></table></figure>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">line1 = <span class="string">"this is from line 1"</span></div><div class="line">line2 = <span class="string">"this is from line 2"</span></div><div class="line"></div><div class="line">line1</div><div class="line">line2</div><div class="line"></div><div class="line">[out]:<span class="string">'this is from line 2'</span></div><div class="line">  </div><div class="line"><span class="comment"># 修改之后</span></div><div class="line"><span class="keyword">from</span> IPython.core.interactiveshell <span class="keyword">import</span> InteractiveShell</div><div class="line">InteractiveShell.ast_node_interactivity = <span class="string">"all"</span></div><div class="line"></div><div class="line">line1</div><div class="line">line2</div><div class="line"></div><div class="line">[out]:</div><div class="line"><span class="string">'this is from line 1'</span></div><div class="line"><span class="string">'this is from line 2'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="导出为PDF"><a href="#导出为PDF" class="headerlink" title="导出为PDF"></a>导出为PDF</h4><ul>
<li>报错：Download as “PDF via LaTeX” fails - nbconvert fails, xelatex not found on PATH <ul>
<li>nbconvert failed: xelatex not found on PATH, if you have not installed xelatex you may need to do so. Find further instructions at <a href="https://nbconvert.readthedocs.io/en/latest/install.html#installing-tex" target="_blank" rel="external">https://nbconvert.readthedocs.io/en/latest/install.html#installing-tex</a>.</li>
</ul>
</li>
</ul>
<blockquote>
<p> <a href="https://github.com/jupyter/docker-stacks/issues/353" target="_blank" rel="external">https://github.com/jupyter/docker-stacks/issues/353</a></p>
<p> As said by Thomas K in the comments, you need to have Latex installed, and after add the path to the directory containing pdflatex.exe file to the PATH variable of your system.</p>
<p> I have looked for a lightweight distribution and tried installing TeXworks, but I didn’t find any pdflatex.exe file.<br> So I have tried TeX Live, which worked fine creating the pdflatex.exe file under the target installation directory. This path should be like C:...\texlive\2016\bin\win32.<br> Finally, you should just add this path to the PATH environment variable of your system (you can use the link shared by Thomas K).</p>
<p> In Jupyter, you can check your environment variables by running the following (refer to this link for details):</p>
<pre><code>import os
os.environ
</code></pre><p> so you can look for ‘PATH’: ‘C: … and check if it contains the path to pdflatex.exe file.</p>
<p> If you get some trouble when exporting your notebook to pdf due to missing files/packages (this happened to me), refer to this link to search and install them under TeX Live.</p>
</blockquote>
<p><br></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><strong>【报告文档】</strong>（删去了业务人员不想查看的代码）</p>
<ul>
<li><strong>Jupyter Dashboards</strong>   </li>
<li><a href="https://github.com/jupyter/dashboards" target="_blank" rel="external">https://github.com/jupyter/dashboards</a></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># install using pip from pypi and then activate the extension</span></div><div class="line">pip install jupyter_dashboards</div><div class="line">jupyter dashboards quick-setup --sys-prefix</div><div class="line"></div><div class="line"><span class="comment"># install using conda from conda-forge, no activation required</span></div><div class="line">conda install jupyter_dashboards -c conda-forge</div></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Anaconda安装&quot;&gt;&lt;a href=&quot;#Anaconda安装&quot; class=&quot;headerlink&quot; title=&quot;Anaconda安装&quot;&gt;&lt;/a&gt;Anaconda安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这个问题本质其实就是，windows的cmd并不能识别python这个符号（即无法识别这个符号是一个可执行程序），因为windows这里也是类似的，遇到一个字符，先会在默认path路径查询这个符号是不是一个可执行程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;右键我的电脑-&amp;gt;属性-&amp;gt;高级系统配置-&amp;gt;点击高级一栏，在这里栏点开环境变量-&amp;gt;在系统变量PATH加入python的安装路径即可，比如我的就是D:\Python27&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt;不是内部或外部命令，也不是可运行的程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;添加Python的Script  到环境变量；在Path后面追加一下内容(Path： 不要复制进去) &lt;code&gt;Path:;C:\python;C:\Python\Scripts&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_正则表达式_RE</title>
    <link href="http://yoursite.com/2018/01/24/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F_RE/"/>
    <id>http://yoursite.com/2018/01/24/软件应用_程序编程/Python/Python_专题总结/Python_正则表达式_RE/</id>
    <published>2018-01-23T16:00:00.000Z</published>
    <updated>2018-02-13T13:44:18.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Re模块"><a href="#Re模块" class="headerlink" title="Re模块"></a>Re模块</h2><blockquote>
<p>Re模块的函数主要分三个大类：匹配模式、替换、拆分</p>
</blockquote>
<p><strong>Python字符串转义符 <code>\</code> </strong> </p>
<p><strong>因此强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">s = <span class="string">r'ABC\-001'</span> <span class="comment"># Python的字符串</span></div><div class="line"><span class="comment"># 对应的正则表达式字符串不变：</span></div><div class="line"><span class="comment"># 'ABC\-001'</span></div></pre></td></tr></table></figure>
<a id="more"></a>
<p><br></p>
<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>当我们在Python中使用正则表达式时，re模块内部会干两件事情：</p>
<ol>
<li>编译正则表达式，如果正则表达式的字符串本身不合法，会报错；</li>
<li>用编译后的正则表达式去匹配字符串。</li>
</ol>
<blockquote>
<p>Python代码最终被被编译为字节码，然后才被解释器执行。在匹配模式之前，正则表达式模式必须先被编译成regex对象。由于正则表达式在执行过程中多次被用于比较，所以强烈建议先对它进行预编译。</p>
</blockquote>
<p>如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以<strong>预编译</strong>该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：</p>
<p><br></p>
<h4 id="compile-模块的函数"><a href="#compile-模块的函数" class="headerlink" title="compile - 模块的函数"></a>compile - 模块的函数</h4><ul>
<li><strong>re.compile(patter [, flags=0])</strong> 把正则表达式<strong>编译成一个正则对象（regex）</strong>;供其他函数 find()、match()、search() 等函数使用<ul>
<li>使用方式为 <strong>命名的变量.方法(查找对象的范围)</strong> ；其实因为在其他Re函数使用时，自动传递pattern</li>
<li>若对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>flags 包括：<br>re.I 忽略大小写<br>re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境<br>re.M 多行模式<br>re.S 即为’ . ’并且包括换行符在内的任意字符（’ . ’不包括换行符）<br>re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库<br>re.X 为了增加可读性，忽略空格和’ # ’后面的注释</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">a = re.compile() <span class="comment"># 创建的正则规则</span></div><div class="line">result = a.findall(ojbect)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 简单说明 】</span></div><div class="line">compiled_pattern = re.compile(pattren)</div><div class="line">resule = re.findall(compiled_pattern, string)  <span class="comment"># 这种方式更利于理解</span></div><div class="line"><span class="comment">#---------等价于--------------</span></div><div class="line">compiled_pattern = re.compile(pattren)</div><div class="line">result = compiled_patter.findall(string)  <span class="comment"># 使用方式为 命名的变量.方法(查找对象的范围) 。其实因为在其他Re函数使用时，自动传递pattern</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 解释说明 】</span></div><div class="line"><span class="comment">## p 即为编译后的 pattern。 在其他Re函数使用时，自动传递pattern</span></div><div class="line">p = re.compile( <span class="string">'(one|two|three)'</span>)  </div><div class="line">p.sub( <span class="string">'num'</span>, <span class="string">'one word two words three words'</span>)   <span class="comment"># 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num</span></div><div class="line"><span class="string">'num word num words num words'</span></div><div class="line"><span class="comment">### 正常应为 re.sub('(one|two|three)', 'num', 'one word two words three words')</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 编译:</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone = re.compile(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>)</div><div class="line"><span class="comment"># 使用：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-12345'</span>).groups()   </div><div class="line">(<span class="string">'010'</span>, <span class="string">'12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>re_telephone.match(<span class="string">'010-8086'</span>).groups()</div><div class="line">(<span class="string">'010'</span>, <span class="string">'8086'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<blockquote>
<p>Re模块的函数和regex对象的方法</p>
<p>强调：查找的对象是 <strong>字符串string</strong></p>
</blockquote>
<h4 id="search-amp-match-搜索-amp-匹配"><a href="#search-amp-match-搜索-amp-匹配" class="headerlink" title="search &amp; match- 搜索&amp;匹配"></a>search &amp; match- 搜索&amp;匹配</h4><blockquote>
<p>search - 搜索；  match - 匹配</p>
<p>通过.group 返回对象</p>
</blockquote>
<ul>
<li><strong>match(pattern, string, flags=0)</strong>：在字符串string的<strong>开头 开始搜索</strong>正则表达式模式pattern；若匹配成功，则返回一个匹配对象<u>（仅返回匹配的部分）</u>；否则返回None</li>
</ul>
<ul>
<li><strong>search(pattern, string, flags=0)</strong>：从字符串string中<strong>（任意位置）</strong>搜索正则表达式模式pattern <strong>第一次出现的地方</strong>； 如果匹配成功，则返回一个匹配对象；否则返回None</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># match 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">3</span>), match=<span class="string">'foo'</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'The food on the table'</span>) <span class="comment"># 什么都没有返回</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># search 应用</span></div><div class="line">re.search(<span class="string">'foo'</span>, <span class="string">'The food on the table'</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">4</span>, <span class="number">7</span>), match=<span class="string">'foo'</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">val = <span class="string">'abc, dca, guides'</span></div><div class="line"></div><div class="line">m = re.search(<span class="string">'uid'</span>, val)</div><div class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(9, 12), match='uid'&gt;</span></div><div class="line">val[m.start():m.end()]</div><div class="line"><span class="comment"># 'uid'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="findall-amp-finditer-查找"><a href="#findall-amp-finditer-查找" class="headerlink" title="findall &amp; finditer - 查找"></a>findall &amp; finditer - 查找</h4><blockquote>
<p>search 与 findall 不同之处在于：findall 总返回一个<strong>[ 列表 ] </strong></p>
</blockquote>
<ul>
<li><strong>findall(pattern, string [,flags])</strong> ：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，并返回一个匹配对象的 <strong>[列表 list]</strong></li>
</ul>
<blockquote>
<p>正则表达式</p>
</blockquote>
<ul>
<li><strong>finditer(pattern, string [, flags])</strong>：在字符串string中搜索匹配pattern的<strong>所有内容</strong>，返回一个<strong>迭代器</strong>，该迭代器返回一个匹配对象</li>
</ul>
<p><br></p>
<h4 id="sub-替换"><a href="#sub-替换" class="headerlink" title="sub - 替换"></a>sub - 替换</h4><ul>
<li><strong>re.sub(pattern, repl ,string, max = 0)</strong> : 把字符串string中所有匹配正则表达式pattern的地方 <strong>替换</strong>成 字符串 repl <ul>
<li>如果没有找到匹配 pattern 的串，则返回未被修改的 string。Repl 既可以是字符串也可以是一个函数。</li>
</ul>
</li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行替换</p>
</blockquote>
<ul>
<li>re.subn - 该函数的功能和 sub() 相同，但它还返回新的字符串以及替换的次数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">re.sub(pattern, repl, string[, count, flags])</div><div class="line"></div><div class="line"><span class="comment"># count=1 表示替换仅替换第一个</span></div><div class="line">p = re.compile( <span class="string">'(one|two|three)'</span>) </div><div class="line">p.sub( <span class="string">'num'</span>, <span class="string">'one word two words three words'</span>)   <span class="comment"># 其第一个参数为p，即将one|two|three作为查找的对象，替换为rep = num</span></div><div class="line"><span class="string">'num word num words num words'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------------------------------</span></div><div class="line">subn(repl, string[, count=<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="split-分割"><a href="#split-分割" class="headerlink" title="split - 分割"></a>split - 分割</h4><ul>
<li><strong>re.split(pattren, string, max=0)</strong> ： 根据正则表达式pattern中的分隔符 把字符串string <strong>分割为一个 [列表]</strong></li>
</ul>
<blockquote>
<p>若max 的值没有给出，则对所有匹配的地方进行分割</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">re.split(pattern, string[, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>])</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="group-匹配对象"><a href="#group-匹配对象" class="headerlink" title="group - 匹配对象"></a>group - 匹配对象</h4><blockquote>
<p><strong>匹配对象的方法：在match &amp; search 被成功调用之后所返回的结果。</strong></p>
</blockquote>
<ul>
<li><strong>group(num=0)</strong>：<strong>返回全部匹配对象</strong>（或指定编号是num的子组）</li>
<li><strong>groups()</strong>：返回一个包含<strong>唯一或全部</strong>匹配的子组的<strong>元组</strong>（若正则表达式中没有子组，则返回一个空元组）</li>
</ul>
<blockquote>
<p>num 代表第1、2、……个子串。如果正则表达式中定义了组，就可以在<code>Match</code>对象上用<code>group()</code>方法提取出子串来。</p>
<p>用<code>()</code>表示的就是要提取的分组(Group)，进行<strong>提取子串</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  group 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>).group()</div><div class="line"><span class="string">'foo'</span></div><div class="line"></div><div class="line"><span class="comment"># groups 应用</span></div><div class="line">re.match(<span class="string">'foo'</span>, <span class="string">'food on the table'</span>).groups()</div><div class="line">()</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 用()定义组</span></div><div class="line">^(\d&#123;<span class="number">3</span>&#125;)-(\d&#123;<span class="number">3</span>,<span class="number">8</span>&#125;)$  <span class="comment"># 分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</span></div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m = re.match(<span class="string">r'^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$'</span>, <span class="string">'010-12345'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">9</span>), match=<span class="string">'010-12345'</span>&gt;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">0</span>)  <span class="comment"># group(0) 永远是原始字符串</span></div><div class="line"><span class="string">'010-12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">1</span>)</div><div class="line"><span class="string">'010'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group(<span class="number">2</span>)</div><div class="line"><span class="string">'12345'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>m.group()  <span class="comment"># 返回所有的值</span></div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h3><ol>
<li>正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。<ul>
<li>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'102300'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<ol>
<li>必须让<code>\d+</code>采用<strong>非贪婪匹配（也就是尽可能少匹配）</strong>，才能把后面的<code>0</code>匹配出来，<strong>加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</strong></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">r'^(\d+?)(0*)$'</span>, <span class="string">'102300'</span>).groups()</div><div class="line">(<span class="string">'1023'</span>, <span class="string">'00'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h2 id="参考资料-：-正则表达式"><a href="#参考资料-：-正则表达式" class="headerlink" title="参考资料 ： 正则表达式"></a>参考资料 ： 正则表达式</h2><blockquote>
<p>元字符</p>
</blockquote>
<h3 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h3><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>.</strong></td>
<td>点号</td>
<td>匹配单个(除换行符以外)<strong>任意字符</strong> <strong>（含空格、下划线等）</strong></td>
</tr>
<tr>
<td><strong>\s </strong></td>
<td>空白/空格- space</td>
<td>匹配任意的<strong>空白符</strong></td>
</tr>
<tr>
<td>\S</td>
<td>非空白字符</td>
<td>匹配<strong>任何非空白字符，相当于[^ fv]</strong></td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td>数字 - digit</td>
<td>匹配<strong>数字 ，相当于[0-9]</strong></td>
</tr>
<tr>
<td>\D</td>
<td>非数字</td>
<td>匹配任何<strong>非数字字符</strong>，相当于[^0-9]</td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td>任何字符 - whatever</td>
<td><strong>匹配任何字母数字字符，相当于[a-zA-Z0-9_]</strong></td>
</tr>
<tr>
<td>\W</td>
<td>非任何字符</td>
<td>匹配<strong>任何非字母数字字符</strong>，相当于[^a-zA-Z0-9_]</td>
</tr>
<tr>
<td><strong>[ ]</strong></td>
<td>字符组</td>
<td>匹配<strong>单个</strong>列出的字符，表示或的关系</td>
</tr>
<tr>
<td><strong>[^ ]</strong></td>
<td>排除性字符组</td>
<td>匹配<strong>单个</strong>未列出的字符</td>
</tr>
<tr>
<td>\char</td>
<td>转义字符</td>
</tr>
</tbody>
</table>
<blockquote>
<p>对于 ? 和 * 的对象在”匹配成功”时也可能并没有匹配任何内容。因为它们允许匹配的数量为0</p>
<p>即便是排除性字符，也需要匹配一个字符</p>
<p>转义符 <code>\\*</code>第一个转义符是对\进行转义，表示：查找 <code>\*</code>此类字符的内容</p>
<p>空格 也是一个字符</p>
<p>由于Python的字符串本身也用<code>\</code>转义，因此强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p>
</blockquote>
<h4 id="字符组"><a href="#字符组" class="headerlink" title="字符组 [ ]"></a>字符组 [ ]</h4><ol>
<li><p>字符组内匹配的是<strong>列出的单个字符</strong>，<strong>或者</strong>的关系</p>
</li>
<li><p><strong>字符组元字符</strong> ：字符组内的元字符，<strong>其含义表示为本身的含义，即代表普通文本字符，相当于转义之后的字符（连字符 - 除外）</strong></p>
<ul>
<li><strong>连字符 ( - )</strong>表示一个<strong>范围</strong>；<strong>【注意：只有在字符组内部，连字符( - )才是元字符】</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">0</span><span class="number">-9</span>]  <span class="comment"># 表示匹配的字符为0~9之间的任意一个</span></div></pre></td></tr></table></figure>
<ul>
<li>连字符 ( - ) 出现在<strong>字符组的开头</strong>，则仅代表<strong>普通文本字符</strong>； </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">-09</span>]  <span class="comment"># 表示匹配的字符为 - 或者 0 或者 9</span></div></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h3 id="量词-计数功能"><a href="#量词-计数功能" class="headerlink" title="量词 - 计数功能"></a>量词 - 计数功能</h3><p>对前一个/一组字符匹配的的次数</p>
<table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>？</strong>  = 0 或 1</td>
<td><strong>问号</strong></td>
<td>不匹配，或仅匹配一次</td>
</tr>
<tr>
<td><strong>*</strong>     $\ge$ 0</td>
<td>星号</td>
<td>可能不匹配，也可能匹配任意多次</td>
</tr>
<tr>
<td><strong>+</strong>     $\ge$ 1</td>
<td>加号</td>
<td>至少匹配一次，也可能匹配任意多次</td>
</tr>
<tr>
<td>{m}</td>
<td></td>
<td>对于前一个字符重复m次</td>
</tr>
<tr>
<td><strong>{min, max}</strong></td>
<td>区间量词</td>
<td>对前一个字符重复min到max次</td>
</tr>
</tbody>
</table>
<h3 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>^</strong></td>
<td>脱字符</td>
<td>一行的开头位置</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>美元符</td>
<td>一行的结束位置</td>
</tr>
<tr>
<td>\b</td>
<td><strong>单词分界符</strong></td>
<td>匹配<strong>单词的开始或结束</strong> (用于精确匹配)</td>
</tr>
<tr>
<td>\D</td>
<td>非单词分界符</td>
<td>匹配<strong>不是单词开头或结束的位置</strong></td>
</tr>
</tbody>
</table>
<h3 id="其他元字符"><a href="#其他元字符" class="headerlink" title="其他元字符"></a>其他元字符</h3><table>
<thead>
<tr>
<th><strong>符号</strong></th>
<th><strong>含义</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>( )</td>
<td>括号</td>
<td>限定多线结构的范围； 为反向引用“捕获”文本</td>
</tr>
<tr>
<td>\1 , \2</td>
<td>反向引用</td>
<td>匹配之前的第一个、第二个括号内的字表达式<strong>所匹配的文本</strong>(即捕获的文本)</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>或者</td>
<td>匹配任意分隔的表达式</td>
</tr>
</tbody>
</table>
<blockquote>
<p>括号与反向引用的示例</p>
<ul>
<li><strong>分组0对应整个正则表达式</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; \b(a-zA-Z)*+\<span class="number">1</span>\b</div><div class="line">&gt; <span class="comment"># 若 \b(a-zA-Z)*+ 任意字符找到的以单词开头的内容为the，则\1 表示其末尾也应为the的内容 </span></div><div class="line">&gt; <span class="comment"># 若有两个括号，\2表示第二个括号中所匹配的文本内容</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h4 id="多选结构"><a href="#多选结构" class="headerlink" title="多选结构"></a>多选结构</h4><ol>
<li><p>使用圆括号( ) 来进行表示，而非方括号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 查找 gray 或 grey的写法</span></div><div class="line"></div><div class="line"><span class="number">1.</span> gr[ae]y</div><div class="line"><span class="number">2.</span> gr(a|e)y</div><div class="line"></div><div class="line"><span class="comment"># 错误的写法 gr[a|e]y  -表示查找 a 或者 | 或者 e</span></div></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>多选结构可以匹配<strong>任意长度</strong>的字符，而字符组[ ]只能匹配<strong>单个</strong>字符</p>
</blockquote>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><p>你在一篇英文小说里查找hi，你可以使用正则表达式hi</p>
<p>通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，它可以匹配hi,HI,Hi,hI这四种情况中的任意一种。</p>
<p>很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用\bhi\b</p>
<p><code>\bhi\b.*\bLucy\b</code>的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词</p>
<p><br></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line">f = open(<span class="string">'caihf001'</span>)</div><div class="line">text = f.read()</div><div class="line">f.close()</div><div class="line">k = re.compile(<span class="string">'Lemon'</span>, re.I)</div><div class="line">k.findall(text)</div><div class="line"></div><div class="line"><span class="comment"># ----效果同上</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'caihf001'</span>) <span class="keyword">as</span> f:</div><div class="line">    text = f.read()</div><div class="line"><span class="comment">#     print(text)</span></div><div class="line">    k = re.compile(<span class="string">'lemon'</span>,re.I)</div><div class="line">    l = re.findall(k,text)</div><div class="line">print(l)</div><div class="line"></div><div class="line"></div><div class="line">[<span class="string">'Lemon'</span>, <span class="string">'lemon'</span>, <span class="string">'Lemon'</span>, <span class="string">'Lemon'</span>, <span class="string">'LeMoN'</span>, <span class="string">'LEmon'</span>, <span class="string">'LEMON'</span>]</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Re模块&quot;&gt;&lt;a href=&quot;#Re模块&quot; class=&quot;headerlink&quot; title=&quot;Re模块&quot;&gt;&lt;/a&gt;Re模块&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Re模块的函数主要分三个大类：匹配模式、替换、拆分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Python字符串转义符 &lt;code&gt;\&lt;/code&gt; &lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此强烈建议使用Python的&lt;code&gt;r&lt;/code&gt;前缀，就不用考虑转义的问题了：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; re&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;s = &lt;span class=&quot;string&quot;&gt;r&#39;ABC\-001&#39;&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Python的字符串&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 对应的正则表达式字符串不变：&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# &#39;ABC\-001&#39;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python_文件与目录操作_OS</title>
    <link href="http://yoursite.com/2018/01/23/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/Python_%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93/Python_%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6&amp;%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA_OS&amp;Pandas/"/>
    <id>http://yoursite.com/2018/01/23/软件应用_程序编程/Python/Python_专题总结/Python_目录与文件&amp;导入导出_OS&amp;Pandas/</id>
    <published>2018-01-22T16:00:00.000Z</published>
    <updated>2018-02-13T13:11:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>Python_导入导出</p>
<a id="more"></a>
<h1 id="目录与文件操作-OS模块"><a href="#目录与文件操作-OS模块" class="headerlink" title="目录与文件操作 - OS模块"></a>目录与文件操作 - OS模块</h1><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><blockquote>
<p>“./” 表示当前目录</p>
<p>“../“ 表示上一目录</p>
<p>Windows 中路径需要两个<code>\\</code>  如下为示例：</p>
<p><code>E:\\my_computer\\1_工作学习</code></p>
</blockquote>
<p><br></p>
<h4 id="getcwd-amp-os-chdir-工作目录"><a href="#getcwd-amp-os-chdir-工作目录" class="headerlink" title="getcwd &amp; os.chdir - 工作目录"></a>getcwd &amp; os.chdir - 工作目录</h4><ul>
<li><strong>os.getcwd()</strong> 函数得到当前工作目录，即当前Python脚本工作的目录路径。</li>
<li><strong>os.chdir(dirname)</strong>: 改变工作目录到dirname</li>
</ul>
<p><br></p>
<h4 id="listdir-文件与目录名"><a href="#listdir-文件与目录名" class="headerlink" title="listdir - 文件与目录名"></a>listdir - 文件与目录名</h4><ul>
<li><strong>os.listdir()</strong> 返回指定目录下的所有文件和目录名</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 返回当前目录下的文件名</span></div><div class="line">os.listdir()   </div><div class="line">os.listdir(<span class="string">'./'</span>)    </div><div class="line"></div><div class="line"><span class="comment"># 返回上一目录下的文件名</span></div><div class="line">os.listdir(<span class="string">'../'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<blockquote>
<p>目录结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment"># 参考</span></div><div class="line">&gt; <span class="comment">## 工作目录为 /Users/ethan/coding/python</span></div><div class="line">&gt;</div><div class="line">&gt; Users/ethan</div><div class="line">&gt; └── coding</div><div class="line">&gt;     └── python</div><div class="line">&gt;         ├── hello.py    - 文件</div><div class="line">&gt;         └── web         - 目录</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p><br></p>
<h4 id="path-abspath-绝对路径"><a href="#path-abspath-绝对路径" class="headerlink" title="path.abspath -  绝对路径"></a>path.abspath -  绝对路径</h4><ul>
<li><strong>os.path.abspath(file)</strong> ：获取<strong>文件或目录</strong>的<strong>绝对路径</strong></li>
<li><strong>os.path.abspath(‘.’)</strong> ：获取<strong>当前目录</strong>的绝对路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 文件的绝对绝对路径</span></div><div class="line">os.path.abspath(<span class="string">'hello.py'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python/hello.py'</span></div><div class="line"></div><div class="line"><span class="comment"># 文件夹的绝对路径</span></div><div class="line">os.path.abspath(<span class="string">'web'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python/web'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-dirname-文件路径"><a href="#path-dirname-文件路径" class="headerlink" title="path.dirname - 文件路径"></a>path.dirname - 文件路径</h4><ul>
<li><strong>os.path.dirname(path)</strong>：获取<strong>文件或文件夹</strong>的<strong>所在的路径</strong></li>
</ul>
<blockquote>
<p>对比<code>os.path.abspath</code>  hellp.py 得到的结果不同；</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取文件所在的路径</span></div><div class="line">os.path.dirname(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding/python'</span></div><div class="line"></div><div class="line"><span class="comment"># 获取文件夹的路径</span></div><div class="line">os.path.dirname(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line"><span class="string">'/Users/ethan/coding'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-basename-文件名称"><a href="#path-basename-文件名称" class="headerlink" title="path.basename - 文件名称"></a>path.basename - 文件名称</h4><ul>
<li><strong>os.path.basename(path)</strong>：获取<strong>文件名或文件夹名</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 从一个 绝对路径 中获取该 [文件] 的名称</span></div><div class="line">os.path.basename(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line"><span class="string">'hello.py'</span></div><div class="line"></div><div class="line"><span class="comment"># 从一个 绝对路径 中获取该 [文件夹] 的名称</span></div><div class="line">os.path.basename(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line"><span class="string">'python'</span></div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-split-目录与文件名"><a href="#path-split-目录与文件名" class="headerlink" title="path.split - 目录与文件名"></a>path.split - 目录与文件名</h4><ul>
<li><strong>os.path.split(path)</strong>：获取分离后的<strong>目录与文件名</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取分离后的目录与文件名</span></div><div class="line">os.path.split(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python'</span>, <span class="string">'hello.py'</span>)</div><div class="line"></div><div class="line"><span class="comment"># 获取分离后的目录与文件夹名</span></div><div class="line">os.path.split(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding'</span>, <span class="string">'python'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-splitext-分离"><a href="#path-splitext-分离" class="headerlink" title="path.splitext - 分离"></a>path.splitext - 分离</h4><ul>
<li><strong>os.path.splitext(path)</strong>：分离<strong>文件名与扩展名</strong></li>
</ul>
<blockquote>
<p>事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取分离后的文件名与扩展名</span></div><div class="line">os.path.splitext(<span class="string">'/Users/ethan/coding/python/hello.py'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python/hello'</span>, <span class="string">'.py'</span>)</div><div class="line"></div><div class="line">os.path.splitext(<span class="string">'/Users/ethan/coding/python'</span>)</div><div class="line">(<span class="string">'/Users/ethan/coding/python'</span>, <span class="string">''</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-join-连接"><a href="#path-join-连接" class="headerlink" title="path.join - 连接"></a>path.join - 连接</h4><ul>
<li><strong>os.path.join(path, name)</strong> ：连接<strong>目录与文件名</strong>或目录</li>
</ul>
<p><br></p>
<p>####walk - 遍历</p>
<ul>
<li><strong>os.walk()</strong>  遍历目录常用的模块，它返回一个包含 3 个元素的元祖：(dirpath, dirnames, filenames)。</li>
</ul>
<blockquote>
<p>dirpath 是以 string 字符串形式返回该目录下所有的<strong>绝对路径</strong>；</p>
<p>dirnames 是以列表 list 形式返回每一个绝对路径下的<strong>文件夹名字</strong>；</p>
<p>filesnames 是以列表 list 形式返回该路径下所有<strong>文件名字</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(<span class="string">'/Users/ethan/coding'</span>):</div><div class="line">	<span class="keyword">print</span> root</div><div class="line">	<span class="keyword">print</span> dirs</div><div class="line">	<span class="keyword">print</span> files</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="path-sidir-判断目录"><a href="#path-sidir-判断目录" class="headerlink" title="path.sidir - 判断目录"></a>path.sidir - 判断目录</h4><ul>
<li><strong>os.path.isdir(name)</strong>： 判断name是不是目录，不是目录就返回false</li>
</ul>
<p><br></p>
<h4 id="path-exists-判断存在"><a href="#path-exists-判断存在" class="headerlink" title="path.exists - 判断存在"></a>path.exists - 判断存在</h4><ul>
<li><strong>os.path.exists(name)</strong> :判断是否存在文件或目录name</li>
</ul>
<p><br></p>
<h4 id="path-isfile-判断存在"><a href="#path-isfile-判断存在" class="headerlink" title="path.isfile - 判断存在"></a>path.isfile - 判断存在</h4><ul>
<li><strong>os.path.isfile(name)</strong> :判断name这个文件是否存在，不存在返回false</li>
</ul>
<p><br></p>
<h4 id="mkdir-创建"><a href="#mkdir-创建" class="headerlink" title="mkdir - 创建"></a>mkdir - 创建</h4><ul>
<li><strong>os.mkdir(‘file’)</strong> ：创建目录</li>
</ul>
<p><br></p>
<h4 id="rename-重命名"><a href="#rename-重命名" class="headerlink" title="rename - 重命名"></a>rename - 重命名</h4><ul>
<li><strong>os.rename(“oldname”,”newname”)</strong> ：重命名文件（目录）</li>
</ul>
<p><br></p>
<p><br></p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p><br></p>
<h4 id="moknod-创建"><a href="#moknod-创建" class="headerlink" title="moknod - 创建"></a>moknod - 创建</h4><ul>
<li><strong>os.moknod(‘text.txt’)</strong> : 创建空文件</li>
</ul>
<p><br></p>
<h4 id="remove-移除"><a href="#remove-移除" class="headerlink" title="remove - 移除"></a>remove - 移除</h4><ul>
<li><strong>os.remove()</strong>：函数用来删除一个文件</li>
</ul>
<p><br></p>
<h4 id="open-打开"><a href="#open-打开" class="headerlink" title="open - 打开"></a>open - 打开</h4><blockquote>
<p>要以任何方式打开文件（即使是打印文档），都必须<strong>先打开文件</strong>，这样才能访问它。</p>
<p>读取文本文件时，Python将其中的所有文本都解读为<strong>字符串。如果你读取的是数字，需要转为int/float</strong></p>
</blockquote>
<ul>
<li><strong>open(file, [w])</strong> ：以某种方式打开文件</li>
<li><strong>with open(file, [w])</strong> ： with 关键字<strong>不再需要访问文件后将其关闭的操作；会自动关闭</strong></li>
</ul>
<blockquote>
<p>r - 只读模式</p>
<p>w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件</p>
<p>a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾</p>
<p>r+ - 读写模式</p>
<p>w+ 以读写模式打开<br>a+ 以读写模式打开<br>rb 以二进制读模式打开<br>wb 以二进制写模式打开 (参见 w )<br>ab 以二进制追加模式打开 (参见 a )<br>rb+ 以二进制读写模式打开 (参见 r+ )<br>wb+ 以二进制读写模式打开 (参见 w+ )<br>ab+ 以二进制读写模式打开 (参见 a+ )</p>
</blockquote>
<p><br></p>
<h4 id="read-读取"><a href="#read-读取" class="headerlink" title="read - 读取"></a>read - 读取</h4><blockquote>
<p>要以任何方式打开文件（即使是打印文档），都必须<strong>先打开文件</strong>，这样才能访问它。</p>
<p>读取文本文件时，Python将其中的所有文本都解读为<strong>字符串。如果你读取的是数字，需要转为int/float</strong></p>
<ul>
<li>所谓字符串，是指可以在内部查找的文档格式。</li>
</ul>
</blockquote>
<ul>
<li><strong>tb0.realine()</strong>： 读取第一行的数据，以 <strong>( 字符串str )</strong> 形式返回文件数据 ； 此时<strong>源数据 tb0已经缺少了第一行的数据</strong></li>
<li><strong>tb0.readlines()</strong>：按行读取所有的数据，以<strong>[ 列表list ]</strong>，准确的说<strong>包含字符串str的列表list</strong>，并且也包含<strong>换行符(\n)，制表符(\t)</strong> 形式返回文件数据</li>
<li><strong>tb0.read() </strong>：一次性读取所有数据，类型为 <strong>( 字符串str )</strong><ul>
<li>末尾多一行空行</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'filename.csv'</span>) <span class="keyword">as</span> tb01:  <span class="comment"># with 关键字不再需要访问文件后将其关闭的操作；会自动关闭</span></div><div class="line">    a = tb01.readline() <span class="comment"># 此时源数据tb01已经缺少了第一行的数据</span></div><div class="line">    b = tb01.readlinse() </div><div class="line">    c = tb01.read() <span class="comment"># 此时已经为空</span></div><div class="line"></div><div class="line"><span class="comment"># ----【 重要概念 】--------------------------------------    </span></div><div class="line">b[<span class="number">0</span>]  <span class="comment"># 获得列表中的第一个字符串 '003888800000798,160999900163133\n'</span></div><div class="line">b[<span class="number">0</span>][<span class="number">0</span>] <span class="comment"># 获得列表中第一个字符串的第一个字符 '0'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ----【 读取与替换】--------------------------------</span></div><div class="line"><span class="comment">## 创建里面为列表的列表</span></div><div class="line">l = []   <span class="comment"># 创建空列表</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:  <span class="comment"># b为列表，对每个对象进行逐一操作</span></div><div class="line">    m = re.sub(<span class="string">r'\n'</span>,<span class="string">''</span>,i)   <span class="comment"># 完成一系列对字符串的操作，结果仍为字符串string</span></div><div class="line"><span class="comment">#   p = re.split(',',m)  若需要，可对字符串进行分割，结果为列表list</span></div><div class="line">    l.append(m)</div><div class="line">l</div><div class="line">[<span class="string">',,,会员简称,成交量,比上一交易日增减,会员简称,持买单量,比上一交易日增减,会员简称,持卖单量,比上一交易日增减'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,1,海通期货    ,1581,31,上海东证    ,1287,-17,中信期货    ,2137,-95'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,2,中信期货    ,1437,-13,华泰期货    ,1124,-70,广发期货    ,1583,-194'</span>,</div><div class="line"> <span class="string">'20160111,IC1601                        ,3,国泰君安    ,1231,-55,海通期货    ,993,-16,国泰君安    ,831,-52'</span>]</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 用循环读取的结果为字符串格式</span></div><div class="line">l = <span class="string">''</span></div><div class="line"><span class="keyword">with</span> open(filename) <span class="keyword">as</span> file_object:</div><div class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> file_object:</div><div class="line">		l = l + line</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="write-写入"><a href="#write-写入" class="headerlink" title="write - 写入"></a>write - 写入</h4><ul>
<li>write 不会在文本末尾添加换行符(\n)，若<strong>写入多行时，建议在最后添加换行符 \n.</strong><ul>
<li><code>tb1.write(&#39;I love programming.\n&#39;)</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>r - 只读模式<br>w - 只写模式。覆盖之前的同名文件（即删除里面的所有内容）。如果文件不存在就创建文件<br>a - 追加模式打开。附加到现有文件；若文件不存在则创建一个；添加到文件末尾<br>r+ - 读写模式<br>w+ 以读写模式打开</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> tb1:</div><div class="line">    tb1.write(<span class="string">'I love programming!'</span>)   <span class="comment"># 直接在该文件中最后写入</span></div><div class="line">    </div><div class="line"></div><div class="line"><span class="comment"># --------------若要写入文档，先完成数据的提取-----------------</span></div><div class="line">b = <span class="string">''</span>  <span class="comment"># 空字符串；因为文本文档均为字符串格式</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>) <span class="keyword">as</span> f:</div><div class="line">    a = f.readlines()  <span class="comment"># 此时a为列表list格式； 也可为 a = f.read()，则该处a为字符串格式</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(a)):</div><div class="line">        b = b + str(i) + a[i]</div><div class="line"><span class="keyword">with</span> open(<span class="string">'path\filename.csv'</span>) <span class="keyword">as</span> f:</div><div class="line">    f1 = f.write(b)</div></pre></td></tr></table></figure>
<p><br> </p>
<p>##【实战演练】</p>
<p><strong>【获取上一层次目录中，test文件夹内的所有文件，并选取csv格式的文档】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="comment"># 方法一</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>os.listdir(<span class="string">'../'</span>) </div><div class="line">[<span class="string">'.ipynb_checkpoints'</span>,</div><div class="line"> <span class="string">'.Rhistory'</span>,</div><div class="line"> <span class="string">'Python'</span>,</div><div class="line"> <span class="string">'R_dir'</span>,</div><div class="line"> <span class="string">'test'</span>,</div><div class="line"> <span class="string">'test.ipynb'</span>]</div><div class="line"></div><div class="line"><span class="comment">## 手动添加目录</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>file_name = os.listdir(<span class="string">'../test'</span>)</div><div class="line">[<span class="string">'2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-13-T_1.csv'</span>]</div><div class="line"></div><div class="line"><span class="comment">## 用Re模块匹配符合的文档</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>k = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</div><div class="line">    <span class="keyword">if</span> re.findall(<span class="string">r'.*\.csv$'</span>,i):</div><div class="line">        k.append(<span class="string">'../test/'</span>+i) </div><div class="line">k</div><div class="line"></div><div class="line">[<span class="string">'../test/2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'../test/2016-01-13-T_1.csv'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># -------获得绝对路径的文件名-------------------------------------------------------</span></div><div class="line">dir_name = os.path.abspath(<span class="string">'../test/'</span>)</div><div class="line">dir_name</div><div class="line">k = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> file_name:</div><div class="line">    <span class="keyword">if</span> re.findall(<span class="string">r'.*\.csv$'</span>,i):</div><div class="line">        k.append(dir_name+i) </div><div class="line">k</div><div class="line">[<span class="string">'E:\\Jupyter_notebook\\test2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\test2016-01-13-T_1.csv'</span>,</div><div class="line"> <span class="string">'E:\\Jupyter_notebook\\testtest - 副本.csv'</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># ------------------------------------------------------</span></div><div class="line"><span class="comment"># 方法二</span></div><div class="line">dir_name1 = os.path.abspath(<span class="string">'../'</span>)</div><div class="line"><span class="string">'E:\\Jupyter_notebook'</span></div><div class="line"></div><div class="line">os.listdir(<span class="string">'../'</span>)  <span class="comment"># 结果同上</span></div><div class="line">test_dir  = os.path.join(dir_name1, <span class="string">'test'</span>)</div><div class="line">os.listdir(test_dir)</div><div class="line">[<span class="string">'2016-01-11-IC_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-11-IH_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-12-TF_1.csv'</span>,</div><div class="line"> <span class="string">'2016-01-13-T_1.csv'</span>]</div></pre></td></tr></table></figure>
<p><br></p>
<p><strong>【获取其他目录下的文件】</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 获取当前工作目录</span></div><div class="line">os.getcwd()</div><div class="line"></div><div class="line"><span class="comment"># 变更工作目录</span></div><div class="line">os.chdir(<span class="string">'E:\Others'</span>)</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h1 id="导入与导出-pandas"><a href="#导入与导出-pandas" class="headerlink" title="导入与导出 - pandas"></a>导入与导出 - pandas</h1><h2 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h2><blockquote>
<p>pandas默认将表格型数据读取为<strong>数据框格式（DataFrame）</strong></p>
<p>“./” 表示当前目录</p>
<p>“../“ 表示上一目录</p>
<p>import pandas as pd<br>import numpy as np</p>
<p>df：任意的Pandas DataFrame对象<br>s：任意的Pandas Series对象</p>
</blockquote>
<ul>
<li><strong>pd.read_csv(“./filename.txt”, sep=’,’, header=0, names=[‘a’,’b’], skiprows=0, index_col=’a’, na_values=’NULL’, nrows=1000, encoding=’gb2312’, thousands= ‘,’)</strong> ：从CSV文件导入数据</li>
</ul>
<blockquote>
<p>sep =’\s+’ 正则表达式的空白字符串 </p>
<p>header=0，表示默认第一行为列名； header=None 没有列名行</p>
<p>names=[‘a’, ‘b’] 用于指定列名，与header=None结合使用</p>
<p>skiprows=0, skiprows=[0,2,3] 表示跳过的观测行； </p>
<p>skip_footer=0，表示忽略的行数（从文件末尾算起）</p>
<p>index_col =[‘a’,’b’] 表示指定为索引列</p>
<p>na_valuse = [‘Null’] 一组将NA值替换为指定的字符’Null’ 或其他任意形式</p>
<p>nrows=1000 表示读取的行数，从文件开始处算起</p>
<p>thousands=’,’ / ‘.’ 千分位分隔符</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tb01 = pd.read_csv(<span class="string">"./filename.txt"</span>, sep=<span class="string">','</span>, header=<span class="number">0</span>, names=[<span class="string">'a'</span>,<span class="string">'b'</span>], skiprows=<span class="number">0</span>, index_col=<span class="string">'a'</span>, na_values=<span class="string">'NULL'</span>, nrows=<span class="number">1000</span>, encoding=<span class="string">'gb2312'</span>, thousands= <span class="string">','</span>)  <span class="comment"># 默认分隔符为逗号；  </span></div><div class="line">tb01 = pd.read_table() 　<span class="comment">#</span></div></pre></td></tr></table></figure>
<ul>
<li><strong>pd.read_exce</strong>l(filename)：从Excel文件导入数据</li>
<li><strong>pd.read_table</strong>(filename)：从限定分隔符（默认为制表符 “\t”）的文本文件导入数据； 也可读csv格式的文档，但建议将sep=’,’</li>
<li><strong>pd.read_sql</strong>(query, connection_object)：从SQL表/库导入数据</li>
<li><strong>pd.read_json</strong>(json_string)：从JSON格式的字符串导入数据</li>
<li><strong>pd.read_html</strong>(url)：解析URL、字符串或者HTML文件，抽取其中的tables表格</li>
<li><strong>pd.read_clipboard</strong>()：从你的粘贴板获取内容，并传给read_table()</li>
<li><strong>pd.DataFrame</strong>(dict)：从字典对象导入数据，Key是列名，Value是数据</li>
</ul>
<p><br></p>
<p>####数据清洗</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> open(<span class="string">'关联客户0522.csv'</span>) <span class="keyword">as</span> tb0:</div><div class="line">    tb1 = tb0.readlines()  <span class="comment"># 将tb0中的内容按行读取为列表；(此时自动生成了一个换行符\n)</span></div><div class="line">    tb3 = []</div><div class="line">    <span class="keyword">for</span> tb <span class="keyword">in</span> tb1:  <span class="comment"># 一次访问列表list中的元素（此时各元素为字符串格式，故可以对其进行操作）</span></div><div class="line">        tb2 = tb.replace(<span class="string">'"'</span>, <span class="string">''</span>).replace(<span class="string">'\n'</span>,<span class="string">''</span>).strip().split(<span class="string">','</span>)  <span class="comment"># 依次完成各个操作 替换” - 替换\n - 去空格 - 按分隔符','将元素转化为列表</span></div><div class="line">        tb3.append(tb2)  <span class="comment"># 在列表tb3中添加以将各元素转为列表的值；最终类型为列表的列表</span></div><div class="line">print(tb3)</div><div class="line">tb3[<span class="number">1</span>][<span class="number">1</span>]</div></pre></td></tr></table></figure>
<p><br></p>
<h4 id="显示所有行数"><a href="#显示所有行数" class="headerlink" title="显示所有行数"></a>显示所有行数</h4><blockquote>
<p>pandas默认会隐去中间的部分。如果希望能显示完整，可以使用下面的方法：</p>
</blockquote>
<ul>
<li>一次性设置Pandas运行环境，以便输出所有记录；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pd.set_option(<span class="string">'display.max_columns'</span>, <span class="keyword">None</span>)</div><div class="line">pd.set_option(<span class="string">'display.max_rows'</span>, <span class="keyword">None</span>)</div></pre></td></tr></table></figure>
<ul>
<li>针对特定输出，设置Pandas参数。<strong>运行之后，再恢复到默认值</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">with</span> pd.option_context(<span class="string">'display.max_rows'</span>, <span class="keyword">None</span>, <span class="string">'display.max_columns'</span>, <span class="number">3</span>):  <span class="comment"># None 为全部；或者指定具体的数值</span></div><div class="line">    <span class="keyword">print</span> (df)</div></pre></td></tr></table></figure>
<br>



<h2 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h2><blockquote>
<p><strong>缺失值 在输出结果中为 空字符串；</strong></p>
</blockquote>
<ul>
<li><strong>DataFrame.to_cvs(‘filename.csv’, sep=’,’, na_rep=’NULL’, index=False, header=False, cols=[‘a’,’b’,’c’])</strong>：导出数据到CSV文件</li>
</ul>
<ul>
<li><strong>df.to_exce</strong>l(filename)：导出数据到Excel文件<ul>
<li>DataFrame.to_excel(<em>excel_writer</em>, <em>sheet_name=’Sheet1’</em>, <em>na_rep=’’</em>, <em>float_format=None</em>, <em>columns=None</em>, <em>header=True</em>, <em>index=True</em>, <em>index_label=None</em>, <em>startrow=0</em>, <em>startcol=0</em>, <em>engine=None</em>, <em>merge_cells=True</em>, <em>encoding=None</em>, <em>inf_rep=’inf’</em>, <em>verbose=True</em>, <em>freeze_panes=None</em>)</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>excel_writer</strong> : string or ExcelWriter object. File path or existing ExcelWriter</p>
<p><strong>na_rep</strong> : string, default ‘’ . Missing data representation</p>
<p><strong>float_format</strong> : string, default None. Format string for floating point numbers</p>
<p><strong>columns</strong> : sequence, optional. Columns to write ；表示需要导出的列</p>
<p><strong>header</strong> : boolean or list of string, default True； 表示可以<strong><u>重命名列名</u></strong></p>
<p><strong>index</strong> : boolean, default True   ；是否包含索引列</p>
<p><strong>index_label</strong> : string or sequence, default None</p>
<p><strong>startrow :</strong>upper left cell row to dump data frame</p>
<p><strong>encoding: string, default None</strong></p>
</blockquote>
<ul>
<li><strong>df.to_sql</strong>(table_name, connection_object)：导出数据到SQL表</li>
<li><strong>df.to_json</strong>(filename)：以Json格式导出数据到文本文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 导出数据</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dir_name</div><div class="line"><span class="string">'E:\\my_computer\\1_工作学习\\10_工作文档\\5 银天下-数据分析\\30_专项分析\\0102_股今中外链接统计\\人员信息\\历史数据'</span></div><div class="line">lj01.to_excel(dir_name+<span class="string">'\\'</span>+<span class="string">'lj02.xls'</span>,index=<span class="keyword">False</span>)</div><div class="line">qian_all_data.to_csv(<span class="string">'qianguqg.csv'</span>, index=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 导入到同一Excel的多个sheet</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>writer = pd.ExcelWriter(<span class="string">'output.xlsx'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df1.to_excel(writer,<span class="string">'Sheet1'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>df2.to_excel(writer,<span class="string">'Sheet2'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>writer.save()</div></pre></td></tr></table></figure>
<p><br></p>
<p><br></p>
<h2 id="【实战演练】"><a href="#【实战演练】" class="headerlink" title="【实战演练】"></a>【实战演练】</h2><h4 id="将所有CSV文档读入到同一个对象"><a href="#将所有CSV文档读入到同一个对象" class="headerlink" title="将所有CSV文档读入到同一个对象"></a>将所有CSV文档读入到同一个对象</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> re</div><div class="line"></div><div class="line"><span class="comment"># 读取csv的文件，并写入到一个列表 name2</span></div><div class="line">name2 = []</div><div class="line">l = re.compile(<span class="string">'.*\.csv'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name:</div><div class="line">    <span class="keyword">if</span> re.findall(l, i):</div><div class="line">        name2.append(i)</div><div class="line">        </div><div class="line"><span class="comment"># 读入到同一个对象        </span></div><div class="line">table1 = []</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name2:</div><div class="line"><span class="comment">#    print(i)</span></div><div class="line"><span class="comment">#      need_table = pd.read_csv(i)</span></div><div class="line">    table0 = pd.read_csv(<span class="string">'../future-exchange/'</span>+i, encoding = <span class="string">'gb2312'</span>)</div><div class="line">    table1.append(table0)</div></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python_导入导出&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Python/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Hive_介绍</title>
    <link href="http://yoursite.com/2018/01/22/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Hive/Hive_%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/01/22/软件应用_程序编程/Hive/Hive_介绍/</id>
    <published>2018-01-21T16:00:00.000Z</published>
    <updated>2018-02-13T13:49:16.378Z</updated>
    
    <content type="html"><![CDATA[<p>Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。</p>
<p>术语“大数据”是大型数据集，其中包括体积庞大，高速，以及各种由与日俱增的数据的集合。使用传统的数据管理系统，它是难以加工大型数据。因此，Apache软件基金会推出了一款名为Hadoop的解决大数据管理和处理难题的框架。</p>
<p>参考链接：<a href="http://www.yiibai.com/hive/" target="_blank" rel="external">http://www.yiibai.com/hive/</a></p>
<a id="more"></a>
<p>​    </p>
<p><br></p>
<h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop是一个开源框架来存储和处理大型数据在分布式环境中。它包含两个模块，一个是MapReduce，另外一个是Hadoop分布式文件系统（HDFS） Hadoop Distributed File System</p>
<ul>
<li><strong>MapReduce：</strong>它是一种并行编程模型在大型集群普通硬件可用于处理大型结构化，半结构化和非结构化数据。</li>
</ul>
<ul>
<li><strong>HDFS：</strong>Hadoop分布式文件系统是Hadoop的框架的一部分，用于存储和处理数据集。它提供了一个容错文件系统在普通硬件上运行。</li>
</ul>
<p>Hadoop生态系统包含了用于协助Hadoop的不同的子项目（工具）模块，如Sqoop, Pig 和 Hive。</p>
<ul>
<li><strong>Sqoop: </strong>它是用来在HDFS和RDBMS之间来回<strong><u>导入和导出数据</u></strong>。</li>
<li><strong>Pig:</strong> 它是用于开发MapReduce操作的<strong><u>脚本程序语言的平台</u></strong>。</li>
<li><strong>Hive:</strong> 它是用来开发<strong><u>SQL类型脚本</u></strong>用于做<strong><u>MapReduce操作的平台</u></strong>。</li>
</ul>
<p>注：有多种方法来执行MapReduce作业：</p>
<ul>
<li>传统的方法是使用Java MapReduce程序结构化，半结构化和非结构化数据。</li>
<li>针对MapReduce的脚本的方式，使用Pig来处理结构化和半结构化数据。</li>
<li>Hive查询语言（HiveQL或HQL）采用Hive为MapReduce的处理结构化数据。</li>
</ul>
<p><br></p>
<h2 id="Hive是什么？"><a href="#Hive是什么？" class="headerlink" title="Hive是什么？"></a>Hive是什么？</h2><p>Hive是一个<strong>数据仓库</strong>基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。</p>
<p>最初，Hive是由Facebook开发，后来由Apache软件基金会开发，并作为进一步将它作为名义下Apache Hive为一个开源项目。它用在好多不同的公司。例如，亚马逊使用它在 Amazon Elastic MapReduce。</p>
<h3 id="Hive-不是"><a href="#Hive-不是" class="headerlink" title="Hive 不是"></a>Hive 不是</h3><ul>
<li>一个关系数据库</li>
<li>一个设计用于联机事务处理（OLTP）</li>
<li>实时查询和行级更新的语言</li>
</ul>
<p><br></p>
<h2 id="Hiver特点"><a href="#Hiver特点" class="headerlink" title="Hiver特点"></a>Hiver特点</h2><ul>
<li>它存储架构在一个数据库中并处理数据到HDFS。</li>
<li>它是专为OLAP设计。</li>
<li>它提供SQL类型语言查询叫HiveQL或HQL。</li>
<li>它是熟知，快速，可扩展和可扩展的。</li>
</ul>
<p><br></p>
<h2 id="Hive架构"><a href="#Hive架构" class="headerlink" title="Hive架构"></a>Hive架构</h2><p>下面的组件图描绘了Hive的结构：</p>
<p><img src="http://www.yiibai.com/uploads/allimg/141228/1-14122R10152108.jpg" alt="Hive Architecture"></p>
<p>该组件图包含不同的单元。下表描述每个单元：</p>
<table>
<thead>
<tr>
<th>单元名称</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户接口/界面</td>
<td>Hive是一个数据仓库基础工具软件，可以创建用户和HDFS之间互动。用户界面，Hive支持是Hive的Web UI，Hive命令行，HiveHD洞察（在Windows服务器）。</td>
</tr>
<tr>
<td>元存储</td>
<td>Hive选择各自的数据库服务器，用以储存表，数据库，列模式或元数据表，它们的数据类型和HDFS映射。</td>
</tr>
<tr>
<td>HiveQL处理引擎</td>
<td>HiveQL类似于SQL的查询上Metastore模式信息。这是传统的方式进行MapReduce程序的替代品之一。相反，使用Java编写的MapReduce程序，可以编写为MapReduce工作，并处理它的查询。</td>
</tr>
<tr>
<td>执行引擎</td>
<td>HiveQL处理引擎和MapReduce的结合部分是由Hive执行引擎。执行引擎处理查询并产生结果和MapReduce的结果一样。它采用MapReduce方法。</td>
</tr>
<tr>
<td>HDFS 或 HBASE</td>
<td>Hadoop的分布式文件系统或者HBASE数据存储技术是用于将数据存储到文件系统。</td>
</tr>
</tbody>
</table>
<p><br></p>
<h2 id="Hive工作原理"><a href="#Hive工作原理" class="headerlink" title="Hive工作原理"></a>Hive工作原理</h2><p>下图描述了Hive 和Hadoop之间的工作流程。</p>
<p>下表定义Hive和Hadoop框架的交互方式：</p>
<table>
<thead>
<tr>
<th>Step No.</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>Execute Query</strong>Hive接口，如命令行或Web UI发送查询驱动程序（任何数据库驱动程序，如JDBC，ODBC等）来执行。</td>
</tr>
<tr>
<td>2</td>
<td><strong>Get Plan</strong>在驱动程序帮助下查询编译器，分析查询检查语法和查询计划或查询的要求。</td>
</tr>
<tr>
<td>3</td>
<td><strong>Get Metadata</strong>编译器发送元数据请求到Metastore（任何数据库）。</td>
</tr>
<tr>
<td>4</td>
<td><strong>Send Metadata</strong>Metastore发送元数据，以编译器的响应。</td>
</tr>
<tr>
<td>5</td>
<td><strong>Send Plan</strong>编译器检查要求，并重新发送计划给驱动程序。到此为止，查询解析和编译完成。</td>
</tr>
<tr>
<td>6</td>
<td><strong>Execute Plan</strong>驱动程序发送的执行计划到执行引擎。</td>
</tr>
<tr>
<td>7</td>
<td><strong>Execute Job</strong>在内部，执行作业的过程是一个MapReduce工作。执行引擎发送作业给JobTracker，在名称节点并把它分配作业到TaskTracker，这是在数据节点。在这里，查询执行MapReduce工作。</td>
</tr>
<tr>
<td>7.1</td>
<td><strong>Metadata Ops</strong>与此同时，在执行时，执行引擎可以通过Metastore执行元数据操作。</td>
</tr>
<tr>
<td>8</td>
<td><strong>Fetch Result</strong>执行引擎接收来自数据节点的结果。</td>
</tr>
<tr>
<td>9</td>
<td><strong>Send Results</strong>执行引擎发送这些结果值给驱动程序。</td>
</tr>
<tr>
<td>10</td>
<td><strong>Send Results</strong>驱动程序将结果发送给Hive接口。</td>
</tr>
</tbody>
</table>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。</p>
<p>概念“Map（映射）”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归纳）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p>
<h4 id="映射和归纳"><a href="#映射和归纳" class="headerlink" title="映射和归纳"></a>映射和归纳</h4><p>简单来说，一个<strong>映射</strong>函数就是对一些独立元素组成的概念上的列表（例如，一个测试成绩的列表）的每一个元素进行指定的操作（比如，有人发现所有学生的成绩都被高估了一分，他可以定义一个“减一”的映射函数，用来修正这个错误。）。事实上，每个元素都是被独立操作的，而原始列表没有被更改，因为这里创建了一个新的列表来保存新的答案。这就是说，Map操作是可以高度并行的，这对高性能要求的应用以及并行计算领域的需求非常有用。</p>
<p>而归<strong>纳操</strong>作指的是对一个列表的元素进行适当的合并（继续看前面的例子，如果有人想知道班级的平均分该怎么做？他可以定义一个归纳函数，通过让列表中的奇数（odd）或偶数（even）元素跟自己的相邻的元素相加的方式把列表减半，如此递归运算直到列表只剩下一个元素，然后用这个元素除以人数，就得到了平均分）。虽然他不如映射函数那么并行，但是因为归纳总是有一个简单的答案，大规模的运算相对独立，所以归纳函数在高度并行环境下也很有用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。&lt;/p&gt;
&lt;p&gt;术语“大数据”是大型数据集，其中包括体积庞大，高速，以及各种由与日俱增的数据的集合。使用传统的数据管理系统，它是难以加工大型数据。因此，Apache软件基金会推出了一款名为Hadoop的解决大数据管理和处理难题的框架。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;a href=&quot;http://www.yiibai.com/hive/&quot;&gt;http://www.yiibai.com/hive/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件应用" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Hive" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/Hive/"/>
    
    
      <category term="软件应用" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8/"/>
    
      <category term="程序编程" scheme="http://yoursite.com/tags/%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Hive" scheme="http://yoursite.com/tags/Hive/"/>
    
  </entry>
  
  <entry>
    <title>关于月度总结的几个问题</title>
    <link href="http://yoursite.com/2018/01/21/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/%E5%85%B3%E4%BA%8E%E6%9C%88%E5%BA%A6%E6%80%BB%E7%BB%93%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98_20180121/"/>
    <id>http://yoursite.com/2018/01/21/个人日志/关于月度总结的几个问题_20180121/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-01-21T10:53:33.694Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="关于月度总结的几个问题"><a href="#关于月度总结的几个问题" class="headerlink" title="关于月度总结的几个问题"></a>关于月度总结的几个问题</h2><blockquote>
<p>【SCQA】 $\to$ 【SCA - WKO - RR - P】</p>
<blockquote>
<p>关键的触发器：S - W - R - P $\to$ 【Sword】</p>
</blockquote>
<p>S-C-A：当时是一个什么样的（S）场景 [where/when/who/what]，产生了这个方案/行为/问题/疑问 （Action / Answer）</p>
<p>Why：这个方案/问题的最终目的是？（一种状态 Be）</p>
<p>One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？</p>
<blockquote>
<p>Key：达成这个目的/状态的关键问题是什么</p>
</blockquote>
<p>Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？</p>
<p>Role：你扮演的角色是？</p>
<p>Defend：保护你的预留时间不被侵害</p>
</blockquote>
<p>【S-C-A】：<strong>发现自己的月度总结只是事件的堆砌，并没有实质性的总结与指导作用</strong>。这个体会之前就会，但一直没有去做改变。直到写2017年12月月度总结的时候，才准备做一些改变。那是因为，准备重新整理自己的博客；</p>
<p>【W】：<strong>(1) 记录并回顾过去一个月自己所经历的事情； (2) 对未来的行动方向做出调整</strong></p>
<p>【O】： (1) 及时记录； <strong>(2) 花足够的时间去重新梳理浪，并进一步思考；同时将待调整的行动具化到可执行的行动上。</strong></p>
<p>【o】：<strong>预留足够多的时间</strong>来给自己写总结</p>
<p>【R】：两个O只能达成一部分目的；另一部分是要确定如何来梳理同一类别下不同的事件（这个具体行动的时候可以在调整）</p>
<p>【R】：自我观察者</p>
<p>【D】：保护你的预留时间不被侵害</p>
<p><br></p>
<h2 id="对SCQA的思考"><a href="#对SCQA的思考" class="headerlink" title="对SCQA的思考"></a>对SCQA的思考</h2><p><strong>【原先的设定】</strong></p>
<p>在什么样的场景（S &amp; C）下，得出了这样的一个结论/方案（A），它的目的（Why）是达成什么样的一个状态（Be）或解决什么问题（Q）； </p>
<p><br></p>
<p><strong>【疑惑点】</strong></p>
<p>对于SCQA与Why的两种<strong>提问方式</strong>的不和谐感。因为其实这两个都是为了得到同一个目的：界定问题，但采取两种不同的表达方式。所以，当你同时采用的时候，总觉得会有一种不顺畅的感觉。</p>
<p>另外，实践才能检验。的确，必须要实际行动一遍，才能知道好用不好用。——浦东图书馆 2018.01.21  17:52</p>
<p><br></p>
<p><strong>【优化】</strong></p>
<p>对SCQA提问的思考：<strong>分开提问</strong></p>
<ol>
<li><p>S-C-A：当时是一个什么样的场景，产生了这个方案/行为/问题/疑问 </p>
</li>
<li><p>W ：这个方案/问题的最终目的是？</p>
<blockquote>
<p>通过SCA中自己发现的 [目的] 去与对方确认；同时明确对方的真正目的</p>
</blockquote>
</li>
<li><p>One：为了达成XX目的，最重要的一件事是什么？当前状态下能做的最重要的一件事又是什么？</p>
<blockquote>
<p>Key：达成这个目的/状态的关键问题是什么</p>
</blockquote>
</li>
<li><p>Reverse：这个方案/行动能解决真正的问题吗？为了解决问题，还需要什么内容？</p>
</li>
<li><p>Role：你扮演的角色是？</p>
</li>
<li><p>Defend：保护你的预留时间不被侵害</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;关于月度总结的几个问题&quot;&gt;&lt;a href=&quot;#关于月度总结的几个问题&quot; class=&quot;headerlink&quot; title=&quot;关于月度总结的几个问题&quot;&gt;&lt;/a&gt;关于月度总结的几个问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;【SC
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>个人日志_2017年12月总结</title>
    <link href="http://yoursite.com/2018/01/21/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/2017%E5%B9%B4%E5%BA%A6/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97_2017%E5%B9%B412%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/21/个人日志/2017年度/个人日志_2017年12月总结/</id>
    <published>2018-01-20T16:00:00.000Z</published>
    <updated>2018-02-12T09:01:25.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="12月总结"><a href="#12月总结" class="headerlink" title="12月总结"></a>12月总结</h2><p><img src="https://raw.githubusercontent.com/chf2012/P-markdownpic/master/个人日志_2017年12月总结_01.jpg" alt=""></p>
<p><strong>触发器：回顾工作总结、生活总结、读书笔记</strong></p>
<a id="more"></a>
<h3 id="【运动-amp-健康】8分"><a href="#【运动-amp-健康】8分" class="headerlink" title="【运动&amp;健康】8分"></a>【运动&amp;健康】8分</h3><ol>
<li>对于新年目标的达成情况：</li>
</ol>
<table>
<thead>
<tr>
<th style="text-align:center">做晨间日志</th>
<th style="text-align:center">早睡早起</th>
<th style="text-align:center">晚睡早起</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">24天</td>
<td style="text-align:center">9天</td>
<td style="text-align:center">15天</td>
</tr>
</tbody>
</table>
<ol>
<li>天气寒冷，准备拿出我爱的黑色长大衣来穿。不知何时，原本只爱飒爽秋风的我，也开始慢慢喜欢上了寒冷的冬季。</li>
<li>平常都是用手掰苹果的，这次因为刚好有刀就用了刀来切苹果；切完之后因为不想洗，比较懒，就用纸巾擦。然后猛的一划，左手中指上深深的一道口子；忧伤。还好5F前台有酒精棉花和创可贴，才稍微缓解了伤势。果然，不熟悉的武器容易伤到自己。</li>
<li>寒风袭来，流感肆虐；好多人都陆续感冒，自己期间也有一段时间喉咙一直不舒服，通过多喝开水，多注意，最后还是好转了，并没有步入流感的行列。</li>
<li>每周一次的羽毛球运动，继续保持。打羽毛球；发现教练重要，是因为他能够帮助你调整姿势，更关键的把你从习惯性地动作拉回到意识；即当你挥拍的时候，你是有意识地调整自己的动作。</li>
<li>买了折叠椅，避免午睡的时候在趴着睡；因为明显贵感觉到脚麻；</li>
<li>放毒，完全是因为无聊；完全是因为一时兴起；完全是因为有一个触发器，然后想去得到那个最后的奖励，最终在引发了行为；</li>
<li>出门的时候要带上零食，以备不时之需；很重要；因为自己在书局看书的时候，往往弄到很晚才去吃饭。</li>
</ol>
<p><br></p>
<h3 id="【生活-amp-娱乐】-9分"><a href="#【生活-amp-娱乐】-9分" class="headerlink" title="【生活&amp;娱乐】 9分"></a>【生活&amp;娱乐】 9分</h3><ol>
<li>迎来了今年的第二次出游，目的地：浙江丽水缙云；原本是要去青岛玩耍的，只是突发状况过多，只能改道南下了。酒店真的是住着舒服，风景环境都是一级棒。缙云呢，就是一个山村的感觉。这次旅行，就是逃离都市，贴近大自然。发了一张朋友圈，”岁月静好” 。配图是我们4个小伙伴站在弹簧上，满脸笑容。发现，自己变得越来越珍惜现在的人和事。人也好，事也好，越发珍惜，越发投入感情。<br>另外，发现一个精致的蓝牙音箱，然后每次进门都要用来听歌；嗯。以后买一个蓝牙音箱放在卧室，对于一个爱听音乐的我来说的确是一个好东西。能够切实提高我的生活质量与幸福感。</li>
<li>现在出门都带着一副海绵耳塞 + 降噪耳机。周六在大众书局回顾《数据之美》时，降噪耳塞发挥了作用，虽然旁边的人在很大声地交谈事情，但并没有因此影响到我的心情。果然是好东东。</li>
<li>睡前因为没有可看的书，然后就看了动漫。之后就玩《火影忍者》又耗费了50分钟的时间。第二天早上果断卸载。但是，之后却还是装回来了，没事的时候又常常玩。</li>
<li>因着手被割伤，加上最近都很累；晚上的时候就果断早早下班，然后自己买了《寻梦环游记》的电影票；迪士尼的动画已经可以做的这么逼真与精美了。原来龙阳路的 中影DFC影城，影院还是非常大的。今天基本就是包场，因为不到10个人</li>
<li>约Changhy一起看《芳华》；散场23:00出来，整个街道是如此的安静与干净，慢慢地走，缓缓地骑；一路从世博源骑车回来；这种夜晚干净的街角甚是喜欢；</li>
<li>逛了一圈南京东路，最后还是买了最开始看到的那顶帽子；H&amp;M的 黑白格子帽子</li>
<li>迪士尼一日游。和同事外加一位新认识的菇凉Sunll 一起玩耍。记录那些美好；幻想曲旋转木马（第一个玩的项目）、探险家独木舟、巴斯光年星际营救、创极速光轮（特别刺激）、加勒比海盗（真的很赞）、探秘海妖复仇号、欢笑聚友会（拍照合影）、翱翔 飞越地平线（等了2个多小时的4D电影）、绳索挑战道（高难度的空中项目）、爱丽丝梦游仙境迷宫（红皇后）、奇幻童话城堡、漫威英雄总部（钢铁侠）、米奇俱乐部；原本是要看晚上的烟花的，但大家都走了，所以没有看成，算是小小遗憾吧。</li>
<li>晚上和Liuyx一起去了世博轴买圣诞节 “交换礼物” 活动的礼品；买了一个看着就让人很暖的暖水袋；还配了一个手套在外面，看着就很暖。不过外面的袋子竟然花了我15大洋，感觉被抢了。交换礼物；抽到了一个点烟器；看着高端，只是并不适合我。最后送给了Zhul；因为她抽到的是2包烟。（T..T）</li>
<li>在三钢里发现了一家过桥米线；开心。</li>
<li>参加 “ 社健身的射箭活动 ” ；也是第一次体验复合弓的射箭；玩的挺开心的，也认识了新伙伴，加深了与Daijh 的联系；发现自己相对于其他男生，其实更容易与对方沟通；更加外向、自信一点；尤其在于陌生人沟通的时候；</li>
</ol>
<p><br></p>
<h3 id="【阅读-amp-学习】-10分"><a href="#【阅读-amp-学习】-10分" class="headerlink" title="【阅读&amp;学习】 10分"></a>【阅读&amp;学习】 10分</h3><ol>
<li><p>《精益数据分析》尤科维奇：主要从各个行业的关键指标去阐述；更多的是告诉你如何去理解不同行业的商业模式与关注点；从创业的视角来阐述不同阶段应关注的核心指标；并提到了好的指标应具有的特点（对比、比率、简单）</p>
</li>
<li><p>《智能时代》- 吴军 ；</p>
<ul>
<li>大数据的三个特点：数据量大、多维性、全面性</li>
<li>原有产业 + 新技术 = 新产业；</li>
<li>大数据面临的几个关键问题：存储、传输、并行处理与实时计算、隐私保护</li>
</ul>
<blockquote>
<p>对于大数据面临的几个关键问题：统一标准、集中存放、共享等问题；中国更有可能走在前列，因为中国是一个高度集权化的国家，这些问题在西方强调民主的国家可能很难做，但在中国只要政府有心，就可以整合在一起。</p>
</blockquote>
</li>
<li><p>《人活到极致，一定是素与简》-山口势子；极简主义：指的是<strong>只留下最重要的东西，并且为此倾注全部的精力</strong>；</p>
<ul>
<li>记录了自己所希望的家居风格，写入OneNote；家居在宜家 or 无印良品购买；偏向木质、白色两种颜色；</li>
</ul>
</li>
<li><p>参加《颈椎知识讲座》，学到几个拉伸颈部肌肉的动作，算是有一点点收获；</p>
</li>
<li><p>信用卡分期；从向客户收取分期费用转而向企业收取；这个想法新颖又好。一方面促进了消费，另一封面又促进了企业产品的销售，一举两得。</p>
<ul>
<li>产品分期，客户是无需支付费用的；</li>
<li>产品售出，客户选择分期支付；银行一次性把款项打给企业，然后企业拿出一部分费用给到银行；</li>
<li>客户按期将资金支付给银行，最后完成整个交易；</li>
</ul>
</li>
<li><p>关于工具Python 与 R 的选择，又陷入了纠结。我是希望能够用自己的判断去做选择，而不是听别人的。不过，要知道别人做选择也是有他们自己的考量的。最后选择了Python，开始《Python核心编程》</p>
<ul>
<li>R 在数学统计、数学分析、可视化上有优势；适合单机运行</li>
<li>Python 在机器学习、深度学习上有优势；适合网上在线运行</li>
</ul>
<blockquote>
<p>了解基础概念很重要；</p>
</blockquote>
</li>
<li><p>重新学习Python的基础知识。翻完了《Python核心编程》的基础部分，关键还在于实践；</p>
</li>
<li><p>《元数据》：关于数据的描述；</p>
<ul>
<li>数据：1991.03.21</li>
<li>数据的描述：日期</li>
</ul>
<blockquote>
<p>元数据（日期）说明了数据（1991.03.21）所代表的含义</p>
</blockquote>
</li>
<li><p>《最重要事只有一件》- 加里 $\cdot$ 凯勒 (Gary Keller) ：每天要先完成最重要的事情；这个道理你真正体会并懂得了吗？并没有，因为没有知行合一；当前你做的只不过把任务列出来而已；</p>
</li>
<li><p>买来一系列关于精简的书籍；准备在年末的时候看这类的书籍，然后重新思考，制定2018年的的个人计划；</p>
<ul>
<li>温习《80/20法则》_理查德-科克<em>Richard-Koch；《每周工作4小时》</em>蒂莫西.费里斯（Timothy Ferriss)</li>
</ul>
</li>
<li><p>《精要主义》_格雷尔  麦吉沃恩 (Gray Mckewon)</p>
<ul>
<li>认识到选择这个权利，是独一无二，每个人都有的；无关选择的对象</li>
<li>精要主义者往往花更多的时间去思考可能的答案，因为他们专注于做一件大事；</li>
</ul>
</li>
<li><p>《精要主义》_格雷尔  麦吉沃恩（Gray Mckewon）</p>
<ul>
<li>选择：区分重要、不重要的事情</li>
<li>排除：把不重要的事情排除掉（行动）</li>
<li>执行：更加高效又容易地去做重要的事情 </li>
</ul>
</li>
<li><p>《专注力》只有第一部分的内容对我有帮助，其他大量的篇幅并没有多少用；但也足够了。</p>
</li>
<li><p>《最重要的2小时》，一个很重要的内容：觉察点；告诉你觉察点是什么，以及如何去发觉觉察点；所谓觉察点，<strong>就是在两件事情的间隔之间；当做完一件事或者右一件事情打断你的时候，当你准备做下一个任务的时候，这就是一个觉察点；</strong></p>
</li>
<li><p>《那些细碎却美好的时光》_山亭夜宴；翻了几页，就当闲来无事的时候翻看而已；</p>
</li>
<li><p>了解到新的文本编辑器 Sublime Text；后续花时间去研究；因为明显感觉Typora在打开文档速度比较慢，并且会卡顿；需要找一个合适的编辑器，且需要 “ 所见即所得 “。</p>
</li>
</ol>
<p><br></p>
<h3 id="【工作】-8分"><a href="#【工作】-8分" class="headerlink" title="【工作】 8分"></a>【工作】 8分</h3><ol>
<li>划分了工作的处理顺序之后，效率还是有明显地提升；继续保持；</li>
<li>新领导的风格是以我的视角出发，给你提供我认为你所需要的内容。<ul>
<li>换个视角来思考， 总是走在你前面，为你做好了铺垫 。但这个是否为你真正需要的，可能并非如此。</li>
</ul>
</li>
<li>关于工作任务的负责人：我的原则是谁负责谁跟进；<ul>
<li>搭建中间库的过程中，做到一半让别人来跟进，这个事情我认为非常不妥。</li>
<li>与对方沟通这个事情，我并不觉得有什么问题。</li>
</ul>
</li>
<li>对于领导分配的工作，会带有疑惑；但并不会马上去否定，而是会先去做调查，然后在进行反馈。虽然如此，但自己的态度的态度还是挺谨慎的。一开始的时候，谨慎一点是正确的。等到了解了对方的风格之后，应该会转变态度，就事论事；</li>
<li>Liuqh 再一次强调Python的重要性，以及Tensor需要学习的目的与原因；</li>
<li>Hezy 提到，对于这个现象以后可以做个测算。这个想法触动到了我对于数据分析价值的体现：一个数据分析师真正要做的应该是这样的事情才对。同时，让我对编程语言Python 又有了新的渴望。如果要做好这样的事情，必须要涉及到用编程语言去解决。</li>
<li>对于临时分派的任务，当领导说可以交给你的时候（并且在其他领导面前时），你不应该表现出自己不适合或能力不够；因为这样子就是在说，你的领导识人不对。关于ZhiXG迁址上海需要报告的任务；其实当时是有考量的，但最后还是没有想清楚。</li>
<li>发现对于工作的事情，涉及到催别人要东西，整个事情效率就会很低；尤其是当对方并不怎么配合的时候。因为自己并不是这样的情况。最多只会让对方催2遍；因为我会有自觉。</li>
<li>跟Liuqh沟通了这一年的工作内容、成长与评价；这次了解到了<strong>整个数据分析的前端、后端的内在联系；包括自己应该努力的方向</strong>；很感谢Liuqh 的耐心指导。</li>
<li>面对一件事情，关于你对待它的态度、要花费的精力等，这些都取决于你的定位；在事情进入的时候，你要首先去明确在这个事件中，自己的角色是什么。</li>
</ol>
<p><br></p>
<h3 id="【友情】7分"><a href="#【友情】7分" class="headerlink" title="【友情】7分"></a>【友情】7分</h3><ol>
<li>对于友谊的处理，自己还真的是不会。<strong>把特长带回来分给大家的时候，感觉有些做作；自己都感觉到了。这样的自己，不喜欢</strong>；应该说是在面对某些人的时候，更容易暴露出孩童般的那个自己。感觉这里的情谊，比较淡；大家各自做自己的，并无多少交集与情谊；或许是另外一种的情谊。只是并不是适合你的样子而已。</li>
<li>在影城门口看到了很大只的夹娃娃，突然想起之前lijj 看到大娃娃的吃惊表情，就发了照片给她；</li>
<li>大学好友 Lusq 来上海啦。约了 Lijj 一起吃饭；也记不清上一次见面是什么时候了。3个人吃了韩宫宴（韩国烤肉）；问了lusq的女儿 陆梓菡 很文艺的名字；<ul>
<li>晚饭结束后送Ta回酒店，然后径直去了他的房间。（其实我也有些诧异，一个女孩子一点也没有顾忌；还是有点意外）；可能正是她的这种性格，让她能够交到很多知心的朋友。因为真实，所以美丽。</li>
<li>晚上的自己，话变得少了。安静的存在着。但也并不会不和谐。</li>
</ul>
</li>
<li>Lijj 说，她可能会回去福建做银行其他模块的工作，然后跳出信用卡业务的这个圈子；回去是因为在上海没有这样跨模块的工作机会，在福建会有人脉能够获得这样的机会；嗯。</li>
<li>晚上接到Guanyh的电话，这两天回家了明天返沪。最近在找工作，关于秘书类职位；聊到那些有很多知心朋友的人，甚是羡慕。他们的特点都是<strong>不拘小节；不拘泥于细节。</strong></li>
<li>与Changhy一起在书局看书，沟通；虽然两个人往往不在同一个频率，但这并不影响；互相沟通交流，还是挺有帮助的。这次，让回想起角色定位这个概念；</li>
</ol>
<p><br></p>
<h3 id="【亲情】6分"><a href="#【亲情】6分" class="headerlink" title="【亲情】6分"></a>【亲情】6分</h3><ol>
<li>晚上妈妈来电，说起有人要做媒；哈哈。我说我现在没有心思，而且异地也没有意思。</li>
</ol>
<p><br></p>
<h3 id="【投资】0分"><a href="#【投资】0分" class="headerlink" title="【投资】0分"></a>【投资】0分</h3><p><br></p>
<h3 id="【感恩回报】6分"><a href="#【感恩回报】6分" class="headerlink" title="【感恩回报】6分"></a>【感恩回报】6分</h3><ol>
<li>手被割伤的时候，感谢前台小妹的帮助。上楼后用RTX再次表示了感谢。</li>
<li>把充电线借给了陌生人；一开始的时候有点犹豫，并没有第一时有所反映，因为我知道自己马上就要走了。但随后想起来之后还是把充电器借给了对方。做一个善良的人；</li>
</ol>
<p><br></p>
<h3 id="【成功小事】10分"><a href="#【成功小事】10分" class="headerlink" title="【成功小事】10分"></a>【成功小事】10分</h3><ol>
<li><p>回顾了《工作思索&amp;工作习惯》、《思维的组织与表达》</p>
</li>
<li><p>面对同事的多次疑问，保持了温和的态度；</p>
</li>
<li><p>与集团小伙伴Hujl 沟通数据及字段的时候，意识到了自己的口吻，保持了温和的态度。</p>
</li>
<li><p>第一次主动提涨薪的事情；因为觉得自己对得起这个薪资，另一方面也是越加逼近的紧迫感；</p>
</li>
<li><p>第一次在周六早上的时候完成了日志；</p>
</li>
<li><p>无聊的时候去阅读，就会静心；</p>
</li>
<li><p>先做重要且困难的事情，然后早早完成的那一刻，真的很舒服；（年度提纲）完成常规工作之后，先做了最重要的事情（年度总结报告的提纲）；先做完这个事的时候，感觉时间还很充裕；感觉这一天的工作又进展。确实，由于这件事本身是最重要的，所以会很有成就感；</p>
</li>
<li><p>明白自己要什么，即使休假，也要通过外界环境（上班发日报）来促使自己早起</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h3 id="【自我思索】9分"><a href="#【自我思索】9分" class="headerlink" title="【自我思索】9分"></a>【自我思索】9分</h3><ol>
<li>觉得自己生活中还是很像一个小孩子；并且还把这样的特性带来了工作中；这并不是我所期望的。<ul>
<li>生活，我喜欢随性的自己；工作中，我喜欢稳重的样子；但问题是，由于宽松的办公环境，会使得自己把生活中的自己代入到工作状态中；每当这种时候，就会感觉很不舒服；因为我知道，这不是一个职业人在工作场合该有的表现。随性的孩童的性格可能是自己无意识中的状态；</li>
<li>割伤手指之后，在Zhengyj旁边讨论事情时，表现得最真自我；然后被说像小孩子一样；当时，我并没有觉得不舒服，应该是那个时候的状态我自己把它切换都了生活状态；如果是另一个场景听到这样的话，我估计就要好好反思了。</li>
</ul>
</li>
<li>真实；生活还是相处，最关键的还是真实；坦诚地活出自己的样子，不要做作，不要讨好，更不要唯唯诺诺；只要做到这一点，足以；【很长一段时间，又没有好好提醒自己了；又需要好好自省一下】</li>
<li>思考的触发器、个性的坦诚与真实，都没有有意识地去做。因为并没有意识到。</li>
<li>晚上回来的时候，想想自己一个人也是挺悲凉的。或许每一个独自在外的人儿都是这样的。</li>
<li>现在买东西，不会在货比三家；找到自己喜欢的，就会买下来。也不会太计较价格；（在Hotwind 买了一双冬天的鞋子，469元）</li>
<li>待人温和；严以律己，宽以待人。<strong>与人沟通的时候，温和一些；少一些不耐烦；</strong>Zhengyj童鞋提到我有的时候对她比较凶，真的抱歉。</li>
<li><strong>在撰写分析文章之前，先梳理提纲，写下来而不仅仅是在脑中思考；并时刻对照文章是否根据提纲的思路在表达；因为思维是多维的，而文字输出只能是线性的；</strong> </li>
<li>这周感觉特别无聊；无所事事，不想学习；但一旦开始阅读，把自己置于学习的环境中，就不会再有这种感觉；所以，关键在于去迈出第一步；</li>
<li>一旦知道第二天休息，就会不知不觉地晚睡；或者说把正常作息看的没有那重要，因为潜意识里面会说，明天不重要；</li>
<li>跨年；一个与我并无关联的词；因为找不到伙伴；因为很想吃胖哥俩，最后自己一个人去了，点了一份肉蟹煲。虽然吃到了想吃的，但仍旧抵不过孤独感；</li>
</ol>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;12月总结&quot;&gt;&lt;a href=&quot;#12月总结&quot; class=&quot;headerlink&quot; title=&quot;12月总结&quot;&gt;&lt;/a&gt;12月总结&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/chf2012/P-markdownpic/master/个人日志_2017年12月总结_01.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;触发器：回顾工作总结、生活总结、读书笔记&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人日志" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="个人日志" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>时间的朋友2017:中国式机会_罗辑思维</title>
    <link href="http://yoursite.com/2018/01/11/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/Others_%E7%BD%97%E6%8C%AF%E5%AE%87-%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4/%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B/%E6%97%B6%E9%97%B4%E7%9A%84%E6%9C%8B%E5%8F%8B2017-%E4%B8%AD%E5%9B%BD%E5%BC%8F%E6%9C%BA%E4%BC%9A_%E7%BD%97%E8%BE%91%E6%80%9D%E7%BB%B4_20180111/"/>
    <id>http://yoursite.com/2018/01/11/阅读书籍/Others_罗振宇-罗辑思维/时间的朋友/时间的朋友2017-中国式机会_罗辑思维_20180111/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-02-13T13:50:06.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六个问题"><a href="#六个问题" class="headerlink" title="六个问题"></a>六个问题</h2><blockquote>
<p>2017年哪一天、哪一个时刻你认为很重要？</p>
</blockquote>
<ol>
<li>不是强者，还能不能登上舞台？</li>
<li>刚刚进场者，能不能找到玩法？</li>
<li>如果跟不上变化，会不会被淘汰？</li>
<li>中国经济增长会不会遇到天花板？</li>
<li>中国经济增长有没有可持续性？</li>
<li>中国能否赢得良性的全球发展环境？</li>
</ol>
<p><br><a id="more"></a></p>
<p><br></p>
<h2 id="六个脑洞"><a href="#六个脑洞" class="headerlink" title="六个脑洞"></a>六个脑洞</h2><h3 id="1-动车组脑洞"><a href="#1-动车组脑洞" class="headerlink" title="1.动车组脑洞"></a>1.动车组脑洞</h3><blockquote>
<p>不是强者，还能不能登上舞台？</p>
</blockquote>
<p>平凡创新的动车组时代</p>
<p><br></p>
<h3 id="2-热带雨林脑洞"><a href="#2-热带雨林脑洞" class="headerlink" title="2.热带雨林脑洞"></a>2.热带雨林脑洞</h3><blockquote>
<p>刚刚进场者，能不能找到玩法？</p>
<p>新连接、小生态</p>
<p>核心：超级用户思维</p>
</blockquote>
<ol>
<li><p>一旦有人不断地涌入了互联网，就一定需要一个全新的连接器。</p>
</li>
<li><p>新物种，往往是高价值的连接器；</p>
<blockquote>
<p>零零后，区别就是有钱；</p>
</blockquote>
</li>
<li><p>老玩法：<strong>流量思维</strong>（一代商业思维；公平对待）；新玩法：<strong>超级用户思维</strong> （区别对待）</p>
<blockquote>
<p>优酷视频，一个会员对这家公司的贡献是免费用户的二十倍；资源肯定向你倾斜；但它目前的识别方式就是交费；是不是会员用户；</p>
<p><u> 【瓶盖测试：<strong>不管你对陌生普通用户有多好，请先关照你身边的超级用户的感受。】</strong></u> </p>
<blockquote>
<p>你跟你的女朋友一起去看电影，旁边一个姑娘想请你帮她拧开矿泉水瓶；</p>
</blockquote>
</blockquote>
</li>
<li><p>会员经济，最重要的是在企业和消费者之间建立了一种可持续信任的正式关系；</p>
</li>
<li><p><strong>超级用户思维，我希望你以我为荣；（用户以你们为荣，但同时我们也以用户为荣）。</strong>面朝超级用户，才能春暖花开。</p>
<ul>
<li>做给用户长脸的事情</li>
<li>绝不做给用户丢脸的事情（这个是克制本能冲动的事情）</li>
</ul>
</li>
<li><p>企业的使命，创造且留住顾客。——德鲁克</p>
</li>
</ol>
<p><br></p>
<h3 id="3-比特化脑洞"><a href="#3-比特化脑洞" class="headerlink" title="3.比特化脑洞"></a>3.比特化脑洞</h3><blockquote>
<p>如果跟不上变化，会不会被淘汰？</p>
<p>比特世界和我们想象的不一样；原来我们要费劲力量穿越进去，要转型，因此很焦虑。但真实的比特世界是一种席卷一切的力量，你想逃都逃不掉。</p>
<p>做最好的自己，以最高的效率最最好的自己。</p>
</blockquote>
<ol>
<li>小米：认知战。不是价格战；它是干掉你的选择，不是让你去评估选择。”闭着眼睛买东西”</li>
<li>互联网会变成一种基础设置；之前从无到有，之后三十年会是从有到无（无处不在的无）；</li>
<li>互联网革命，是一场裹挟一切的变革；（不要低估革命的力量；或者那些力量微小的就根本不是革命；）<ul>
<li>你说，我就站着不动，他们就有能力把你生拉上船；你不能，他们就有本事让你能。</li>
</ul>
</li>
<li>未来战争，不在于你拥有多少资源，而在于你能调动资源；</li>
<li>做最好的自己，同时保持开放。—— 90分旅行箱 </li>
<li>你不用急着出发，因为你会<strong>被抵达</strong>。 你不需要以互联网为彼岸，那不是你要穿越过去的，而是他们会来找你的。</li>
<li>效率越来越高，分工越来越细。<ul>
<li>只要你的方式是推动效率，你不用关系什么转型；</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="4-拔河脑洞"><a href="#4-拔河脑洞" class="headerlink" title="4.拔河脑洞"></a>4.拔河脑洞</h3><blockquote>
<p>中国经济增长会不会遇到天花板？</p>
</blockquote>
<ol>
<li><p>我们不能再中国国土框架内思考的，必须在全球框架内思考这个问题。</p>
</li>
<li><p>人们用两种范式来思考世界：自然地理、地缘政治 </p>
<ul>
<li>物理距离，并不是真实的距离</li>
<li>地缘政治把世界分割成地图上的样子</li>
<li>基础设置把世界连接成另外一个样子</li>
</ul>
</li>
<li><p>世界不再是块与块的拼图，还是基础设施连成的电线网</p>
<ul>
<li>城市化，把平摊的 “面” 变成聚拢的 “点”</li>
<li><strong>只拥有，不连接，就是一个资源孤岛</strong></li>
</ul>
</li>
<li><p>拔河游戏，是所有人都参与的游戏，希望所有人都参与。拳击比赛，是强者的比赛，是有准入门槛的；</p>
<ul>
<li><p>拳击比赛的逻辑不可持续，因为<strong>已经很难找到具体的人</strong> ；</p>
<blockquote>
<p> 【启示】一切的边界都在被模糊</p>
</blockquote>
</li>
<li><p>拔河游戏，只关心价值移动的方向；中国一家公司想创新的时候，它的创新能力会结合这个国家的规模，在世界上拔河，把这些价值向我们拉过来</p>
</li>
</ul>
</li>
<li><p>一个深刻的真理的反面，可能是一个更深刻的真理。 —— 玻儿</p>
</li>
</ol>
<p><br></p>
<h3 id="5-终点站脑洞"><a href="#5-终点站脑洞" class="headerlink" title="5.终点站脑洞"></a>5.终点站脑洞</h3><blockquote>
<p>中国经济增长有没有可持续性？</p>
</blockquote>
<ol>
<li>雁阵模型：产业会进行转移；</li>
<li>“比较理论” 在中国上失效了。</li>
<li>产业更新换代的速度太吓人了。<ul>
<li>我们并没有错做什么，但是不知道为什么，我们输了。 —— 诺记亚 <ul>
<li>自有生产线的速度跟不上产业创新的速度</li>
</ul>
</li>
</ul>
</li>
<li>从 “工厂外包” 到 “风险外包”  （苹果公司的创新速度）<ul>
<li>高效率 VS. 高弹性<ul>
<li>高效率来自分工；分工越细，越高效；但弹性与专业化是矛盾的；专业化带来的低弹性</li>
</ul>
</li>
<li>动态重组的供应链网络（积木）</li>
</ul>
</li>
<li>中国的超大规模性。规模本身就是一种能力；</li>
<li>中国是这一轮全球产业转移的终点站</li>
</ol>
<p><br></p>
<p><br></p>
<h3 id="6-枢纽脑洞"><a href="#6-枢纽脑洞" class="headerlink" title="6.枢纽脑洞"></a>6.枢纽脑洞</h3><blockquote>
<p>中国能否赢得良性的全球发展环境？</p>
</blockquote>
<ol>
<li><p>中国未来的全球角色？中国是世界秩序的自变量；</p>
</li>
<li><p>世界对中国的一个<strong>需求</strong>，把我们<strong>塑造成的一种角色</strong>；</p>
</li>
<li><p>双循环 结构。中国成为一个不可缺少的节点；是世界的十字路口；</p>
<ul>
<li>西方通过中国投放秩序；欠发达国家通过中国发展繁荣</li>
</ul>
</li>
<li><p>历史上的国家和衰败，只是影响到自己；今天任何一个国家的衰弱， 都可能影响世界上其他地方；—— 《枪炮病菌与钢铁》</p>
<ul>
<li>西方不输出繁荣和秩序，就会被输入贫穷和动乱</li>
<li>西方渴望帮助非洲，结果反而摧毁了非洲的经济</li>
</ul>
<blockquote>
<p>【共鸣】援助是没有办法真正改变贫穷的；</p>
</blockquote>
</li>
<li><p>建立秩序，必须把简单的援助转化为具体的经贸过程；</p>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ol>
<li><p>大者越大，强者恒强</p>
</li>
<li><p>“黑洞效应”：一家公司有两个特点：网络协同 + 数据只能</p>
</li>
<li><p>快：小米步枪（吃鸡游戏）；第三天网易发布两款同类游戏；一周内腾讯发布游戏；网络市场，先发优势很重要。小米步枪占领Apple Store 中国第一名，就省去了几百万美元的推广费；</p>
<blockquote>
<p>机器快、公司快、市场快、用户快</p>
</blockquote>
</li>
<li><p>一家游戏公司，在未取得授权之前在网络发布，等到第二天从市场数据的反馈告诉你哪个明星是有效的，立马与对方的经纪人联系。</p>
</li>
<li><p>玩家迭代的方向，就是产品迭代的方向。</p>
<blockquote>
<p>【启发】想起这样一句话，每个人都在问什么在变，我们要知道的是什么没有在变。客户对于简答的需求没有在变，那就是我们要做的方向。</p>
</blockquote>
</li>
<li><p>豌豆公主效应：体验是一种可训练的能力；一旦达成，就再也退不回去了。</p>
<blockquote>
<p>音频的二倍速、三倍速、五倍速；</p>
</blockquote>
</li>
<li><p>竞争是过去的商业关键词；现在是我们必须追赶用户。</p>
</li>
<li><p>你必须不停地奔跑，你才能留在原地。 ——《爱丽丝》</p>
</li>
<li><p>创新，就是解决问题的能力。—— 熊彼特</p>
</li>
</ol>
<p><br></p>
<h3 id="人生算法"><a href="#人生算法" class="headerlink" title="人生算法"></a>人生算法</h3><blockquote>
<p>算法 VS. 规律</p>
</blockquote>
<ol>
<li><p>即使机会相同，算法不同，结果就不同；</p>
<ul>
<li>一个按钮得100万美元；一个按钮一半得一亿美元，一半是什么都没有。</li>
</ul>
</li>
<li><p>人生算法，不断提高达成目标的概率的过程；</p>
</li>
<li><p>人生的一切结果本质上都是概率问题；所有的人生的选择和目标，都是那个一亿美元；</p>
</li>
<li><p>算法就是在连续性基础上运行的原则；</p>
</li>
<li><p><strong><u>所谓的人生算法，就是在漫长的过程中不断找到那个最初的原则。</u></strong></p>
<ul>
<li>当成功概率很高的时候，下最大的赌注；其余时间按兵不动；</li>
<li>人生就是滚雪球，找很多很湿的雪，加上一道很长很长的坡，然后把自己那个最原初的算法，那个雪球一直滚下去 —— 巴菲特</li>
<li>成就 = 核心算法 $\times$ 大量重复动作$^2$</li>
<li>找到那种值得不断重复下去的最基本的套路；</li>
<li>抓住它、重复它、强化它</li>
</ul>
</li>
<li><p>算法的力量，把一切软肋变成铠甲；</p>
</li>
<li><p>岁月不饶人，我亦未曾饶过岁月。—— 木心</p>
<p>​</p>
</li>
</ol>
<p><br></p>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ol>
<li>罗胖的内容很正能量，很有感染力；同时也会营销；（拿出你的手机，拍照照，发个朋友圈，说我相信）</li>
<li>罗胖，一直不忘记他的用户；也不忘记他的赞助商；他真诚，这个也是我所需要的。 视频160分处</li>
<li>对时间的掌控能力，尤其是最后一段时间；真厉害；</li>
</ol>
<p><br></p>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><ol>
<li>《超级版图》：真实的世界什么样？</li>
<li>《枢纽》</li>
<li>《原则》Ray Darial</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;六个问题&quot;&gt;&lt;a href=&quot;#六个问题&quot; class=&quot;headerlink&quot; title=&quot;六个问题&quot;&gt;&lt;/a&gt;六个问题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;2017年哪一天、哪一个时刻你认为很重要？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;不是强者，还能不能登上舞台？&lt;/li&gt;
&lt;li&gt;刚刚进场者，能不能找到玩法？&lt;/li&gt;
&lt;li&gt;如果跟不上变化，会不会被淘汰？&lt;/li&gt;
&lt;li&gt;中国经济增长会不会遇到天花板？&lt;/li&gt;
&lt;li&gt;中国经济增长有没有可持续性？&lt;/li&gt;
&lt;li&gt;中国能否赢得良性的全球发展环境？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>2018年新年目标：做一个精要的人</title>
    <link href="http://yoursite.com/2018/01/02/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/2018%E5%B9%B4%E6%89%93%E7%A0%81%E8%AE%B0%E5%BD%95%20-%20%E5%81%9A%E4%B8%80%E4%B8%AA%E7%B2%BE%E8%A6%81%E7%9A%84%E4%BA%BA/"/>
    <id>http://yoursite.com/2018/01/02/个人日志/2018年打码记录 - 做一个精要的人/</id>
    <published>2018-01-01T16:00:00.000Z</published>
    <updated>2018-02-16T14:32:32.495Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018年新年目标：做一个精要的人"><a href="#2018年新年目标：做一个精要的人" class="headerlink" title="2018年新年目标：做一个精要的人"></a>2018年新年目标：做一个精要的人</h2><p><strong>做一个精要的人；</strong></p>
<a id="more"></a>
<p><br></p>
<p><strong>#以下打码记录#</strong></p>
<p>a - 表示早睡早起； b - 表示晚睡晚起；</p>
<p>1 - 表示有写日志； 0 - 表示未写日志； 2 - 表示晚上补写前一天的日志</p>
<p>1 - 表示有回忆精要的；0 - 表示未回忆</p>
<blockquote>
<p>1.1-a11</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">1月</th>
<th>2月</th>
<th>3月</th>
<th>4月</th>
<th>5月</th>
<th style="text-align:left">6月</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1.1-b0</td>
<td>2.1-a</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.2-b2</td>
<td>2.2-a</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.3-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.4-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.5-b1</td>
<td>2.5-a</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td>2.6-a</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.7-b1</td>
<td>2.7-a</td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.8-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.9-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.10-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.11-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.15-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.16-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.17-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.18-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.19-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.20-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.23-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.24-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.26-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">2.27-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.29-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.30-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">1.31-b1</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><br></p>
<table>
<thead>
<tr>
<th style="text-align:left">7月</th>
<th>8月</th>
<th>9月</th>
<th>10月</th>
<th>11月</th>
<th>12月</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>不能因为是周末，就可以晚睡晚起，甚至熬夜；</strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2018年新年目标：做一个精要的人&quot;&gt;&lt;a href=&quot;#2018年新年目标：做一个精要的人&quot; class=&quot;headerlink&quot; title=&quot;2018年新年目标：做一个精要的人&quot;&gt;&lt;/a&gt;2018年新年目标：做一个精要的人&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;做一个精要的人；&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="个人日志" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="个人日志" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/01/01/%E8%BD%AF%E4%BB%B6%E5%BA%94%E7%94%A8_%E5%8A%9E%E5%85%AC%E8%BD%AF%E4%BB%B6/Markdown/%E7%A9%BA%E7%99%BD%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2018/01/01/软件应用_办公软件/Markdown/空白模板/</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-02-13T13:56:40.166Z</updated>
    
    <content type="html"><![CDATA[<p><em>主题</em></p>
<a id="more"></a>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;主题&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《每天最重要的2小时》读书笔记_乔西.戴维斯</title>
    <link href="http://yoursite.com/2017/12/31/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89/%E3%80%8A%E6%AF%8F%E5%A4%A9%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%842%E5%B0%8F%E6%97%B6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%B9%94%E8%A5%BF.%E6%88%B4%E7%BB%B4%E6%96%AF/"/>
    <id>http://yoursite.com/2017/12/31/阅读书籍/10_思维意识/20_精要主义/《每天最重要的2小时》读书笔记_乔西.戴维斯/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-02-12T07:40:50.674Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《每天最重要的2小时》 - 乔西.戴维斯</strong></p>
<blockquote>
<p>《Two Awesome Hours》 - Josh.Daivs</p>
</blockquote>
<p>目的：了解如何塑造最重要的2小时</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol>
<li>一个错误的方向：在更短的时间里做到更多。只有当我们错误地以为完全依赖于挤出足够多的时间，我们才会面对这种选择的压力。</li>
<li>具身认知：身体影响思维的方式的总称；说明身体上的动作会极大地影响到你的思维。</li>
<li>要想实现真正高产，最好的方法可能是抛弃 “效率” 这个念头，转而<strong><u>创造条件</u></strong>，让自己在每天当中都能拥有极为高效的量2小时。<ul>
<li><strong><u>意识到你的觉察点。</u></strong> 只要你开始一项任务，基本上就会处于<strong>自动工作的状态</strong>，这就很难改变你工作的方向。因此，要利用好<strong>不同任务交接时的那一刻</strong>，在这种时候你<strong>能够选择下一步该做什么</strong>，然后把精力放在接下来最重要的事情上面。</li>
<li>管理你的心理能量</li>
<li>不要与分心做无意义的斗争；了解你大脑的工作方式</li>
<li>利用你的身心联系：运动和饮食</li>
<li>让你的工作环境为你所用</li>
</ul>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="策略一：在日常工作中，认清最重要的事"><a href="#策略一：在日常工作中，认清最重要的事" class="headerlink" title="策略一：在日常工作中，认清最重要的事"></a>策略一：在日常工作中，认清最重要的事</h2><blockquote>
<p>意识到并抓住觉察点 </p>
</blockquote>
<h3 id="意识到每天的关键时刻-——-觉察点"><a href="#意识到每天的关键时刻-——-觉察点" class="headerlink" title="意识到每天的关键时刻 —— 觉察点"></a>意识到每天的关键时刻 —— 觉察点</h3><ol>
<li><strong>我们一旦开始了一项神经性常规活动，就会像电脑程序一样一直运行下去，直到<u>完成任务或者被打断</u>。</strong></li>
<li>我们的习惯很有必要，因为它们能够节省大脑的能量。（生物进化论的角度）</li>
<li>必须学会意识到 <strong>“觉察点”</strong> ，只有在这种时刻你才有机会也有能力决定自己如何度过接下来的时间。这种时刻就是<strong><u>你完成或者中断了任务</u></strong>的那个时刻；<ul>
<li>我们会如此频繁地进入自动模式，那么每天并没有那么多机会让我们有意识地决定下一步该做什么。因此<strong>意识到这些觉察点并抓住它们就显得极为重要。</strong></li>
<li>【原因】 <u>大家习惯于这种时刻（觉察点）匆忙略过，好去做某些让自己觉得 “很高效” 的事。</u>匆忙略过一个觉察点（即不同任务的间隙）也许能给你省出5分钟的时间，但是完成不该完成的任务可能会消费掉1个小时。<strong>这5分钟的确会让你不安。因为在这种时候，我们能够非常清楚地意识到每一秒的流逝，而在那浪费掉的一小时中因为名为基本上处于自动模式，所以不会察觉也不会觉得难受。</strong></li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="做出最恰当的选择"><a href="#做出最恰当的选择" class="headerlink" title="做出最恰当的选择"></a>做出最恰当的选择</h3><ol>
<li><p><strong>“认知上的懒惰者”</strong> ：在其他条件完全相同的情况下，我们倾向于选择在思维层面阻力最小的那条路。正因为那些无意识的、已经很熟练的神经性常规程序相对而言更容易完成，所以作为认知上的懒惰者，只要有可能就会更倾向于依赖自动的神经性常规行为，而不是有意识的选择；【原因】</p>
</li>
<li><p>在一步步完成神经性常规程序时，人们会进入一种 “忘我” 的状态。在此状态下，你意识不到周围发生的事。但<strong><u>当常规程序结束时或者被打断之后，自我意识就会浮现出来。</u></strong>从沉溺于神经性常规程度到停止这一程序，这之间的转变很可能让你感觉不适。</p>
<ul>
<li>两类思维：有目的、有意识的行为；自动的、无意识的行为；</li>
<li>意识最主要的功能就是在我们的自动式神经常规活动遇到困难的时候做出决定。<u>尤其是当不同的刺激性神经常规活动指导我们去做相互矛盾的动作的时候。</u></li>
</ul>
</li>
<li><p>觉察点通常 <strong><u>作为冲突的结果</u></strong> 而出现。（无意识的自动行为之间相冲突、行为和目标之间相冲突）</p>
<ul>
<li>两种行为（盯着电脑 VS. 转过去面对我朋友）是互相矛盾的，才需要这种有意识地评估并做出决定</li>
</ul>
<blockquote>
<p>【反思】解释了觉察点出现的原因以及场景</p>
</blockquote>
</li>
<li><p>你越是需要注意自己的思绪、情感和行为，你就越觉得时间流逝得慢。然后，这种不够 “高产” 的时间流逝，并不意味着你浪费了很多时间。这只是意味着我们<strong>恰巧更能意识到时间的存在而已。</strong> 而恰好正因为觉察这点会让人不舒服，所以我们往往才选择尽快跳过它们。</p>
</li>
</ol>
<p><br></p>
<h3 id="充分利用觉察点"><a href="#充分利用觉察点" class="headerlink" title="充分利用觉察点"></a>充分利用觉察点</h3><blockquote>
<p>珍惜每一个觉察点；提前为觉察点做好相应计划；不要随便开始一项新任务</p>
</blockquote>
<ol>
<li><p><strong>珍惜</strong>每一个觉察点：<strong>意识到觉察点的出现，并尽力抓住它；</strong></p>
<ul>
<li>觉察点能够让你与眼下最关注的时<strong>拉开一定的距离</strong>；</li>
</ul>
<blockquote>
<p>【共鸣】心理学中，两个自我：一个是正在做事的自我；一个是正在观察当下自我的那个自己；你只有意识到它，才有可能去改变它；</p>
</blockquote>
</li>
<li><p><strong><u>提前为觉察点做好相应计划；</u></strong> </p>
<ul>
<li>可能没办法知道被打断的确切时间，但我们知道这些情况发生的概率很大，而每一次打断都会创造一个觉察点</li>
<li><strong>[ IFTTT ]</strong> 可以<strong><u>提前决定</u>：当你被打断的时候，把那一刻变为觉察点；</strong> 这些打扰你的情况帮你从忘我状态中走出来，让你重新评估一下自己是否需要切换任务<ul>
<li><em>Eg：对他而言，工作方面的突发奇想往往是在他完全放松的时候出现，特别是在与家人共进晚餐的时候；于是，他提前为这个场景做了计划：如果当他陪着家人时突然灵关一现，那么就花2分钟评估一下这个想法的重要性</em></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>【思考】面对不同情境，提前设置规则，提前想象与演练；可以为一般情况建立规则，也可以每天为特定情况临时建立这种规则；</strong></p>
<p><em>研究表明，当我们在脑中设想某一行动时，所利用的神经回路其实和真正去做这件事时的神经回路是相同的；</em></p>
</blockquote>
</li>
<li><p><strong>不要随便开始一项新任务</strong>， 除非已经有意识地决定了它确实值得做</p>
<ul>
<li><strong>当你完成一项任务的时候，不要去想接下来做什么，而是把一刻标记为觉察点</strong><ul>
<li><em>Eg：当我结束了一节课之后我会对自己大声说 “现在就是个觉察点” 。这句话足够让我真个人停下来</em></li>
</ul>
</li>
<li><strong>再考虑一下自己目前的身体状态</strong> （是否疲劳、需要休息、喝水、食物），接下来有没有其他事情需要你花更多的能量去做以及你会在什么样的环境下工作</li>
</ul>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="策略二：管理你的心理能量"><a href="#策略二：管理你的心理能量" class="headerlink" title="策略二：管理你的心理能量"></a>策略二：管理你的心理能量</h2><blockquote>
<p><strong>必须把有限的心理能量全部留给今天最重要的内容</strong></p>
</blockquote>
<h3 id="让你心理疲惫的事物"><a href="#让你心理疲惫的事物" class="headerlink" title="让你心理疲惫的事物"></a>让你心理疲惫的事物</h3><ol>
<li>进行自我控制会削弱我们的自控力；</li>
<li>做决定（即使是一些典型的、日常的决定）也会导致心理上的疲惫，由此降低我们做出最佳表现；</li>
</ol>
<blockquote>
<p>【思考】先做最重要的事；知行合一；原因在于此</p>
</blockquote>
<p><br></p>
<h3 id="管理心理能量"><a href="#管理心理能量" class="headerlink" title="管理心理能量"></a>管理心理能量</h3><ol>
<li><strong>重视你身体的信号。</strong></li>
<li>如果在做完某项任务之感觉很累，很可能就是它消耗了大量的自控力；导致疲惫的活动：<ul>
<li>不断从一个任务转换到另一任务</li>
<li>交际、与人聊天</li>
<li>做计划、做决定等</li>
</ul>
</li>
<li>我们不需要完全避开这些活动，<strong>因为我们不需要每时每刻都处于最佳状态，因为这是不可能做到的</strong>；但是，我们可以策略性地安排待办事项的完成顺序，就能够<strong>分配出高效的2小时</strong>；</li>
<li>早上第一件事就是完成你最重要的工作，不要让你的大脑能力一开始就被几十个小决定消耗殆尽</li>
<li>考虑一下今天所有的待办事项，分类为 “重要的、创造性的、其他”</li>
<li><strong>在第二天有重要活动时，前一天晚上提前做一些决定，不要把它们留到第二天来浪费你的能力</strong></li>
<li>不要轻易承诺做完清单上的每一件事，因为这会浪费掉你本该用在最重要的事情上的能量</li>
<li><strong>必须把有限的心理能量全部留给今天最重要的内容</strong></li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="策略三：无须对抗分心也能更专注"><a href="#策略三：无须对抗分心也能更专注" class="headerlink" title="策略三：无须对抗分心也能更专注"></a>策略三：无须对抗分心也能更专注</h2><ol>
<li><p>从进化的角度来讲，人的大脑天生就不是为了无限专注于任何事；大脑的构造决定了它会不断在不同的注意点之间来回切换；如果做不到这一点，人类就很难生存下来；想象一下，当你正在采果子的时候也必须要时刻警惕有没有危险接近；</p>
</li>
<li><p>大脑从一个注意点<strong>切换到另一个注意点时</strong>，它会<strong>对那些不变的东西习惯性地视而不见</strong>；</p>
</li>
<li><p><strong>可以把那些没有必要存在和让你分心的东西都拿开；</strong></p>
</li>
<li><p><strong>在一段时间内，拿开、关闭或忽视 那些会令你分心的东西（某件物品、手机、即时通讯软件等）</strong></p>
<blockquote>
<p>当你在做一件事的时候，不要去看手机、邮箱、即时通讯软件；当你完成的时候在去看。在不同事物之间来回切换注意力，本身就很耗费能量</p>
</blockquote>
</li>
<li><p>不要指责自己没有专心致志，不妨静静旁观自己的思绪；只要能避免因无法专注而变得沮丧、疲惫或更加不专心，就能把注意力再次带回到手中的任务上来</p>
<blockquote>
<p>把无法长久维持注意力的问题归咎于我们个性上的缺陷，这是一个明显的误区</p>
</blockquote>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="策略四：掌握运动和饮食的诀窍"><a href="#策略四：掌握运动和饮食的诀窍" class="headerlink" title="策略四：掌握运动和饮食的诀窍"></a>策略四：掌握运动和饮食的诀窍</h2><ol>
<li>当你发现自己头昏脑涨、太过焦虑或者压力重重时，你应该换一种方式利用自己的身体（走动、跑步或做其他事），让自己 “重启” 一下。</li>
<li><strong>不要在桌子边坐得太久。当你意识到这一点，就站起身来走动一下。</strong></li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="策略五：让工作环境为你服务"><a href="#策略五：让工作环境为你服务" class="headerlink" title="策略五：让工作环境为你服务"></a>策略五：让工作环境为你服务</h2><blockquote>
<p>声音、光线</p>
</blockquote>
<h3 id="声音"><a href="#声音" class="headerlink" title="声音"></a>声音</h3><ol>
<li>虽然<strong>背景音乐</strong>通常能够提升积极的情绪，提高运动方面的表现，并让人们做事更加迅速，但同时它<strong>对阅读有着干扰效果。</strong></li>
<li><strong>比起有白噪声的环境，安全的环境对提高效率更有益；</strong> 如果能在安静的环境下工作，成效只会更出色</li>
<li>内向的人容易被各种刺激影响，所以对噪声干扰也更加敏感；</li>
<li><strong>对于那些需要运用知识才能完成的任务来说，安静的环境几乎无疑地优于有噪声的环境</strong></li>
<li><strong>背景音乐对创造性工作，有一定的促进作用；</strong></li>
</ol>
<p><br></p>
<h3 id="光线"><a href="#光线" class="headerlink" title="光线"></a>光线</h3><ol>
<li><strong>蓝白光</strong>对需要专注力和逻辑思考的分析性任务更有利</li>
<li><strong>暗淡光线对创造力更为有利</strong></li>
</ol>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《每天最重要的2小时》 - 乔西.戴维斯&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《Two Awesome Hours》 - Josh.Daivs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目的：了解如何塑造最重要的2小时&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《精要主义》读书笔记_格雷格.麦吉沃恩</title>
    <link href="http://yoursite.com/2017/12/31/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89/%E3%80%8A%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%E3%80%8B_%E6%A0%BC%E9%9B%B7%E6%A0%BC.%E9%BA%A6%E5%90%89%E6%B2%83%E6%81%A9_Grey.Mckeown/%E3%80%8A%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E6%A0%BC%E9%9B%B7%E6%A0%BC.%E9%BA%A6%E5%90%89%E6%B2%83%E6%81%A9_20171231/"/>
    <id>http://yoursite.com/2017/12/31/阅读书籍/10_思维意识/20_精要主义/《精要主义》_格雷格.麦吉沃恩_Grey.Mckeown/《精要主义》读书笔记_格雷格.麦吉沃恩_20171231/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-02-12T07:40:26.843Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《精要主义》_格雷格.麦吉沃恩</strong></p>
<blockquote>
<p>《Essentialism : The Disciplined Pursuit of Less》_ Grey.Mckeown</p>
</blockquote>
<p>目的：精要，即重要的事。懂得如何识别与运用；强化思维；为2018年成为一个精要的人做理论研究</p>
<a id="more"></a>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote>
<p><strong>如果你不能安排自己生活的优先次序，就只能任由别人来替你安排。</strong></p>
<p><strong>If you don’t prioritize your life, someone else will.</strong></p>
</blockquote>
<ol>
<li><p>精要主义是对 “更少，但更好” 的不懈追求。这意味着不是偶尔为之，而是<strong>把追求 “更少，但更好” 当做行事的铁律。</strong></p>
<ul>
<li>不断停下来反问自己 “这件事值得我投入时间和精力吗？”</li>
<li><strong>精要主义不是如何完成更多的事，而是如何做好对的事。</strong>它不是为了提倡少做而少做，而是主张做必做之事，尽可能做出最明智的时间和精力投资，从而达到个人贡献峰值；</li>
</ul>
</li>
<li><p>成功的悖论：<strong>社会中我们因为正确的行为（说 “不”）而受到惩罚，因不正确的行为（说 “好”）而受到奖赏。</strong>因为前者往往会令当时的气氛变得尴尬，而后者通常受到赞美；</p>
<ul>
<li>第一阶段：如果我们真的有清晰的目标，它有助于我们取得成功</li>
<li>第二阶段：当我们成功时，被冠以 “可以去找的人” 的称号，成为老好人。只要你需要，就总能找到这个人。这样，我们就能得到更多的选择和机会</li>
<li>第三阶段：当我们拥有了更多的选项和机会，实际上就被要求付出更多的精力和时间，这样便会导致精力的分散</li>
<li>第四阶段：因为精力分散，我们无法实现原本可以实现的个人贡献峰值；成功所带来的后果最终瓦解了最初指引我们走向成功的那个真正清晰的目标</li>
</ul>
<blockquote>
<p>成功会让我们偏离最本质的事情，这些事情最初曾是成功的源泉。</p>
</blockquote>
</li>
<li><p>选择的数量呈指数级增长：这是历史上第一次，拥有选择的人的数量有了极大的增加，而我们的社会却还未完全准备好这一切；</p>
</li>
</ol>
<p><br></p>
<h2 id="Part-1-精要主义者的核心思维模式"><a href="#Part-1-精要主义者的核心思维模式" class="headerlink" title="Part 1 精要主义者的核心思维模式"></a>Part 1 精要主义者的核心思维模式</h2><blockquote>
<p>时间与精力只用于有意义的事</p>
<p>选择 $\to$ 甄别 $\to$ 取舍</p>
</blockquote>
<ol>
<li>摆脱三种错误的想法<ul>
<li>我必须做</li>
<li>这些都重要</li>
<li>我能二者兼顾</li>
</ul>
</li>
<li>拥抱的三条核心真理<ul>
<li>我选择我要做的事</li>
<li>只有小部分事情是重要的</li>
<li>我能做任何事但不是所有事</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="选择：一种战无不胜的力量"><a href="#选择：一种战无不胜的力量" class="headerlink" title="选择：一种战无不胜的力量"></a>选择：一种战无不胜的力量</h3><blockquote>
<p>选择：选择如何支配自己的精力和时间；</p>
<p>非精要主义：我必须做 （丧失选择权） </p>
<p>​    精要主义：我选择做 （运用选择能力）</p>
<p><strong>选择是成为精要主义者的核心所在。必须高度重视选择能力，把它视为一种战无不胜的力量，它的存在独立于其他任何事物、任何人以及任何力量；</strong></p>
</blockquote>
<ol>
<li><p>一旦我们放弃自己选择的能力，别的力量或别人就会替我们做出选择；</p>
</li>
<li><p>人们常把选择视为一种事物，但它不是事物。我们面临的选项也许可以算做事物，但<strong>选择是一个行为动作。</strong></p>
<ul>
<li>我们也许无法完全左右自己会有哪些选项，但可以永远掌握自己如何从中选择；</li>
<li>选项（事物）会被拿走，但进行选择的核心能力（自由意志）却不会</li>
</ul>
<blockquote>
<p>选择能力不会被夺走，不会被丢弃，只会被遗忘； The ability to choose cannot be taken away or even given away —— it can only be forgotten.</p>
</blockquote>
</li>
<li><p>习得性无助；</p>
</li>
<li><p>强迫自己去做更多的方式不过是一种障眼法；这样的人不相信自己可以选择机遇、任何和挑战，而是认为自己 “必须什么都做” 。</p>
</li>
</ol>
<p><br></p>
<h3 id="甄别：几乎一切都是噪声"><a href="#甄别：几乎一切都是噪声" class="headerlink" title="甄别：几乎一切都是噪声"></a>甄别：几乎一切都是噪声</h3><blockquote>
<p>几乎一切都是噪声，只有少数事情有非凡价值。应该努力去辨别什么才是最重要的</p>
<p><strong>非精要主义：认为几乎一切都重要</strong>，将所有机会视之等同</p>
<p>​    <strong>精要主义：认为几乎一切都不重要</strong>；区分重要的少数和不重要的多数</p>
</blockquote>
<ol>
<li><strong>真正重要的是时间与结果之间的关系。</strong></li>
<li>重要少数法则（现代管理之父 - 朱兰）：人们可以通过解决问题中一个微小的部分来极大地提供产品的质量</li>
<li>幂次定律：某种努力与其他努力相比，确实会使成果呈指数级增长<ul>
<li>最优秀的软件工程师的开发效率比一般的软件工程师不是强10被或100倍，甚至不是1000倍，而是10000倍；</li>
</ul>
</li>
<li><strong>我们生活的世界中几乎一切都是无价值的</strong>，仅有极少的事物例外；几乎一切事物的次要性再怎么高估都不够。</li>
<li><strong>精要主义者用更多的时间来辨别，以便花更少的时间来做。</strong></li>
</ol>
<p><br></p>
<h3 id="取舍：我要的究竟是什么"><a href="#取舍：我要的究竟是什么" class="headerlink" title="取舍：我要的究竟是什么"></a>取舍：我要的究竟是什么</h3><blockquote>
<p>取舍：接受取舍的现实</p>
</blockquote>
<ol>
<li>你必须审视每一个机会，然后说， “不，我很抱歉。我们不想做那么多件不同的事情，如果它们对我们努力要实现的最终结果没有太大贡献的话” （Relevant）</li>
<li>在现实中，接受任何一个机会都无疑需要你舍弃其他几个机会。</li>
<li>我们要么自己做出艰难的选择，要么允许其他人替我们做出决定</li>
<li>【反思】价值观的体现，是在冲突中表现出来的；<ul>
<li>当一个人面对不用的情况如何做选择时，才真正体现了他的价值观；</li>
</ul>
</li>
<li>精要主义者<strong>不问 “我应该放弃什么？” 而是问 “我要大干一场的是什么？”</strong> ； 这样小小的改变，日积月累会产生意义深远的影响；</li>
</ol>
<p><br></p>
<h2 id="Part-2-第一步：探索"><a href="#Part-2-第一步：探索" class="headerlink" title="Part 2 第一步：探索"></a>Part 2 第一步：探索</h2><blockquote>
<p>区分；区分无意义的多数和有意义的少数</p>
<p>精要主义者花更多的时间用于探索、倾听、辩论、质问和思考。但是，<strong>探索本身不是他们的目的，真正的目的在于将有意义的少数从无意义的多数中甄别出来。</strong></p>
<p>精要主义实际上会探求更多的选项。他们在行动之前会系统地探索和评估多个选项，<strong>因为他们会在一两个大的项目上大干一场</strong>，所以一开始就会慎重地探索更多地选项，来确保自己做出的选择是正确的；</p>
<ul>
<li>几乎所有的事情都会引起非精要主义者的兴趣，也会引起他们的反应。但是，正因为如此忙于追逐每一个机会和每一种想法，他们实际上在选项探索上花费的精力少之又少。</li>
</ul>
</blockquote>
<p><br></p>
<h3 id="抽离：为探索和思考留出空间"><a href="#抽离：为探索和思考留出空间" class="headerlink" title="抽离：为探索和思考留出空间"></a>抽离：为探索和思考留出空间</h3><blockquote>
<p>非精要主义：忙得无暇顾及人生</p>
<p>​    精要主义：抽身而退，探索人生</p>
</blockquote>
<ol>
<li>人们习惯将 <strong>“焦点”</strong> 视为一种事物。焦点的确是我的拥有物，但它同时也是我的<strong><u>行为</u></strong>。</li>
<li><strong>为了找到焦点，我们需要抽身而退，全力聚焦； In order to focus we need to escape to focus.</strong></li>
<li>有意识地留出没有分心物的时间、没有分心物的空间，除了思考，绝不做任何别的事情<ul>
<li>向对方解释，在完成本书之前，都不要来打扰我；这种 “修行模式” 带给我的自由，怎么高估都不为过；</li>
</ul>
</li>
<li><strong>重要的是你要创造一个空间，让自己从忙碌的生活中抽身而退。</strong></li>
</ol>
<p><br></p>
<h3 id="审视：关注真正重要的事情"><a href="#审视：关注真正重要的事情" class="headerlink" title="审视：关注真正重要的事情"></a>审视：关注真正重要的事情</h3><blockquote>
<p>非精要主义：注意最大的声音；听所有说出来的话；被海量信息压垮</p>
<p>​    精要主义：关注声音传递的信号；听么有说出来的话；审视查找信息的精华</p>
</blockquote>
<ol>
<li>要理解这篇新闻到底意味着什么，以及它为什么重要。新闻记者的价值在于发现那些对人们真正重要的东西；</li>
<li><strong>写日志</strong>，成为自己人生的记者；并且<strong>每隔一段时间来回顾；</strong><ul>
<li>要捕捉标题，寻找自己每天、每周生活中的导语。</li>
</ul>
</li>
<li><strong>实地探索，认清问题本质</strong><ul>
<li>把自己置身于场景中；关键在于接触<strong>实际发生的那个场景</strong></li>
</ul>
</li>
<li><strong>捕捉不正常与不寻常</strong><ul>
<li>要汲取故事的精华，需要深刻理解它的主题和语境，需要将它放在一个更宏大的图景中去俯仰观察，需要找出他和其他领域的关联</li>
</ul>
</li>
<li>走出推诿逃避的怪圈</li>
</ol>
<blockquote>
<p>培养 “新闻记者” 的四种方法</p>
</blockquote>
<p><br></p>
<h3 id="游戏：拥抱内心孩童的智慧"><a href="#游戏：拥抱内心孩童的智慧" class="headerlink" title="游戏：拥抱内心孩童的智慧"></a>游戏：拥抱内心孩童的智慧</h3><blockquote>
<p>不要把游戏定义为仅仅是电子游戏；自己不爱电子游戏，但喜欢其他互动类的游戏；</p>
</blockquote>
<ol>
<li><p>学校在一定程度上是在扼杀创意。我们把自己卖给了一种快餐式的教育模式，它使我们的精神和活力日渐枯竭，就像快餐侵蚀我们的身体。想象力是人类一切成就的源泉。</p>
</li>
<li><p>那种 “游戏不重要” 的想法跟随我们。这是因为现在公司诞生于工业革命时期，那时它们存在的全部理由就是提高大规模生产产品的效率。而且，这些早期的管理者还把眼光朝向了军队。</p>
<blockquote>
<p>【反思】：理解一件事情，必须要去理解他的场景；SCQ在什么样的场景下产生了什么冲突，产生了什么行为，目的是什么</p>
</blockquote>
</li>
<li><p>当我们玩的时候，人性得到了最纯粹的表达，个性得到了最真实的展现；</p>
</li>
</ol>
<p><br></p>
<h3 id="睡眠：保护你的身心资产"><a href="#睡眠：保护你的身心资产" class="headerlink" title="睡眠：保护你的身心资产"></a>睡眠：保护你的身心资产</h3><blockquote>
<p>每晚，当我入睡时，我死去；次日，当我醒来时，我重生。—— 甘地</p>
</blockquote>
<ol>
<li>每个人的头等大事，是<strong><u>确保自己有能力</u></strong>决断什么才是头等大事； Our highest priority is to protect our ability to prioritize.</li>
</ol>
<p><br></p>
<h3 id="精选：只接受前10-的机会"><a href="#精选：只接受前10-的机会" class="headerlink" title="精选：只接受前10%的机会"></a>精选：只接受前10%的机会</h3><blockquote>
<p>非精要主义：接受一切要求和机会；运用宽泛的、盲从的标准（如果我认识的人在做，那我也应该做）</p>
<p>​    精要主义：只接受前10%的机会；<strong>运用挑剔的、明确的标准</strong>（这确实是我所追求的吗）</p>
</blockquote>
<ol>
<li><strong>如果答案不是一个确定的 YES，那么就应该是一个确定的 NO。</strong></li>
<li>90%法则：在做每一项决定或每一次选择的时候，<strong>评估每一项时，考虑一个最重要的决定标准，然后在0~10分之间为这个选项打分。如果得分低于9分，那就自动把它降为0，并且果断淘汰它。</strong><ul>
<li>如果某物/某事刚刚好或者差不多，正好是7分或8分，那么结果就是淘汰；这大大简化了问题。</li>
</ul>
</li>
<li>这种精挑细选的方法有着显而易见的好处：如果我们的选择标准过于宽泛，就会发现自己要面对的选项太多太多。更重要的是，对选项的价值进行评分，能让我们更自觉、更有逻辑、更加理性地做出选择，而不是听凭一时的兴趣或情绪所支配。</li>
<li>【关键】明确的标准；非精要主义运用的是一种盲从的、无法明确表达的标准；</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="Part-3-第二步：排除"><a href="#Part-3-第二步：排除" class="headerlink" title="Part 3 第二步：排除"></a>Part 3 第二步：排除</h2><blockquote>
<p>行动；摆脱无意义的多数。当我们丧失选择权的时候，别人会替我们做出选择。所以，要么慎重地有所不为，要么不由自主，任人摆布。</p>
<p>澄清：明确的目标  $\to​$ 边界：设定标准 $\to​$  勇气：选择项目 $\to​$ 放弃：已有项目及时终止</p>
</blockquote>
<ol>
<li>人们往往<strong>高估自己已经拥有东西的价值</strong>。于是扔掉这些东西就更难。<strong>问你一个问题（假设你还没有拥有它）</strong><ul>
<li>“如果没有它，我愿意花多少钱去买它” </li>
<li>“如果没有这个机会，我愿意做什么来得到它”</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="澄清：做一个以一当千的决定"><a href="#澄清：做一个以一当千的决定" class="headerlink" title="澄清：做一个以一当千的决定"></a>澄清：做一个以一当千的决定</h3><ol>
<li>从 “很清楚” 到 “真的很清楚”</li>
<li>目标SMART原则</li>
</ol>
<p><br></p>
<h3 id="边界：设定界限会带来自由"><a href="#边界：设定界限会带来自由" class="headerlink" title="边界：设定界限会带来自由"></a>边界：设定界限会带来自由</h3><blockquote>
<p>“不”， 是一个完整的句子。</p>
<p>非精要主义：认为如果有界限，自己将受到限制；视界限为约束</p>
<p>​    精要主义：<strong>懂得如果有界限，自己将不受限制；视界限为自由</strong></p>
</blockquote>
<ol>
<li><p>界限的丧失是非精要时代的典型特征；并且问题不仅在于界限已经模式，还在于工作的界限已经恶意侵蚀了家庭生活的领地；</p>
</li>
<li><p>精要主义者视界限为一种授权。界限保护了他们的时间，使之免受劫持。界限让他们摆脱了对有利于实现他人目标而非自身目标之事说 “不” 的负担。（因为他们知道，清晰的界限能让他们积极主动地淘汰各种要求和累赘之事）</p>
<blockquote>
<p><strong>设定边界，才能获得自由。If you have limits you will become limitless.</strong></p>
</blockquote>
</li>
<li><p>免受他人事务烦扰的方法</p>
<ul>
<li><p>别人的问题不是你的问题（如果把别人的问题变成我们的问题，那么我们就不是在帮他们，而是在纵容他们）</p>
<blockquote>
<p>【反思】这一点上，自己做的还是不错的；80分</p>
</blockquote>
</li>
<li><p>没有界限，就没有自由；</p>
</li>
<li><p>找到自己的坏事者（<strong>如果你不能和自己、和别人说清楚这些界限，那么你就不要期待别人能够尊重或者找到你的边界</strong>）</p>
<blockquote>
<p>【反思】这一点上，工作中，自己是有明确的边界</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li>指定契约/规则</li>
</ul>
<p><br></p>
<h3 id="勇气：优雅说”不”的力量"><a href="#勇气：优雅说”不”的力量" class="headerlink" title="勇气：优雅说”不”的力量"></a>勇气：优雅说”不”的力量</h3><blockquote>
<p>非精要主义：为了避免社交尴尬和压力而不说 “不”；应承一切事</p>
<p>​    精要主义：勇于坚定地、决绝地，优雅地说 “不”；只答应真正的要事</p>
</blockquote>
<ol>
<li><p>尽管拒绝别人时如此艰难，但如果不这样做，我们就会错过重要地多的东西；</p>
</li>
<li><p><strong>我们分不清什么才是重要的事情。所以当事情发生时，我们变得毫无防御能力。</strong> </p>
<blockquote>
<p>【反思】必须提前明确什么是重要的事，而不是当事情发生的时候在去考虑；当事情发生的时候，我们要做的仅仅是根据之前的标准去判断这件事</p>
</blockquote>
</li>
<li><p>优雅说 “不” 的六大原则</p>
<ul>
<li>把决定和关系分开来。（当别人让我们做什么的时候，我们往往会把这个要求和自己同他们的关系搅在一起）</li>
<li>并不代表一定要 “No” （我很想帮你，可是我已经力不从心了；但是我现在真的没有时间和精力）</li>
<li>关注权衡取舍<strong>（在答应的时候，对自己将要牺牲什么考虑得越多，拒绝就会变得越容易）</strong><ul>
<li>如果我们不能清晰地认识到机会成本（我们所放弃东西的价值），那么会很容易跌进非精要主义的陷阱</li>
</ul>
</li>
<li>接受自己不能始终让所有人都喜欢的现实；<strong>受人尊重比被人喜欢重要的多</strong></li>
<li><strong>一个明确的 “不” 比一个模糊的 “是” 更优雅</strong>  （延迟说那个最终还是要说的 “不” ，只会让它更难说出口）</li>
</ul>
</li>
<li><p>有效的说 “不” 的方法</p>
<ul>
<li>委婉的说 <strong>“不，但是”</strong> <ul>
<li>我现在在忙事情；但是我可以在后天的时候跟你聊一聊；到时如果你有时间的话</li>
</ul>
</li>
<li><strong>“好的。那我要取消的是什么”</strong><ul>
<li>对于来自重要人物的需求，告诉他们当前你正在负责的内容，以及如果你答应这件事，那么你将无法做其他事，让他们来解决这个取舍问题；</li>
</ul>
</li>
<li><strong>“这个我做不了，但是XX可能对此感兴趣”</strong>  （提供其他人的解决办法）<ul>
<li>人们在提出要求的时候，通常并不在乎帮助他们的究竟是不是我们，只要有人帮忙就行了。</li>
</ul>
</li>
</ul>
<blockquote>
<p>学会慢一点说 “好” ， 快一点说 “不”</p>
</blockquote>
</li>
</ol>
<p><br></p>
<h3 id="放弃：止损就是最大的赢"><a href="#放弃：止损就是最大的赢" class="headerlink" title="放弃：止损就是最大的赢"></a>放弃：止损就是最大的赢</h3><blockquote>
<p>人生中一半的麻烦源于答应得太快，拒绝得太慢。</p>
<p>非精要主义：”为什么现在要停止这个项目，我已经在这上面投入了这么多”</p>
<p>​    精要主义：”如果不是之前已经有投资，我现在愿意在这个项目上投入多少”</p>
</blockquote>
<ol>
<li><strong>陷阱1：禀赋效应</strong>（The Endowment Effect）：当一个人没有某件物品时，他就倾向于低估这件物品的价值；而当他一旦拥有该物品，就会倾向于高估它的价值；<ul>
<li>生活中，一旦你想放弃它们的时候，它们就会显得更加有价值；想象一下，一本闲置在书架上多年未翻的书，一个仍未开封的笔记本；</li>
</ul>
</li>
<li><strong>对策1：假装未曾拥有它</strong><ul>
<li>问 “如果手头没有，我愿意花多少钱来得到它”  （而不是 “这件物品估值多少”）</li>
<li>问 “如果没有这个机会，我愿意花多大的代价去得到它”</li>
<li>问 “如果我不是已经参与了这个项目，我愿意花多少代价参与其中”</li>
</ul>
</li>
<li><strong>陷阱2：对浪费的恐惧</strong><ul>
<li>选择真正想去做的，忽视沉没成本</li>
</ul>
</li>
<li><strong>对策2：承认失败，让成功开始</strong> （承认错误，没有什么可羞耻的。因为我们真正承认的，现在的自己比过去更明智了）</li>
<li>陷阱3：害怕过错</li>
<li>对策3：逆向试行<ul>
<li>最小可行性产品；反向应用，<strong>检验取消一项尝试或活动是否会产生负面效应；</strong></li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="编辑：看不见的艺术"><a href="#编辑：看不见的艺术" class="headerlink" title="编辑：看不见的艺术"></a>编辑：看不见的艺术</h3><blockquote>
<p>非精要主义：认为改善就意味着要增加；对每个词、形象和细节都恋恋不舍；</p>
<p>​    精要主义：<strong>认为改善就是需要删减；</strong>删减分散注意力的词、形象和细节</p>
</blockquote>
<ol>
<li>剪辑，就是严格淘汰那些无意义的、不重要的或不相关的内容。它是一种精要工艺。</li>
<li>编辑人生的原则<ul>
<li>删减，自律地抛弃</li>
<li>精缩，有有意义的活动取代无意义的活动（你能不能只用一个句子，而不是两个，就把意思说清楚？现在用两个词的地方能不能只用一个词）<ul>
<li>用更少的词表达同样的思想，用更小的空间获得同样的功用，或者用更小的努力获得同样的成就。</li>
</ul>
</li>
<li>纠正，反观核心，调整方向</li>
</ul>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="Part-4-第三步：执行"><a href="#Part-4-第三步：执行" class="headerlink" title="Part 4 第三步：执行"></a>Part 4 第三步：执行</h2><blockquote>
<p>让有意义的少数做起来毫不费力；</p>
<p>关于执行，非精要主义者通常用蛮力执行；精要主义者则通过<strong>淘汰无意义之事来节省时间，并设计一套体系，让执行变得毫不费力。</strong>  即一旦确定了哪些行为和努力在人生中加以保留，就必须/应该要设计一套体系来执行。</p>
<p>扫除：扫除目标上的主要障碍 $\to$ 进步：最低可行性进步&amp;准备 $\to$ 心流：触发器 - 程序 - 习惯 $\to$ 专注</p>
</blockquote>
<h3 id="缓冲：充足准备带来优势"><a href="#缓冲：充足准备带来优势" class="headerlink" title="缓冲：充足准备带来优势"></a>缓冲：充足准备带来优势</h3><ol>
<li>通常会议的最后10分钟被用于提问和评论，但他却坚持留出整整一个小时</li>
<li><strong>出发前，提前一周就开始打包。</strong><ul>
<li>提前打包；说不定期间你会突然想起什么</li>
</ul>
</li>
<li>设置缓冲区<ul>
<li>做完善的准备</li>
<li>比预计时间多留50%<ul>
<li>规划谬误（丹尼尔.卡尼曼）：人们倾向于低估任务完成所需的时间，即便是在以前已经承担过相同任务的情况下也是如此</li>
</ul>
</li>
<li>做好情景规划</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="扫除：锁定你的”最慢行进者”"><a href="#扫除：锁定你的”最慢行进者”" class="headerlink" title="扫除：锁定你的”最慢行进者”"></a>扫除：锁定你的”最慢行进者”</h3><ol>
<li><strong><u>锁定你的 “最慢行进者” 之后，想尽一切办法来提高它的速度</u></strong>（不同于木桶理论；在完成一项事的过程中，<strong>用一切办法来克服</strong>，而不仅仅是通过自身的努力，<strong>完全可以是借助他人的力量或寻求他人的帮助</strong>）<ul>
<li>现状：一群人向山顶走去，但速度有快有慢；<ul>
<li>起初的办法让走在前面的人停下来等待，但只能用于一时；很快就又会产生差距</li>
<li>之后按速度排列：从最慢到最快；但劣势是以最慢的那个人的速度在前进</li>
</ul>
</li>
<li>对策：想尽一切办法为走在第一个最慢的人减负（因为走的最慢的那个人决定了整个队伍的速度；哪怕是任何一点加速，都会对整个队伍的行进速度产生影响）</li>
</ul>
</li>
<li>扫除 “最慢行进者” ：<strong>精要主义者不关注需要增加哪些精力和资源，而是关心哪些限制和障碍需要连根拔起；</strong><ul>
<li>弄清核心目标，确定要扫除的障碍是什么；</li>
<li>锁定障碍，但不要试图一下子扫除所有障碍；<ul>
<li>目标：完成报告的草案；</li>
<li>因此任何延缓此目标执行的活动都是值得怀疑的；</li>
<li>妨碍目标实现的障碍会有很多。然后在任何一个特定的时间，有且只有一个重要事件。</li>
</ul>
</li>
<li>扫除障碍，从小处开始；<ul>
<li>目标：完成报告的草案</li>
<li>考虑：<strong>完成比完美更重要</strong></li>
</ul>
</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="进步：小胜的价值"><a href="#进步：小胜的价值" class="headerlink" title="进步：小胜的价值"></a>进步：小胜的价值</h3><ol>
<li><p>鼓舞进步所具有的力量。</p>
</li>
<li><p><strong>小小的但实实在在的胜利能够创造推动力，并让人们对自己未来的成功持肯定的信念。</strong></p>
<ul>
<li><strong>成就</strong> 和 <strong>对成就的认可</strong>，是人类行为两大主要的内在驱动力。</li>
<li>要真正做好重要的事情，<strong>必须从小处着手，创造动力。</strong> （To really get essential things does we need start small and build momentum. ） 然后，运用这种动力创造下一个胜利，长此以往，直至取得重大突破。</li>
<li>一种错误的逻辑：要干大事，就必须从大处着手；</li>
</ul>
</li>
<li><p>鼓励小胜</p>
<ul>
<li><p>关注最低可行性进步 （完成比完美更重要）</p>
</li>
<li><p><strong><u>做最低可行性准备：早而小</u></strong> </p>
<ul>
<li>“早而小” ，意味着以尽可能少的时间投入，尽可能早地开始 </li>
<li>有一位领导者，他非常善于发表激动人心的演说；他解释说自己的秘诀就是在演说的6个月前就开始为这些内容做准备。<strong>但不是准备整个讲稿，只是开始而已。</strong></li>
<li>如果未来几个星期有一个重大报告要做，那么你现在就打开文件，花4分钟时间，想到什么就写什么。然后关闭文件；无需太长时间，<strong>开始就够了。</strong></li>
<li>任何时候安排了会议或有电话要打，精确地花15秒钟备忘一下那个会议的主题；这样开会当天，只需要参考这个备忘录就可以了。</li>
</ul>
<blockquote>
<p>应对一个重要目标：早动手，小步前进；并且质量/效果往往更佳（因为大脑需要时间去吸收、整理；）</p>
</blockquote>
</li>
<li><p><strong>直观地嘉奖进步</strong></p>
<ul>
<li>直观地看到自己正朝着目标进步，会产生一种巨大的力量。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>人是会被机制/制度/环境所影响的。不要高估自己的意志力。</p>
<p>改变孩子爱看电视的行为：<em>每周一开始，孩子们可以领到10个代币。每个代币可以换30分钟屏幕时间，或者在周末的时候换50美分；如果哪个孩子读书30分钟，那他就可以获得一个额外的代币；结果是一夜之间，屏幕时间下降了90%，读书时间上升了同样的百分比；</em></p>
</blockquote>
<p><br></p>
<h3 id="心流：常规造就天才"><a href="#心流：常规造就天才" class="headerlink" title="心流：常规造就天才"></a>心流：常规造就天才</h3><blockquote>
<p>非精要主义：凭蛮力执行重要任务；让非重要事物成为默认选项</p>
<p>​    精要主义：<strong>设计一种处理重要事务的常规，让重要事务处于默认状态，让执行毫不费力；</strong></p>
</blockquote>
<ol>
<li><p>大脑中进行假想演练，是会非常有效的方法；（菲尔普斯每天都在脑中假想自己的动作）</p>
<blockquote>
<p>因为大脑中的神经元之间的联系得到了加强</p>
</blockquote>
</li>
<li><p>释放常规的力量</p>
<ul>
<li><p>彻底检修你的触发器</p>
<ul>
<li>《习惯的力量》：每一个习惯都是由 “刺激、常规、激励” 组成；如果想改变自己的常规，并不需要真的去改变行为。</li>
</ul>
</li>
<li><p>创建<strong>新的触发器</strong></p>
<ul>
<li>通过<strong>设置场景（物理上的提醒更加有效）</strong>来创建触发器</li>
<li>并且<strong><u>充分利用已有的习惯</u></strong>， 而不是费力去创建新的习惯</li>
</ul>
<blockquote>
<p>有人养成了每天在固定时间写下内容的习惯；虽然听上去很容易，但我们知道自己 <strong>[需要某种刺激物来提醒]</strong> 自己在每天特定时间内写作，否则会像以前那样拖延；</p>
<p>因此，<u>开始把日记本放在包里，紧挨着手机</u>；这样，每天晚上当我把手机从包里拿出来充电时，我就会看到日记本，它会提醒我在上面写东西；</p>
</blockquote>
</li>
<li><p>先做最困难的部分</p>
<ul>
<li>运用上述方法建立一种常规，让攻克一天中最困难的任务成为每天早上的第一件事。找到一种<strong>刺激物</strong> （可以是出现在写字台上的第一杯橙汁，还是手机上的闹铃，或是<strong><u>任何一件你已经习惯</u></strong>一大早就最先做的事情）来出发你坐下来，把精力集中到最难的事情上去</li>
</ul>
</li>
<li><p>建立混合型常规</p>
</li>
<li><p>逐个击破</p>
</li>
</ul>
</li>
</ol>
<p><br></p>
<h3 id="专注：当下最重要的是什么"><a href="#专注：当下最重要的是什么" class="headerlink" title="专注：当下最重要的是什么"></a>专注：当下最重要的是什么</h3><ol>
<li><p>专注于最重要的东西，就是<strong>专注于此时此刻。</strong></p>
<ul>
<li><em>全身心投入吃饭的这一刻：当我缓慢地吃下第一口食物时，变化出现了。我注意到了自己的呼吸。觉得全身心地融入了此处。</em>；    <em>看他做食物，发现他整个人都沉浸进去了</em></li>
</ul>
</li>
<li><p>在担心过去或未来上花费的任何一秒钟，都在分散抽离着你对此时此刻地重要事务的关注。</p>
</li>
<li><p>同时做两件事轻而易举，但同时<strong><u>专注于</u></strong>两件事是几乎不可能的；</p>
</li>
<li><p>活在当下</p>
<ul>
<li><p>想清楚当下最重要的是什么</p>
<ul>
<li>当你面临很多任务，以至于不知该从何下手时，停下来，深呼吸；投入到当下，问问自己此时此刻最重要的是什么。不是明天，甚至也不是一小时后最重要的是什么。如果不确定，那就把所有争抢你注意力的事情都列出来，然后划掉此时此刻不重要的事情</li>
</ul>
</li>
<li><p>把未来清除出去，会更加专注于当下</p>
<ul>
<li><strong>把出现的想法记录下来，写下来</strong>；但这个清单并不是记录承诺的，只不过把这些想法从大脑中清除出去，留在本子上而已；</li>
</ul>
<blockquote>
<p><strong>保证了不会忘记这些想法，他们也许将来会被证明有用</strong></p>
<p><strong>减轻了大脑的负担；减轻了必须现在就去执行的那种压迫感和分心的危险</strong></p>
</blockquote>
</li>
<li><p>排列优先次序</p>
</li>
</ul>
</li>
<li><p>凯洛斯时刻：用来更新的停顿（他只是停顿一会儿，闭上眼睛，缓慢地深呼吸一次）</p>
<ul>
<li>这更像是一种仪式，一种触发器；告诉自己，那个已经过去了。（在走入家门前，他这这种停顿的方式把工作的事情抛在脑后）</li>
</ul>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>存在，设计你的精要人生</p>
</blockquote>
<ol>
<li><p>把<strong>精要主义</strong>作为处理所有事情的<strong>生活方式</strong>；过一种有目的、有意义的生活；</p>
<blockquote>
<p>出差时，不要电视或电影，以便有时间思考和休息</p>
<p>经常一整天都在做当天最重要的事，哪怕这意味着做不了其他任务</p>
</blockquote>
</li>
<li><p>“成功的悖论” 。我们有明确的目标，它能指引我们走向成功。但是，成功给我带来了新的选项。这听起来很美妙。但要警惕，这些选项会在无意间分散我们的注意力，引诱我们偏离正确的轨道；</p>
</li>
<li><p><strong>当你感受到这些想法的真实性时，它们就拥有了改变你的力量。</strong></p>
<blockquote>
<p><strong>As these ideas become essentially true, they take on the power to change you .</strong></p>
</blockquote>
</li>
<li><p><strong>在合适的时机向适宜的对象传递恰当的信息</strong></p>
<blockquote>
<p>Communicating the right information to the right people at the right time.</p>
<p><strong>【反思】不要给接受信息者无谓的干扰信息；你要对你要传达的信息做选择</strong></p>
</blockquote>
</li>
<li><p>精要领导者</p>
<ul>
<li>对人才招聘挑剔地近乎荒谬（一次错误招聘的代价要远远大于一个人手短缺）</li>
<li>在真正明确核心意图之前，不要停止争论</li>
<li>支持极端授权（<strong>授权的关键在于明确性。</strong>它不会让角色定位过于原则性和模糊性。它会保证让团队中的每个人都清楚自己改做出什么贡献，以及其他员工都在贡献什么）</li>
<li>在合适的时机合适的人传递恰当的信息</li>
</ul>
</li>
<li><p>“世界上有一种东西比所有的军队都要强大，那就是恰逢其实的一种理想。” By 维克多 $\cdot$ 雨果 - 法国作家</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《精要主义》_格雷格.麦吉沃恩&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《Essentialism : The Disciplined Pursuit of Less》_ Grey.Mckeown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目的：精要，即重要的事。懂得如何识别与运用；强化思维；为2018年成为一个精要的人做理论研究&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>《专注力》读书笔记_于尔根.沃尔夫</title>
    <link href="http://yoursite.com/2017/12/31/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/10_%E6%80%9D%E7%BB%B4%E6%84%8F%E8%AF%86/20_%E7%B2%BE%E8%A6%81%E4%B8%BB%E4%B9%89/%E3%80%8A%E4%B8%93%E6%B3%A8%E5%8A%9B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0_%E4%BA%8E%E5%B0%94%E6%A0%B9.%E6%B2%83%E5%B0%94%E5%A4%AB_Jurgen.wolff/"/>
    <id>http://yoursite.com/2017/12/31/阅读书籍/10_思维意识/20_精要主义/《专注力》读书笔记_于尔根.沃尔夫_Jurgen.wolff/</id>
    <published>2017-12-30T16:00:00.000Z</published>
    <updated>2018-02-12T07:41:02.608Z</updated>
    
    <content type="html"><![CDATA[<p><strong>《专注力：化简为繁的惊人力量》（第2版）_于尔根.沃尔夫</strong></p>
<blockquote>
<p>《Focus : Use the power of targeted thinking to get more done》_Jurgen.wolff</p>
</blockquote>
<p>本书是关于 “怎样做” 的内容；而非关于 “什么”</p>
<a id="more"></a>
<p><br></p>
<h2 id="找到专注的焦点"><a href="#找到专注的焦点" class="headerlink" title="找到专注的焦点"></a>找到专注的焦点</h2><ol>
<li><p>80%的时间里我们都在关心哪些事情没做好；若将注意力集中在我们做好了什么上才是加速进程的关键； 《改变你看待事物的方式》 凯萨琳.克拉默</p>
</li>
<li><p>注意他人所做的积极而有价值的事情，花点时间去赞美。优秀的项目经理知道培训员工的最好方式是强化他们的有效行为；</p>
</li>
<li><p><strong>“零容忍” 策略</strong>：假装自己还未拥有/投入</p>
<ul>
<li>如果我当时没有开始看这本书，我现在还会继续看吗？（当你看了一半的时候越看越觉得这本书没意思）</li>
<li>如果我当时没有买这个，现在会愿意花多少钱去买？</li>
</ul>
</li>
<li><p>实现目标的过程</p>
<ol>
<li>设定一个SMART目标</li>
<li>开始做一切你认为可以帮助你实现目标的事情</li>
<li>对过程效果进行监控；如果你做的事情并没有给你带来想要的结果，那就需要赶快调整，找到替换措施做些改变</li>
<li>坚持战略（若无法坚持时，考虑如下原因）<ul>
<li><strong>对策略尝试了很长时间，但并不奏效</strong>；此时需要头脑风暴，设想一个新的策略并开始</li>
<li><strong>仅仅是忘记了而没有执行</strong>，说明这个策略不太方便；因此<strong>你需要一个更轻松、更容易上心的方式来做这件事</strong></li>
</ul>
</li>
<li>重复第3和第4，直至实现你的目标（可能失败的唯一原因就是你的自我放弃）</li>
</ol>
</li>
<li><p><strong>你无法专注于看不见的事物</strong>：若要保证每天花时间做对你最重要的事，那就<u><strong>在身边确保一个与此相关的视觉或听觉符号</strong></u>（照片或图画、单词、短语或一段音乐）； 并且<strong>定期改变这个符号</strong>，这能帮助你更新其力量以提醒你行动</p>
<blockquote>
<p>【共鸣】必须要定期改变符号，否则很容易忽视；因为人的大脑就是习惯于忽略不变的内容</p>
</blockquote>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="专注策略"><a href="#专注策略" class="headerlink" title="专注策略"></a>专注策略</h2><ol>
<li><p>当你识别出消极模式，要弄清楚这一模式给你带来了什么</p>
<ul>
<li>想要跳槽却从不才行动的人所收获的，是永远不必被拒绝的风险；</li>
<li>只要是一直在计划，那就不会失败</li>
</ul>
</li>
<li><p>关键要找出对你有用的方式，这是不断尝试的过程；不要指望你试着做的第一件事会有一个完美的解决方案；（这才是普遍现象）</p>
</li>
<li><p><strong><u>分配任务：评估哪些工作是可以分配给其他人去做的。你的目标是尽可能多地把时间利用在能给你带来最大价值的事情上；</u></strong> </p>
<blockquote>
<p>【反思】：知行合一；你没有这么去做，是因为你没有真正理解这件事情的价值</p>
</blockquote>
</li>
<li><p>我们往往没有去做真正要做的事；因为很多时候，做其他事比做我们必须要做的事情更有趣。</p>
<ul>
<li>低附加价值活动倾向于那些容易的、不会给人带来恐慌甚至可能是让人身心愉悦的事</li>
</ul>
</li>
<li><p>迈出第一步：分解任务，去做真正要做的事</p>
<ul>
<li>很多时候，因为事情本身无趣或者困难使我们根本不愿意去做；换个视角，<u><strong>不要去想找个任务会怎么样，而是想想你会怎么样。</strong></u> （比如一旦你打完这个电话，你将会感觉多轻松？不用为这件事烦恼将会有多美好？）</li>
</ul>
</li>
<li><p><strong>选择</strong>你觉得<strong>做起来有趣的部分开始</strong>； 这么做的同时你已经为剩余的工作准备好了冲动。</p>
<ul>
<li>如果你正在写一篇销售，你可能已经对最后的场景做了设想。那么完全可以也应该先写下这一部分的内容</li>
</ul>
</li>
<li><p>通常发现给你带来最多价值的那20%的事情你已经在做了，只是你做的还不够而已。</p>
</li>
</ol>
<p><br></p>
<p><br></p>
<h2 id="专注工具"><a href="#专注工具" class="headerlink" title="专注工具"></a>专注工具</h2><ol>
<li><p><strong>信息处理 - 选择与忽略 </strong> </p>
<ul>
<li>在接触新信息时，先快速提醒自己此时对自己最有吸引力的话题、和你目标最重要的话题</li>
<li>如果你知道这条信息<strong>并不相关，那就不要去看它</strong>，直接丢弃或者将它放置一边，直到它所包含的信息可能更加相关时再去看。</li>
</ul>
</li>
<li><p>先洗出所有可能会做的事情（待办清单），再从中自己筛选并排序对你来说最重要的任务</p>
<blockquote>
<p>首先处理真正有价值的任务会让你这天的时间感觉轻松很多</p>
</blockquote>
</li>
<li><p><strong>休息和反思</strong> 这两项不应该成为首先被牺牲的选项</p>
</li>
<li><p><strong>在处理完一件事情之前，不要收邮件，不要看RTX，不要看微信；直至完成这件事为止；</strong></p>
<p>​</p>
</li>
</ol>
<p><br></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;《专注力：化简为繁的惊人力量》（第2版）_于尔根.沃尔夫&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《Focus : Use the power of targeted thinking to get more done》_Jurgen.wolff&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本书是关于 “怎样做” 的内容；而非关于 “什么”&lt;/p&gt;
    
    </summary>
    
      <category term="阅读书籍" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="阅读书籍" scheme="http://yoursite.com/tags/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
</feed>
